# Story 31.4: Тесты для logout функциональности

## Status

Approved

---

## Story

**As a** frontend developer,
**I want** написать комплексные тесты для logout,
**so that** функциональность надёжна и без багов.

---

## Acceptance Criteria

1. Unit-тесты покрывают desktop и mobile версии кнопки "Выйти"
2. Тесты проверяют вызов `authStore.logout()` при клике
3. Integration-тесты проверяют вызов backend API через MSW
4. Тесты проверяют очистку tokens, cookies, localStorage
5. Тесты проверяют редирект на главную страницу
6. Coverage для новых функций >= 90%
7. Все тесты проходят в Vitest

---

## Tasks / Subtasks

- [ ] **Task 1: Настроить MSW mock для /auth/logout/ endpoint** (AC: 3)
  - [ ] Добавить handler для успешного ответа 204 No Content
  - [ ] Добавить handler для ошибки 400 Bad Request (invalid token)
  - [ ] Добавить handler для ошибки 401 Unauthorized
  - [ ] Добавить handler для network error симуляции

- [ ] **Task 2: Unit-тесты для Header.tsx - кнопка "Выйти"** (AC: 1, 2)
  - [ ] Тест: Кнопка "Выйти" отображается для авторизованных пользователей (desktop)
  - [ ] Тест: Кнопка "Выйти" отображается для авторизованных пользователей (mobile)
  - [ ] Тест: Кнопка "Выйти" НЕ отображается для неавторизованных пользователей
  - [ ] Тест: При клике вызывается `handleLogout`
  - [ ] Тест: При клике вызывается `authStore.logout()`

- [ ] **Task 3: Integration-тесты для authStore.logout()** (AC: 3, 4)
  - [ ] Тест: Вызывается `authService.logoutFromServer()` с refresh токеном
  - [ ] Тест: При успехе API (204) очищается state, localStorage, cookies
  - [ ] Тест: При ошибке API (400/401) локальная очистка всё равно происходит (fail-safe)
  - [ ] Тест: При network error локальная очистка происходит

- [ ] **Task 4: Integration-тесты для authService.logoutFromServer()** (AC: 3)
  - [ ] Тест: POST запрос отправляется на `/api/v1/auth/logout/`
  - [ ] Тест: Request body содержит `{ "refresh": "token_value" }`
  - [ ] Тест: При успехе (204) возвращается resolved Promise
  - [ ] Тест: При ошибке (400) логируется ошибка, не выбрасывается исключение

- [ ] **Task 5: Integration тесты для полного logout flow** (AC: 4, 5)
  > ⚠️ Это integration-тесты с RTL, не настоящие E2E (Playwright/Cypress)
  - [ ] Тест: Клик на "Выйти" → очистка токенов → редирект на `/`
  - [ ] Тест: После logout Header показывает "Войти"/"Регистрация"
  - [ ] Тест: `isAuthenticated` становится `false`
  - [ ] Тест: localStorage.refreshToken удалён
  - [ ] Тест: Cookie refreshToken удалён

- [ ] **Task 6: Проверить coverage и добавить недостающие тесты** (AC: 6, 7)
  - [ ] Запустить `npm run test:coverage`
  - [ ] Проверить coverage >= 90% для новых функций
  - [ ] Добавить edge-case тесты при необходимости
  - [ ] Убедиться что все тесты проходят

---

## Dev Notes

### Relevant Source Tree

```
frontend/src/
├── __mocks__/
│   └── handlers.ts                      # MODIFY: добавить logout handlers
├── services/
│   └── authService.ts                   # TEST: logoutFromServer()
├── stores/
│   └── authStore.ts                     # TEST: logout()
├── components/
│   └── layout/
│       └── Header.tsx                   # TEST: logout button + handleLogout
└── __tests__/
    ├── services/
    │   └── authService.test.ts          # CREATE: тесты для logoutFromServer
    ├── stores/
    │   └── authStore.test.ts            # MODIFY: тесты для logout()
    └── components/
        └── layout/
            └── Header.test.tsx          # MODIFY: тесты для logout button
```

### Зависимость от Story 31.1, 31.2, 31.3

**Story 31.1 (Prerequisite):**
- Добавляет кнопку "Выйти" в Header (desktop + mobile)

**Story 31.2 (Prerequisite):**
- `authService.logoutFromServer()` - метод для вызова backend API
- `authStore.logout()` - async метод с fail-safe подходом

**Story 31.3 (Prerequisite):**
- `handleLogout` обработчик с редиректом на `/`

### MSW Handlers для Logout

```typescript
// frontend/src/__mocks__/handlers.ts
import { http, HttpResponse } from 'msw';

// Добавить к существующим handlers
export const logoutHandlers = [
  // Успешный logout (204 No Content)
  http.post('/api/v1/auth/logout/', () => {
    return new HttpResponse(null, { status: 204 });
  }),
];

// Handler для ошибки invalid token
export const logoutErrorHandler = http.post('/api/v1/auth/logout/', () => {
  return HttpResponse.json(
    { detail: 'Invalid or expired token' },
    { status: 400 }
  );
});

// Handler для unauthorized
export const logoutUnauthorizedHandler = http.post('/api/v1/auth/logout/', () => {
  return HttpResponse.json(
    { detail: 'Authentication credentials were not provided.' },
    { status: 401 }
  );
});

// Handler для network error
export const logoutNetworkErrorHandler = http.post('/api/v1/auth/logout/', () => {
  return HttpResponse.networkError('Failed to connect');
});
```

### Тесты для authService.logoutFromServer()

```typescript
// frontend/src/__tests__/services/authService.test.ts
import { describe, it, expect, beforeAll, afterAll, afterEach } from 'vitest';
import { setupServer } from 'msw/node';
import { http, HttpResponse } from 'msw';
import { authService } from '@/services/authService';

const server = setupServer();

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('authService.logoutFromServer()', () => {
  it('sends POST request to /api/v1/auth/logout/ with refresh token', async () => {
    let capturedBody: any;
    
    server.use(
      http.post('/api/v1/auth/logout/', async ({ request }) => {
        capturedBody = await request.json();
        return new HttpResponse(null, { status: 204 });
      })
    );

    await authService.logoutFromServer('test-refresh-token');

    expect(capturedBody).toEqual({ refresh: 'test-refresh-token' });
  });

  it('resolves successfully on 204 response', async () => {
    server.use(
      http.post('/api/v1/auth/logout/', () => {
        return new HttpResponse(null, { status: 204 });
      })
    );

    await expect(authService.logoutFromServer('token')).resolves.not.toThrow();
  });

  it('does not throw on 400 error (fail-safe)', async () => {
    server.use(
      http.post('/api/v1/auth/logout/', () => {
        return HttpResponse.json(
          { detail: 'Invalid token' },
          { status: 400 }
        );
      })
    );

    // Должен логировать ошибку, но не выбрасывать исключение
    await expect(authService.logoutFromServer('invalid-token')).resolves.not.toThrow();
  });

  it('does not throw on network error (fail-safe)', async () => {
    server.use(
      http.post('/api/v1/auth/logout/', () => {
        return HttpResponse.networkError('Failed to connect');
      })
    );

    await expect(authService.logoutFromServer('token')).resolves.not.toThrow();
  });
});
```

### Тесты для authStore.logout()

```typescript
// frontend/src/__tests__/stores/authStore.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { useAuthStore } from '@/stores/authStore';
import { authService } from '@/services/authService';

// Mock authService
vi.mock('@/services/authService', () => ({
  authService: {
    logoutFromServer: vi.fn(),
  },
}));

describe('authStore.logout()', () => {
  beforeEach(() => {
    // Setup authenticated state
    useAuthStore.setState({
      isAuthenticated: true,
      user: { first_name: 'Иван', role: 'retail' },
      accessToken: 'test-access-token',
    });
    localStorage.setItem('refreshToken', 'test-refresh-token');
    vi.clearAllMocks();
  });

  afterEach(() => {
    localStorage.clear();
  });

  it('calls authService.logoutFromServer with refresh token', async () => {
    await useAuthStore.getState().logout();

    expect(authService.logoutFromServer).toHaveBeenCalledWith('test-refresh-token');
  });

  it('clears state on successful API call', async () => {
    (authService.logoutFromServer as vi.Mock).mockResolvedValue(undefined);

    await useAuthStore.getState().logout();

    const state = useAuthStore.getState();
    expect(state.isAuthenticated).toBe(false);
    expect(state.user).toBeNull();
    expect(state.accessToken).toBeNull();
  });

  it('clears localStorage on successful API call', async () => {
    (authService.logoutFromServer as vi.Mock).mockResolvedValue(undefined);

    await useAuthStore.getState().logout();

    expect(localStorage.getItem('refreshToken')).toBeNull();
  });

  it('clears state even when API fails (fail-safe)', async () => {
    (authService.logoutFromServer as vi.Mock).mockRejectedValue(new Error('API Error'));

    await useAuthStore.getState().logout();

    const state = useAuthStore.getState();
    expect(state.isAuthenticated).toBe(false);
    expect(state.user).toBeNull();
    expect(state.accessToken).toBeNull();
  });

  it('clears localStorage even when API fails (fail-safe)', async () => {
    (authService.logoutFromServer as vi.Mock).mockRejectedValue(new Error('API Error'));

    await useAuthStore.getState().logout();

    expect(localStorage.getItem('refreshToken')).toBeNull();
  });

  it('handles missing refresh token gracefully', async () => {
    localStorage.removeItem('refreshToken');

    await expect(useAuthStore.getState().logout()).resolves.not.toThrow();

    const state = useAuthStore.getState();
    expect(state.isAuthenticated).toBe(false);
  });
});
```

### Тесты для Header.tsx - Logout Button

```typescript
// frontend/src/__tests__/components/layout/Header.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { useAuthStore } from '@/stores/authStore';
import Header from '@/components/layout/Header';

// Mock next/navigation
const mockPush = vi.fn();
vi.mock('next/navigation', () => ({
  usePathname: () => '/',
  useRouter: () => ({ push: mockPush }),
}));

describe('Header - Logout Button', () => {
  describe('Desktop Version', () => {
    beforeEach(() => {
      vi.clearAllMocks();
      // Setup authenticated user
      useAuthStore.setState({
        isAuthenticated: true,
        user: { first_name: 'Иван', role: 'retail' },
        accessToken: 'test-access-token',
      });
      localStorage.setItem('refreshToken', 'test-refresh-token');
    });

    afterEach(() => {
      localStorage.clear();
    });

    it('shows logout button for authenticated users', () => {
      render(<Header />);
      
      expect(screen.getByRole('button', { name: /выйти/i })).toBeInTheDocument();
    });

    it('hides logout button for unauthenticated users', () => {
      useAuthStore.setState({
        isAuthenticated: false,
        user: null,
        accessToken: null,
      });

      render(<Header />);
      
      expect(screen.queryByRole('button', { name: /выйти/i })).not.toBeInTheDocument();
    });

    it('calls authStore.logout() on click', async () => {
      const user = userEvent.setup();
      const logoutSpy = vi.spyOn(useAuthStore.getState(), 'logout');
      
      render(<Header />);
      
      const logoutButton = screen.getByRole('button', { name: /выйти/i });
      await user.click(logoutButton);
      
      expect(logoutSpy).toHaveBeenCalled();
    });

    it('redirects to home page after logout', async () => {
      const user = userEvent.setup();
      
      render(<Header />);
      
      const logoutButton = screen.getByRole('button', { name: /выйти/i });
      await user.click(logoutButton);
      
      await waitFor(() => {
        expect(mockPush).toHaveBeenCalledWith('/');
      });
    });

    it('clears isAuthenticated after logout', async () => {
      const user = userEvent.setup();
      
      render(<Header />);
      
      expect(useAuthStore.getState().isAuthenticated).toBe(true);
      
      const logoutButton = screen.getByRole('button', { name: /выйти/i });
      await user.click(logoutButton);
      
      await waitFor(() => {
        expect(useAuthStore.getState().isAuthenticated).toBe(false);
      });
    });

    it('shows login/register buttons after logout', async () => {
      const user = userEvent.setup();
      
      render(<Header />);
      
      const logoutButton = screen.getByRole('button', { name: /выйти/i });
      await user.click(logoutButton);
      
      await waitFor(() => {
        expect(screen.getByRole('button', { name: /войти/i })).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /регистрация/i })).toBeInTheDocument();
      });
    });
  });

  describe('Mobile Version', () => {
    beforeEach(() => {
      vi.clearAllMocks();
      // Setup authenticated user
      useAuthStore.setState({
        isAuthenticated: true,
        user: { first_name: 'Иван', role: 'retail' },
        accessToken: 'test-access-token',
      });
      localStorage.setItem('refreshToken', 'test-refresh-token');
      
      // Set mobile viewport
      // ⚠️ Примечание: изменение innerWidth в jsdom не триггерит CSS media queries.
      // Для полноценного тестирования responsive используйте Playwright.
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 375,
      });
    });

    afterEach(() => {
      localStorage.clear();
    });

    it('shows logout button in mobile menu for authenticated users', async () => {
      const user = userEvent.setup();
      
      render(<Header />);
      
      // Open mobile menu
      const menuButton = screen.getByRole('button', { name: /меню/i });
      await user.click(menuButton);
      
      expect(screen.getByRole('button', { name: /выйти/i })).toBeInTheDocument();
    });

    it('calls logout and closes mobile menu on click', async () => {
      const user = userEvent.setup();
      const logoutSpy = vi.spyOn(useAuthStore.getState(), 'logout');
      
      render(<Header />);
      
      // Open mobile menu
      const menuButton = screen.getByRole('button', { name: /меню/i });
      await user.click(menuButton);
      
      const logoutButton = screen.getByRole('button', { name: /выйти/i });
      await user.click(logoutButton);
      
      expect(logoutSpy).toHaveBeenCalled();
    });
  });
});

describe('Header - Logout Token Cleanup', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    useAuthStore.setState({
      isAuthenticated: true,
      user: { first_name: 'Иван', role: 'retail' },
      accessToken: 'test-access-token',
    });
    localStorage.setItem('refreshToken', 'test-refresh-token');
  });

  afterEach(() => {
    localStorage.clear();
  });

  it('clears refreshToken from localStorage', async () => {
    const user = userEvent.setup();
    
    render(<Header />);
    
    expect(localStorage.getItem('refreshToken')).toBe('test-refresh-token');
    
    const logoutButton = screen.getByRole('button', { name: /выйти/i });
    await user.click(logoutButton);
    
    await waitFor(() => {
      expect(localStorage.getItem('refreshToken')).toBeNull();
    });
  });

  it('clears accessToken from store', async () => {
    const user = userEvent.setup();
    
    render(<Header />);
    
    expect(useAuthStore.getState().accessToken).toBe('test-access-token');
    
    const logoutButton = screen.getByRole('button', { name: /выйти/i });
    await user.click(logoutButton);
    
    await waitFor(() => {
      expect(useAuthStore.getState().accessToken).toBeNull();
    });
  });

  it('clears user from store', async () => {
    const user = userEvent.setup();
    
    render(<Header />);
    
    expect(useAuthStore.getState().user).not.toBeNull();
    
    const logoutButton = screen.getByRole('button', { name: /выйти/i });
    await user.click(logoutButton);
    
    await waitFor(() => {
      expect(useAuthStore.getState().user).toBeNull();
    });
  });

  it('clears refreshToken cookie', async () => {
    const user = userEvent.setup();
    // Установить cookie перед тестом
    document.cookie = 'refreshToken=test-cookie-token; path=/';
    
    render(<Header />);
    
    const logoutButton = screen.getByRole('button', { name: /выйти/i });
    await user.click(logoutButton);
    
    await waitFor(() => {
      // Cookie должен быть удалён (пустой или expired)
      expect(document.cookie).not.toContain('refreshToken=test-cookie-token');
    });
  });
});
```

### Важные замечания

1. **MSW Setup:** Тесты используют MSW для мока backend API
2. **Fail-safe тестирование:** Обязательно проверить, что локальная очистка происходит даже при ошибках API
3. **Coverage:** Запустить `npm run test:coverage` и проверить >= 90%
4. **Vitest vs Jest:** Проект использует Vitest, использовать `vi.fn()` вместо `jest.fn()`
5. **React Testing Library:** Использовать `userEvent` для симуляции кликов
6. **Mobile viewport ограничения:** jsdom не поддерживает CSS media queries — изменение `window.innerWidth` не влияет на рендеринг. Для полноценного responsive тестирования используйте Playwright.
7. **Cookie тестирование:** Добавлен тест для проверки удаления `refreshToken` cookie при logout

---

## Testing

### Test Commands

```bash
# Запуск всех тестов
npm run test

# Запуск тестов с coverage
npm run test:coverage

# Запуск только logout тестов
npm run test -- --grep "logout"

# Watch mode
npm run test:watch
```

### Coverage Requirements

| File | Statements | Branches | Functions | Lines |
|------|------------|----------|-----------|-------|
| authService.ts (logoutFromServer) | >= 90% | >= 90% | 100% | >= 90% |
| authStore.ts (logout) | >= 90% | >= 90% | 100% | >= 90% |
| Header.tsx (logout button) | >= 90% | >= 90% | >= 90% | >= 90% |

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-13 | 1.0 | Initial story draft | Sarah (PO) |
| 2025-12-13 | 1.1 | Added cookie cleanup test, mobile viewport notes, renamed Task 5 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_

# Backend API Design для Story 11.3
**Форма подписки на рассылку и блок новостей**

**Дата создания:** 2025-11-18
**Последнее обновление:** 2025-11-18 (Backend реализован James)
**Автор:** Winston (Architect Agent)
**Обновлено:** James (Dev Agent)
**Статус:**

Done

---

## Executive Summary

**Цель:** Спроектировать backend API endpoints для Story 11.3:
- `POST /api/v1/subscribe` - подписка на email-рассылку
- `POST /api/v1/unsubscribe` - отписка от рассылки (GDPR compliance)
- `GET /api/v1/news` - получение списка новостей

**Решение:** Добавить 2 модели в `apps/common/`:
- `Newsletter` - хранение email-подписок
- `News` - система новостей и акций

**Обоснование размещения в apps/common:**
- ✅ Общие компоненты платформы (не привязаны к домену)
- ✅ Используются всеми типами пользователей
- ✅ Соответствуют существующим паттернам (AuditLog, SyncLog)

---

## 1. Модели данных (Models)

### 1.1. Newsletter Model

**Назначение:** Хранение email-адресов подписчиков на рассылку

```python
# backend/apps/common/models.py

from __future__ import annotations

from django.db import models
from django.utils import timezone


class Newsletter(models.Model):
    """
    Модель подписки на email-рассылку.
    Хранит email адреса подписчиков с временными метками.
    """

    email: models.EmailField = models.EmailField(
        "Email адрес",
        unique=True,
        max_length=255,
        db_index=True,
        help_text="Уникальный email адрес подписчика",
    )
    is_active: models.BooleanField = models.BooleanField(
        "Активна",
        default=True,
        db_index=True,
        help_text="Флаг активности подписки (для отписки)",
    )
    subscribed_at: models.DateTimeField = models.DateTimeField(
        "Дата подписки",
        auto_now_add=True,
        db_index=True,
        help_text="Дата и время подписки",
    )
    unsubscribed_at: models.DateTimeField = models.DateTimeField(
        "Дата отписки",
        null=True,
        blank=True,
        help_text="Дата и время отписки (null если активна)",
    )
    ip_address: models.GenericIPAddressField = models.GenericIPAddressField(
        "IP адрес",
        null=True,
        blank=True,
        help_text="IP адрес при подписке (для антиспам)",
    )
    user_agent: models.TextField = models.TextField(
        "User Agent",
        blank=True,
        help_text="Браузер и устройство при подписке",
    )

    objects = models.Manager()

    class Meta:
        verbose_name = "Подписка на рассылку"
        verbose_name_plural = "Подписки на рассылку"
        db_table = "newsletter_subscriptions"
        ordering = ["-subscribed_at"]
        indexes = [
            models.Index(fields=["email"]),
            models.Index(fields=["is_active", "subscribed_at"]),
            models.Index(fields=["subscribed_at"]),
        ]
        constraints = [
            models.CheckConstraint(
                check=models.Q(is_active=True, unsubscribed_at__isnull=True)
                | models.Q(is_active=False, unsubscribed_at__isnull=False),
                name="newsletter_active_consistency",
            )
        ]

    def __str__(self) -> str:
        status = "Активна" if self.is_active else "Неактивна"
        return f"{self.email} ({status})"

    def unsubscribe(self) -> None:
        """Отписать email от рассылки."""
        self.is_active = False
        self.unsubscribed_at = timezone.now()
        self.save(update_fields=["is_active", "unsubscribed_at"])
```

**Ключевые решения:**
- ✅ `email` - уникальное поле с индексом для быстрого поиска дубликатов
- ✅ `is_active` - soft delete паттерн (не удаляем, а деактивируем)
- ✅ `ip_address` + `user_agent` - для антиспам защиты и аналитики
- ✅ Индексы на часто запрашиваемых полях
- ✅ Database constraint - гарантирует consistency между `is_active` и `unsubscribed_at`
- ✅ Метод `unsubscribe()` для будущей функции отписки

---

### 1.2. News Model

**Назначение:** Хранение новостей и акций для отображения на главной странице

```python
# backend/apps/common/models.py

from django.db import models
from django.utils.text import slugify


class News(models.Model):
    """
    Модель новостей и акций.
    Отображаются на главной странице и в блоге компании.
    """

    title: models.CharField = models.CharField(
        "Заголовок",
        max_length=200,
        help_text="Заголовок новости",
    )
    slug: models.SlugField = models.SlugField(
        "URL slug",
        max_length=255,
        unique=True,
        db_index=True,
        help_text="Уникальный идентификатор для URL",
    )
    excerpt: models.TextField = models.TextField(
        "Краткое описание",
        max_length=500,
        help_text="Краткое описание для главной страницы (до 500 символов)",
    )
    content: models.TextField = models.TextField(
        "Полный текст",
        blank=True,
        help_text="Полный текст новости (опционально)",
    )
    image: models.ImageField = models.ImageField(
        "Изображение",
        upload_to="news/%Y/%m/",
        null=True,
        blank=True,
        help_text="Изображение новости (опционально)",
    )
    author: models.CharField = models.CharField(
        "Автор",
        max_length=100,
        blank=True,
        help_text="Имя автора (опционально)",
    )
    category: models.CharField = models.CharField(
        "Категория",
        max_length=50,
        blank=True,
        db_index=True,
        help_text="Категория новости (акция, новинка, событие)",
    )
    is_published: models.BooleanField = models.BooleanField(
        "Опубликована",
        default=False,
        db_index=True,
        help_text="Флаг публикации (только опубликованные видны на сайте)",
    )
    published_at: models.DateTimeField = models.DateTimeField(
        "Дата публикации",
        db_index=True,
        help_text="Дата и время публикации",
    )
    created_at: models.DateTimeField = models.DateTimeField(
        "Дата создания",
        auto_now_add=True,
    )
    updated_at: models.DateTimeField = models.DateTimeField(
        "Дата обновления",
        auto_now=True,
    )

    objects = models.Manager()

    class Meta:
        verbose_name = "Новость"
        verbose_name_plural = "Новости"
        db_table = "news"
        ordering = ["-published_at"]
        indexes = [
            models.Index(fields=["is_published", "published_at"]),
            models.Index(fields=["slug"]),
            models.Index(fields=["category", "published_at"]),
            models.Index(fields=["published_at"]),
        ]

    def __str__(self) -> str:
        return self.title

    def save(self, *args, **kwargs) -> None:
        """Автоматическая генерация slug из заголовка."""
        if not self.slug:
            self.slug = slugify(self.title, allow_unicode=True)
        super().save(*args, **kwargs)
```

**Ключевые решения:**
- ✅ `slug` - автоматическая генерация из заголовка (для SEO-friendly URLs)
- ✅ `excerpt` - отдельное поле для краткого описания (не обрезка content)
- ✅ `is_published` + `published_at` - draft/publish паттерн
- ✅ `image` - ImageField с организацией по датам (news/2025/11/)
- ✅ `category` - для будущей фильтрации новостей
- ✅ Composite индекс `(is_published, published_at)` для оптимизации запросов

---

## 2. Сериализаторы (Serializers)

### 2.1. SubscribeSerializer

**Назначение:** Валидация email при подписке на рассылку

```python
# backend/apps/common/serializers.py

from __future__ import annotations

from rest_framework import serializers
from .models import Newsletter


class SubscribeSerializer(serializers.Serializer):
    """
    Сериализатор для подписки на email-рассылку.
    Валидирует email и создает запись в Newsletter.
    """

    email = serializers.EmailField(
        required=True,
        max_length=255,
        help_text="Email адрес для подписки",
    )

    def validate_email(self, value: str) -> str:
        """
        Валидация email адреса.
        Проверяет существование подписки.
        """
        # Нормализация email (lowercase)
        value = value.lower().strip()

        # Проверка на существующую активную подписку
        if Newsletter.objects.filter(email=value, is_active=True).exists():
            raise serializers.ValidationError(
                "Этот email уже подписан на рассылку"
            )

        return value

    def create(self, validated_data: dict) -> Newsletter:
        """
        Создание подписки.
        Если email ранее отписался - реактивируем подписку.
        """
        email = validated_data["email"]

        # Получаем IP и User-Agent из контекста (request)
        request = self.context.get("request")
        ip_address = None
        user_agent = ""

        if request:
            # Получаем IP с учетом proxy (X-Forwarded-For)
            x_forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
            if x_forwarded_for:
                ip_address = x_forwarded_for.split(",")[0]
            else:
                ip_address = request.META.get("REMOTE_ADDR")

            user_agent = request.META.get("HTTP_USER_AGENT", "")

        # Проверяем существование неактивной подписки
        try:
            subscription = Newsletter.objects.get(email=email, is_active=False)
            # Реактивируем подписку
            subscription.is_active = True
            subscription.unsubscribed_at = None
            subscription.ip_address = ip_address
            subscription.user_agent = user_agent
            subscription.save(
                update_fields=[
                    "is_active",
                    "unsubscribed_at",
                    "ip_address",
                    "user_agent",
                ]
            )
            return subscription
        except Newsletter.DoesNotExist:
            # Создаем новую подписку
            return Newsletter.objects.create(
                email=email,
                ip_address=ip_address,
                user_agent=user_agent,
            )


class SubscribeResponseSerializer(serializers.Serializer):
    """Сериализатор ответа при успешной подписке."""

    message = serializers.CharField()
    email = serializers.EmailField()


class UnsubscribeSerializer(serializers.Serializer):
    """
    Сериализатор для отписки от email-рассылки.
    Валидирует email и деактивирует подписку.
    """

    email = serializers.EmailField(
        required=True,
        max_length=255,
        help_text="Email адрес для отписки",
    )

    def validate_email(self, value: str) -> str:
        """
        Валидация email адреса.
        Проверяет существование активной подписки.
        """
        # Нормализация email (lowercase)
        value = value.lower().strip()

        # Проверка на существование активной подписки
        if not Newsletter.objects.filter(email=value, is_active=True).exists():
            raise serializers.ValidationError(
                "Этот email не найден в списке подписчиков или уже отписан"
            )

        return value

    def save(self) -> Newsletter:
        """
        Отписка от рассылки.
        Вызывает метод unsubscribe() модели.
        """
        email = self.validated_data["email"]
        subscription = Newsletter.objects.get(email=email, is_active=True)
        subscription.unsubscribe()
        return subscription


class UnsubscribeResponseSerializer(serializers.Serializer):
    """Сериализатор ответа при успешной отписке."""

    message = serializers.CharField()
    email = serializers.EmailField()
```

**Ключевые решения:**
- ✅ **SubscribeSerializer:** Email normalization, проверка дубликатов, реактивация неактивных подписок
- ✅ **UnsubscribeSerializer:** Валидация существования активной подписки, использование метода `unsubscribe()`
- ✅ Захват IP и User-Agent из request context (subscribe)
- ✅ X-Forwarded-For support (для работы за reverse proxy)
- ✅ Отдельные Response serializers для typed API responses

---

### 2.2. NewsSerializer

**Назначение:** Сериализация новостей для API

```python
# backend/apps/common/serializers.py

from rest_framework import serializers
from .models import News


class NewsSerializer(serializers.ModelSerializer):
    """
    Сериализатор новости для публичного API.
    Возвращает только опубликованные поля.
    """

    class Meta:
        model = News
        fields = [
            "id",
            "title",
            "slug",
            "excerpt",
            "content",
            "image",
            "published_at",
            "created_at",
            "updated_at",
            "author",
            "category",
        ]
        read_only_fields = [
            "id",
            "slug",
            "created_at",
            "updated_at",
        ]

    def to_representation(self, instance):
        """
        Кастомизация вывода.
        Преобразуем image в полный URL.
        """
        data = super().to_representation(instance)

        # Преобразуем image в полный URL
        request = self.context.get("request")
        if instance.image and request:
            data["image"] = request.build_absolute_uri(instance.image.url)
        elif not instance.image:
            data["image"] = None

        return data
```

**Ключевые решения:**
- ✅ ModelSerializer для автоматической валидации
- ✅ `to_representation()` для преобразования image в полный URL
- ✅ Все поля read_only кроме тех, что нужны для создания
- ✅ `content` включен (опционально) для детальной страницы новости

---

## 3. Представления (Views)

### 3.1. SubscribeView

**Назначение:** Обработка POST запросов на подписку

```python
# backend/apps/common/views.py

from __future__ import annotations

from drf_spectacular.utils import (
    OpenApiExample,
    OpenApiResponse,
    extend_schema,
)
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.request import Request
from rest_framework.response import Response

from .serializers import SubscribeSerializer, SubscribeResponseSerializer


@extend_schema(
    summary="Подписка на email-рассылку",
    description=(
        "Подписывает пользователя на email-рассылку о новинках и акциях. "
        "Если email уже подписан - возвращает 409 Conflict."
    ),
    request=SubscribeSerializer,
    responses={
        201: OpenApiResponse(
            description="Подписка успешно создана",
            examples=[
                OpenApiExample(
                    name="success_response",
                    value={
                        "message": "Вы успешно подписались на рассылку",
                        "email": "user@example.com",
                    },
                    response_only=True,
                )
            ],
        ),
        400: OpenApiResponse(
            description="Ошибка валидации email",
            examples=[
                OpenApiExample(
                    name="validation_error",
                    value={
                        "email": ["Введите корректный email адрес."],
                    },
                    response_only=True,
                )
            ],
        ),
        409: OpenApiResponse(
            description="Email уже подписан на рассылку",
            examples=[
                OpenApiExample(
                    name="already_subscribed",
                    value={
                        "email": ["Этот email уже подписан на рассылку"],
                    },
                    response_only=True,
                )
            ],
        ),
    },
    tags=["Newsletter"],
)
@api_view(["POST"])
@permission_classes([AllowAny])
def subscribe(request: Request) -> Response:
    """
    Подписка на email-рассылку.

    Принимает email адрес и создает подписку.
    Если email ранее отписался - реактивирует подписку.
    """
    serializer = SubscribeSerializer(data=request.data, context={"request": request})

    if serializer.is_valid():
        subscription = serializer.save()

        response_serializer = SubscribeResponseSerializer(
            {
                "message": "Вы успешно подписались на рассылку",
                "email": subscription.email,
            }
        )

        return Response(
            response_serializer.data,
            status=status.HTTP_201_CREATED,
        )

    # Обработка ошибки "уже подписан"
    if "email" in serializer.errors:
        error_msg = str(serializer.errors["email"][0])
        if "уже подписан" in error_msg:
            return Response(
                serializer.errors,
                status=status.HTTP_409_CONFLICT,
            )

    # Другие ошибки валидации
    return Response(
        serializer.errors,
        status=status.HTTP_400_BAD_REQUEST,
    )
```

**Ключевые решения:**
- ✅ `AllowAny` permission - доступно всем (включая неавторизованных)
- ✅ OpenAPI документация через `@extend_schema`
- ✅ Детальная обработка ошибок (400 vs 409)
- ✅ Передача request в serializer context (для IP/User-Agent)
- ✅ HTTP 201 Created при успешной подписке
- ✅ HTTP 409 Conflict при дубликате (семантически корректно)

---

### 3.2. UnsubscribeView

**Назначение:** Обработка POST запросов на отписку от рассылки

```python
# backend/apps/common/views.py

from __future__ import annotations

from drf_spectacular.utils import (
    OpenApiExample,
    OpenApiResponse,
    extend_schema,
)
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.request import Request
from rest_framework.response import Response

from .serializers import UnsubscribeSerializer, UnsubscribeResponseSerializer


@extend_schema(
    summary="Отписка от email-рассылки",
    description=(
        "Отписывает пользователя от email-рассылки. "
        "Если email не найден или уже отписан - возвращает 404 Not Found."
    ),
    request=UnsubscribeSerializer,
    responses={
        200: OpenApiResponse(
            description="Отписка успешно выполнена",
            examples=[
                OpenApiExample(
                    name="success_response",
                    value={
                        "message": "Вы успешно отписались от рассылки",
                        "email": "user@example.com",
                    },
                    response_only=True,
                )
            ],
        ),
        400: OpenApiResponse(
            description="Ошибка валидации email",
            examples=[
                OpenApiExample(
                    name="validation_error",
                    value={
                        "email": ["Введите корректный email адрес."],
                    },
                    response_only=True,
                )
            ],
        ),
        404: OpenApiResponse(
            description="Email не найден или уже отписан",
            examples=[
                OpenApiExample(
                    name="not_found",
                    value={
                        "email": [
                            "Этот email не найден в списке подписчиков или уже отписан"
                        ],
                    },
                    response_only=True,
                )
            ],
        ),
    },
    tags=["Newsletter"],
)
@api_view(["POST"])
@permission_classes([AllowAny])
def unsubscribe(request: Request) -> Response:
    """
    Отписка от email-рассылки.

    Принимает email адрес и деактивирует подписку.
    """
    serializer = UnsubscribeSerializer(data=request.data)

    if serializer.is_valid():
        subscription = serializer.save()

        response_serializer = UnsubscribeResponseSerializer(
            {
                "message": "Вы успешно отписались от рассылки",
                "email": subscription.email,
            }
        )

        return Response(
            response_serializer.data,
            status=status.HTTP_200_OK,
        )

    # Обработка ошибки "не найден или уже отписан"
    if "email" in serializer.errors:
        error_msg = str(serializer.errors["email"][0])
        if "не найден" in error_msg or "уже отписан" in error_msg:
            return Response(
                serializer.errors,
                status=status.HTTP_404_NOT_FOUND,
            )

    # Другие ошибки валидации
    return Response(
        serializer.errors,
        status=status.HTTP_400_BAD_REQUEST,
    )
```

**Ключевые решения:**
- ✅ `AllowAny` permission - доступно всем (пользователь может отписаться без авторизации)
- ✅ OpenAPI документация через `@extend_schema`
- ✅ HTTP 200 OK при успешной отписке (не 204, т.к. возвращаем данные)
- ✅ HTTP 404 Not Found если email не найден или уже отписан (семантически корректно)
- ✅ GDPR compliance - возможность отписки без авторизации

---

### 3.3. NewsListView

**Назначение:** Получение списка новостей с pagination

```python
# backend/apps/common/views.py

from django.utils import timezone
from drf_spectacular.utils import (
    OpenApiExample,
    OpenApiParameter,
    OpenApiResponse,
    extend_schema,
)
from rest_framework import generics, status
from rest_framework.permissions import AllowAny

from .models import News
from .serializers import NewsSerializer


@extend_schema(
    summary="Получить список новостей",
    description=(
        "Возвращает список опубликованных новостей с пагинацией. "
        "Новости отсортированы по дате публикации (новые первые)."
    ),
    parameters=[
        OpenApiParameter(
            name="page_size",
            type=int,
            location=OpenApiParameter.QUERY,
            description="Количество новостей на странице (по умолчанию: 10, макс: 100)",
            required=False,
        ),
        OpenApiParameter(
            name="page",
            type=int,
            location=OpenApiParameter.QUERY,
            description="Номер страницы (по умолчанию: 1)",
            required=False,
        ),
    ],
    responses={
        200: OpenApiResponse(
            description="Список новостей успешно получен",
            examples=[
                OpenApiExample(
                    name="success_response",
                    value={
                        "count": 15,
                        "next": "http://api.example.com/api/v1/news?page=2",
                        "previous": None,
                        "results": [
                            {
                                "id": 1,
                                "title": "Новая коллекция 2025",
                                "slug": "new-collection-2025",
                                "excerpt": "Представляем новую коллекцию спортивной одежды...",
                                "content": "Полный текст новости...",
                                "image": "http://api.example.com/media/news/2025/11/collection.jpg",
                                "published_at": "2025-11-18T10:00:00Z",
                                "created_at": "2025-11-17T15:30:00Z",
                                "updated_at": "2025-11-18T09:00:00Z",
                                "author": "FREESPORT Team",
                                "category": "новинки",
                            },
                            {
                                "id": 2,
                                "title": "Скидки на зимнюю экипировку",
                                "slug": "winter-sale",
                                "excerpt": "До конца месяца скидки до 30%...",
                                "content": "",
                                "image": None,
                                "published_at": "2025-11-17T12:00:00Z",
                                "created_at": "2025-11-16T10:00:00Z",
                                "updated_at": "2025-11-17T11:30:00Z",
                                "author": "",
                                "category": "акции",
                            },
                        ],
                    },
                    response_only=True,
                )
            ],
        ),
    },
    tags=["News"],
)
class NewsListView(generics.ListAPIView):
    """
    API endpoint для получения списка новостей.

    Возвращает только опубликованные новости (is_published=True)
    с датой публикации <= текущего момента.
    """

    serializer_class = NewsSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        """
        Возвращает только опубликованные новости.
        Фильтрует по дате публикации (только прошедшие/текущие).
        """
        return News.objects.filter(
            is_published=True,
            published_at__lte=timezone.now(),
        ).order_by("-published_at")
```

**Ключевые решения:**
- ✅ `ListAPIView` - встроенная пагинация из DRF
- ✅ `AllowAny` permission - публичный доступ
- ✅ Фильтрация только опубликованных новостей (`is_published=True`)
- ✅ Фильтрация по дате публикации (не показываем будущие новости)
- ✅ Сортировка по `-published_at` (новые первые)
- ✅ OpenAPI документация с examples

---

## 4. URL Конфигурация

### 4.1. Регистрация endpoints

```python
# backend/apps/common/urls.py

from django.urls import path

from . import views

app_name = "common"

urlpatterns = [
    # Existing endpoints
    path("health/", views.health_check, name="health-check"),
    path(
        "monitoring/metrics/operations/",
        views.operation_metrics,
        name="operation-metrics",
    ),
    path(
        "monitoring/metrics/business/",
        views.business_metrics,
        name="business-metrics",
    ),
    path(
        "monitoring/metrics/realtime/",
        views.realtime_metrics,
        name="realtime-metrics",
    ),
    path("monitoring/health/", views.system_health, name="system-health"),

    # NEW: Newsletter & News endpoints
    path("subscribe/", views.subscribe, name="subscribe"),
    path("unsubscribe/", views.unsubscribe, name="unsubscribe"),
    path("news/", views.NewsListView.as_view(), name="news-list"),
]
```

**Ключевые решения:**
- ✅ RESTful naming: `/subscribe/` (POST), `/unsubscribe/` (POST), `/news/` (GET)
- ✅ Naming convention соответствует существующим endpoints
- ✅ URL names для reverse() в тестах
- ✅ Симметричные endpoints для подписки/отписки

---

## 5. Миграции Django

### 5.1. Команда создания миграций

```bash
# Создание миграций для новых моделей
cd backend
python manage.py makemigrations common --name add_newsletter_and_news_models

# Применение миграций
python manage.py migrate common
```

### 5.2. Ожидаемое содержимое миграции

```python
# backend/apps/common/migrations/0XXX_add_newsletter_and_news_models.py

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('common', '0XXX_previous_migration'),
    ]

    operations = [
        migrations.CreateModel(
            name='Newsletter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('email', models.EmailField(db_index=True, help_text='Уникальный email адрес подписчика', max_length=255, unique=True, verbose_name='Email адрес')),
                ('is_active', models.BooleanField(db_index=True, default=True, help_text='Флаг активности подписки (для отписки)', verbose_name='Активна')),
                ('subscribed_at', models.DateTimeField(auto_now_add=True, db_index=True, help_text='Дата и время подписки', verbose_name='Дата подписки')),
                ('unsubscribed_at', models.DateTimeField(blank=True, help_text='Дата и время отписки (null если активна)', null=True, verbose_name='Дата отписки')),
                ('ip_address', models.GenericIPAddressField(blank=True, help_text='IP адрес при подписке (для антиспам)', null=True, verbose_name='IP адрес')),
                ('user_agent', models.TextField(blank=True, help_text='Браузер и устройство при подписке', verbose_name='User Agent')),
            ],
            options={
                'verbose_name': 'Подписка на рассылку',
                'verbose_name_plural': 'Подписки на рассылку',
                'db_table': 'newsletter_subscriptions',
                'ordering': ['-subscribed_at'],
            },
        ),
        migrations.CreateModel(
            name='News',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(help_text='Заголовок новости', max_length=200, verbose_name='Заголовок')),
                ('slug', models.SlugField(db_index=True, help_text='Уникальный идентификатор для URL', max_length=255, unique=True, verbose_name='URL slug')),
                ('excerpt', models.TextField(help_text='Краткое описание для главной страницы (до 500 символов)', max_length=500, verbose_name='Краткое описание')),
                ('content', models.TextField(blank=True, help_text='Полный текст новости (опционально)', verbose_name='Полный текст')),
                ('image', models.ImageField(blank=True, help_text='Изображение новости (опционально)', null=True, upload_to='news/%Y/%m/', verbose_name='Изображение')),
                ('author', models.CharField(blank=True, help_text='Имя автора (опционально)', max_length=100, verbose_name='Автор')),
                ('category', models.CharField(blank=True, db_index=True, help_text='Категория новости (акция, новинка, событие)', max_length=50, verbose_name='Категория')),
                ('is_published', models.BooleanField(db_index=True, default=False, help_text='Флаг публикации (только опубликованные видны на сайте)', verbose_name='Опубликована')),
                ('published_at', models.DateTimeField(db_index=True, help_text='Дата и время публикации', verbose_name='Дата публикации')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
            ],
            options={
                'verbose_name': 'Новость',
                'verbose_name_plural': 'Новости',
                'db_table': 'news',
                'ordering': ['-published_at'],
            },
        ),
        migrations.AddIndex(
            model_name='newsletter',
            index=models.Index(fields=['email'], name='newsletter_subscriptions_email_idx'),
        ),
        migrations.AddIndex(
            model_name='newsletter',
            index=models.Index(fields=['is_active', 'subscribed_at'], name='newsletter_subscriptions_is_active_subscribed_at_idx'),
        ),
        migrations.AddIndex(
            model_name='newsletter',
            index=models.Index(fields=['subscribed_at'], name='newsletter_subscriptions_subscribed_at_idx'),
        ),
        migrations.AddIndex(
            model_name='news',
            index=models.Index(fields=['is_published', 'published_at'], name='news_is_published_published_at_idx'),
        ),
        migrations.AddIndex(
            model_name='news',
            index=models.Index(fields=['slug'], name='news_slug_idx'),
        ),
        migrations.AddIndex(
            model_name='news',
            index=models.Index(fields=['category', 'published_at'], name='news_category_published_at_idx'),
        ),
        migrations.AddIndex(
            model_name='news',
            index=models.Index(fields=['published_at'], name='news_published_at_idx'),
        ),
    ]
```

---

## 6. Backend Tests

### 6.1. Newsletter Tests

```python
# backend/apps/common/tests/test_subscribe.py

from __future__ import annotations

import pytest
from django.urls import reverse
from rest_framework import status

from apps.common.models import Newsletter


@pytest.mark.django_db
class TestSubscribeEndpoint:
    """Тесты для POST /api/v1/subscribe endpoint."""

    def test_subscribe_success(self, api_client):
        """Тест успешной подписки на рассылку."""
        url = reverse("common:subscribe")
        data = {"email": "newuser@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["message"] == "Вы успешно подписались на рассылку"
        assert response.data["email"] == "newuser@example.com"

        # Проверяем создание записи в БД
        assert Newsletter.objects.filter(email="newuser@example.com").exists()
        subscription = Newsletter.objects.get(email="newuser@example.com")
        assert subscription.is_active is True

    def test_subscribe_duplicate_email(self, api_client):
        """Тест подписки с уже существующим email."""
        # Создаем существующую подписку
        Newsletter.objects.create(email="existing@example.com", is_active=True)

        url = reverse("common:subscribe")
        data = {"email": "existing@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_409_CONFLICT
        assert "уже подписан" in str(response.data["email"][0])

    def test_subscribe_reactivate_unsubscribed(self, api_client):
        """Тест реактивации ранее отписавшегося email."""
        # Создаем неактивную подписку
        Newsletter.objects.create(email="unsubscribed@example.com", is_active=False)

        url = reverse("common:subscribe")
        data = {"email": "unsubscribed@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED

        # Проверяем реактивацию
        subscription = Newsletter.objects.get(email="unsubscribed@example.com")
        assert subscription.is_active is True
        assert subscription.unsubscribed_at is None

    def test_subscribe_invalid_email(self, api_client):
        """Тест с невалидным email адресом."""
        url = reverse("common:subscribe")
        data = {"email": "invalid-email"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert "email" in response.data

    def test_subscribe_email_normalization(self, api_client):
        """Тест нормализации email (lowercase)."""
        url = reverse("common:subscribe")
        data = {"email": "TestUser@EXAMPLE.COM"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED

        # Проверяем сохранение в lowercase
        subscription = Newsletter.objects.get(email="testuser@example.com")
        assert subscription.email == "testuser@example.com"


@pytest.mark.django_db
class TestUnsubscribeEndpoint:
    """Тесты для POST /api/v1/unsubscribe endpoint."""

    def test_unsubscribe_success(self, api_client):
        """Тест успешной отписки от рассылки."""
        # Создаем активную подписку
        Newsletter.objects.create(email="subscriber@example.com", is_active=True)

        url = reverse("common:unsubscribe")
        data = {"email": "subscriber@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_200_OK
        assert response.data["message"] == "Вы успешно отписались от рассылки"
        assert response.data["email"] == "subscriber@example.com"

        # Проверяем деактивацию в БД
        subscription = Newsletter.objects.get(email="subscriber@example.com")
        assert subscription.is_active is False
        assert subscription.unsubscribed_at is not None

    def test_unsubscribe_not_found(self, api_client):
        """Тест отписки несуществующего email."""
        url = reverse("common:unsubscribe")
        data = {"email": "nonexistent@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_404_NOT_FOUND
        assert "не найден" in str(response.data["email"][0])

    def test_unsubscribe_already_unsubscribed(self, api_client):
        """Тест отписки уже отписанного email."""
        # Создаем неактивную подписку
        Newsletter.objects.create(email="unsubscribed@example.com", is_active=False)

        url = reverse("common:unsubscribe")
        data = {"email": "unsubscribed@example.com"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_404_NOT_FOUND
        assert "уже отписан" in str(response.data["email"][0])

    def test_unsubscribe_invalid_email(self, api_client):
        """Тест отписки с невалидным email."""
        url = reverse("common:unsubscribe")
        data = {"email": "invalid-email"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert "email" in response.data

    def test_unsubscribe_email_normalization(self, api_client):
        """Тест нормализации email при отписке."""
        # Создаем подписку в lowercase
        Newsletter.objects.create(email="testuser@example.com", is_active=True)

        url = reverse("common:unsubscribe")
        data = {"email": "TestUser@EXAMPLE.COM"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_200_OK

        # Проверяем отписку
        subscription = Newsletter.objects.get(email="testuser@example.com")
        assert subscription.is_active is False
```

---

### 6.2. News Tests

```python
# backend/apps/common/tests/test_news.py

from __future__ import annotations

from datetime import timedelta

import pytest
from django.urls import reverse
from django.utils import timezone
from rest_framework import status

from apps.common.models import News


@pytest.mark.django_db
class TestNewsListEndpoint:
    """Тесты для GET /api/v1/news endpoint."""

    @pytest.fixture
    def published_news(self):
        """Создание опубликованных новостей для тестов."""
        now = timezone.now()
        return [
            News.objects.create(
                title="Новость 1",
                slug="news-1",
                excerpt="Описание новости 1",
                is_published=True,
                published_at=now - timedelta(days=1),
            ),
            News.objects.create(
                title="Новость 2",
                slug="news-2",
                excerpt="Описание новости 2",
                is_published=True,
                published_at=now - timedelta(days=2),
            ),
            News.objects.create(
                title="Новость 3",
                slug="news-3",
                excerpt="Описание новости 3",
                is_published=True,
                published_at=now - timedelta(days=3),
            ),
        ]

    def test_get_news_list_success(self, api_client, published_news):
        """Тест получения списка новостей."""
        url = reverse("common:news-list")

        response = api_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.data["count"] == 3
        assert len(response.data["results"]) == 3

        # Проверяем сортировку (новые первые)
        assert response.data["results"][0]["title"] == "Новость 1"
        assert response.data["results"][1]["title"] == "Новость 2"
        assert response.data["results"][2]["title"] == "Новость 3"

    def test_get_news_list_with_pagination(self, api_client, published_news):
        """Тест pagination для списка новостей."""
        url = reverse("common:news-list")

        response = api_client.get(url, {"page_size": 2})

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data["results"]) == 2
        assert response.data["next"] is not None

    def test_get_news_list_only_published(self, api_client):
        """Тест фильтрации только опубликованных новостей."""
        now = timezone.now()

        # Опубликованная новость
        News.objects.create(
            title="Опубликованная",
            slug="published",
            excerpt="Описание",
            is_published=True,
            published_at=now - timedelta(days=1),
        )

        # Неопубликованная новость (draft)
        News.objects.create(
            title="Черновик",
            slug="draft",
            excerpt="Описание",
            is_published=False,
            published_at=now - timedelta(days=1),
        )

        url = reverse("common:news-list")
        response = api_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.data["count"] == 1
        assert response.data["results"][0]["title"] == "Опубликованная"

    def test_get_news_list_exclude_future_news(self, api_client):
        """Тест исключения новостей с будущей датой публикации."""
        now = timezone.now()

        # Прошлая новость
        News.objects.create(
            title="Прошлая новость",
            slug="past-news",
            excerpt="Описание",
            is_published=True,
            published_at=now - timedelta(days=1),
        )

        # Будущая новость
        News.objects.create(
            title="Будущая новость",
            slug="future-news",
            excerpt="Описание",
            is_published=True,
            published_at=now + timedelta(days=1),
        )

        url = reverse("common:news-list")
        response = api_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.data["count"] == 1
        assert response.data["results"][0]["title"] == "Прошлая новость"
```

---

## 7. OpenAPI Specification

### 7.1. docs/api-spec.yaml Update

```yaml
# docs/api-spec.yaml

paths:
  /api/v1/subscribe:
    post:
      operationId: subscribe_create
      summary: Подписка на email-рассылку
      description: |
        Подписывает пользователя на email-рассылку о новинках и акциях.
        Если email уже подписан - возвращает 409 Conflict.
      tags:
        - Newsletter
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - email
              properties:
                email:
                  type: string
                  format: email
                  maxLength: 255
                  description: Email адрес для подписки
                  example: user@example.com
      responses:
        '201':
          description: Подписка успешно создана
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: Вы успешно подписались на рассылку
                  email:
                    type: string
                    format: email
                    example: user@example.com
        '400':
          description: Ошибка валидации email
          content:
            application/json:
              schema:
                type: object
                properties:
                  email:
                    type: array
                    items:
                      type: string
                    example: ["Введите корректный email адрес."]
        '409':
          description: Email уже подписан на рассылку
          content:
            application/json:
              schema:
                type: object
                properties:
                  email:
                    type: array
                    items:
                      type: string
                    example: ["Этот email уже подписан на рассылку"]

  /api/v1/unsubscribe:
    post:
      operationId: unsubscribe_create
      summary: Отписка от email-рассылки
      description: |
        Отписывает пользователя от email-рассылки.
        Если email не найден или уже отписан - возвращает 404 Not Found.
      tags:
        - Newsletter
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - email
              properties:
                email:
                  type: string
                  format: email
                  maxLength: 255
                  description: Email адрес для отписки
                  example: user@example.com
      responses:
        '200':
          description: Отписка успешно выполнена
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: Вы успешно отписались от рассылки
                  email:
                    type: string
                    format: email
                    example: user@example.com
        '400':
          description: Ошибка валидации email
          content:
            application/json:
              schema:
                type: object
                properties:
                  email:
                    type: array
                    items:
                      type: string
                    example: ["Введите корректный email адрес."]
        '404':
          description: Email не найден или уже отписан
          content:
            application/json:
              schema:
                type: object
                properties:
                  email:
                    type: array
                    items:
                      type: string
                    example: ["Этот email не найден в списке подписчиков или уже отписан"]

  /api/v1/news:
    get:
      operationId: news_list
      summary: Получить список новостей
      description: |
        Возвращает список опубликованных новостей с пагинацией.
        Новости отсортированы по дате публикации (новые первые).
      tags:
        - News
      parameters:
        - name: page_size
          in: query
          required: false
          schema:
            type: integer
            default: 10
            maximum: 100
          description: Количество новостей на странице
        - name: page
          in: query
          required: false
          schema:
            type: integer
            default: 1
          description: Номер страницы
      responses:
        '200':
          description: Список новостей успешно получен
          content:
            application/json:
              schema:
                type: object
                properties:
                  count:
                    type: integer
                    description: Общее количество новостей
                    example: 15
                  next:
                    type: string
                    nullable: true
                    format: uri
                    description: URL следующей страницы
                    example: "http://api.example.com/api/v1/news?page=2"
                  previous:
                    type: string
                    nullable: true
                    format: uri
                    description: URL предыдущей страницы
                    example: null
                  results:
                    type: array
                    items:
                      $ref: '#/components/schemas/NewsItem'

components:
  schemas:
    NewsItem:
      type: object
      properties:
        id:
          type: integer
          readOnly: true
          example: 1
        title:
          type: string
          maxLength: 200
          example: "Новая коллекция 2025"
        slug:
          type: string
          maxLength: 255
          readOnly: true
          example: "new-collection-2025"
        excerpt:
          type: string
          maxLength: 500
          description: Краткое описание для главной страницы
          example: "Представляем новую коллекцию спортивной одежды..."
        content:
          type: string
          nullable: true
          description: Полный текст новости (опционально)
          example: "Полный текст новости..."
        image:
          type: string
          format: uri
          nullable: true
          description: URL изображения новости
          example: "http://api.example.com/media/news/2025/11/collection.jpg"
        published_at:
          type: string
          format: date-time
          description: Дата и время публикации
          example: "2025-11-18T10:00:00Z"
        created_at:
          type: string
          format: date-time
          readOnly: true
          example: "2025-11-17T15:30:00Z"
        updated_at:
          type: string
          format: date-time
          readOnly: true
          example: "2025-11-18T09:00:00Z"
        author:
          type: string
          maxLength: 100
          nullable: true
          example: "FREESPORT Team"
        category:
          type: string
          maxLength: 50
          nullable: true
          example: "новинки"
```

---

## 8. Admin Panel Configuration

### 8.1. Django Admin для Newsletter

```python
# backend/apps/common/admin.py

from django.contrib import admin
from .models import Newsletter, News


@admin.register(Newsletter)
class NewsletterAdmin(admin.ModelAdmin):
    """Admin интерфейс для подписок на рассылку."""

    list_display = [
        "email",
        "is_active",
        "subscribed_at",
        "unsubscribed_at",
    ]
    list_filter = [
        "is_active",
        "subscribed_at",
    ]
    search_fields = [
        "email",
    ]
    readonly_fields = [
        "subscribed_at",
        "unsubscribed_at",
        "ip_address",
        "user_agent",
    ]
    date_hierarchy = "subscribed_at"

    def has_add_permission(self, request):
        """Только superuser может создавать подписки через admin."""
        return request.user.is_superuser
```

---

### 8.2. Django Admin для News

```python
# backend/apps/common/admin.py

@admin.register(News)
class NewsAdmin(admin.ModelAdmin):
    """Admin интерфейс для новостей."""

    list_display = [
        "title",
        "category",
        "is_published",
        "published_at",
        "created_at",
    ]
    list_filter = [
        "is_published",
        "category",
        "published_at",
    ]
    search_fields = [
        "title",
        "excerpt",
        "content",
    ]
    prepopulated_fields = {
        "slug": ("title",),
    }
    readonly_fields = [
        "created_at",
        "updated_at",
    ]
    date_hierarchy = "published_at"

    fieldsets = (
        ("Основная информация", {
            "fields": (
                "title",
                "slug",
                "category",
                "author",
            )
        }),
        ("Контент", {
            "fields": (
                "excerpt",
                "content",
                "image",
            )
        }),
        ("Публикация", {
            "fields": (
                "is_published",
                "published_at",
            )
        }),
        ("Метаданные", {
            "fields": (
                "created_at",
                "updated_at",
            ),
            "classes": ("collapse",),
        }),
    )
```

---

## 9. Implementation Checklist

**Dev Agent MUST complete этот чек-лист при реализации:**

### Phase 2: Backend Implementation

- [ ] **2.1: Создать модели Newsletter и News**
  - [ ] Добавить модели в `backend/apps/common/models.py`
  - [ ] Запустить `makemigrations` и `migrate`
  - [ ] Проверить создание таблиц в БД

- [ ] **2.2: Создать сериализаторы**
  - [ ] Создать `backend/apps/common/serializers.py` (если нет)
  - [ ] Добавить `SubscribeSerializer`, `SubscribeResponseSerializer`
  - [ ] Добавить `UnsubscribeSerializer`, `UnsubscribeResponseSerializer`
  - [ ] Добавить `NewsSerializer`
  - [ ] Протестировать валидацию email

- [ ] **2.3: Создать views**
  - [ ] Добавить `subscribe` view в `backend/apps/common/views.py`
  - [ ] Добавить `unsubscribe` view в `backend/apps/common/views.py`
  - [ ] Добавить `NewsListView` в `backend/apps/common/views.py`
  - [ ] Добавить OpenAPI документацию через `@extend_schema`

- [ ] **2.4: Обновить URLs**
  - [ ] Добавить роуты `/subscribe/`, `/unsubscribe/`, `/news/` в `backend/apps/common/urls.py`
  - [ ] Проверить URL names для reverse()

- [ ] **2.5: Создать admin configuration**
  - [ ] Добавить `NewsletterAdmin` в `backend/apps/common/admin.py`
  - [ ] Добавить `NewsAdmin` в `backend/apps/common/admin.py`
  - [ ] Протестировать admin panel

- [ ] **2.6: Написать backend tests**
  - [ ] Создать `backend/apps/common/tests/test_subscribe.py`
  - [ ] Добавить тесты для subscribe endpoint (5 сценариев)
  - [ ] Добавить тесты для unsubscribe endpoint (5 сценариев)
  - [ ] Создать `backend/apps/common/tests/test_news.py`
  - [ ] Запустить тесты: `pytest apps/common/tests/`
  - [ ] Убедиться в покрытии > 90%

- [ ] **2.7: Обновить api-spec.yaml**
  - [ ] Добавить `/api/v1/subscribe` endpoint
  - [ ] Добавить `/api/v1/unsubscribe` endpoint
  - [ ] Добавить `/api/v1/news` endpoint
  - [ ] Добавить `NewsItem` schema в components

- [ ] **2.8: Создать тестовые данные**
  - [ ] Создать фикстуру с новостями для development
  - [ ] Протестировать endpoints через Swagger UI

---

## 10. Архитектурные Решения и Обоснование

### 10.1. Почему apps/common?

✅ **Newsletter и News - общие компоненты:**
- Не привязаны к конкретному бизнес-домену (users, products, orders)
- Используются всеми пользователями независимо от роли
- Соответствуют паттерну существующих моделей (AuditLog, SyncLog)

### 10.2. Почему soft delete для Newsletter?

✅ **is_active вместо удаления:**
- Сохраняем историю подписок для аналитики
- Возможность реактивации (пользователь может передумать)
- Соответствие GDPR (можем анонимизировать, но не теряем статистику)

### 10.3. Почему отдельное поле excerpt для News?

✅ **excerpt отдельно от content:**
- Краткое описание пишется специально для главной страницы
- Не всегда первые 500 символов content - лучшее описание
- SEO оптимизация (мета-описание для карточек новостей)

### 10.4. Почему AllowAny permission?

✅ **Публичный доступ:**
- Форма подписки доступна на главной странице (неавторизованным)
- Новости - публичный контент (SEO, sharable links)
- Соответствует требованиям Story 11.3

### 10.5. Почему HTTP 409 для дубликатов?

✅ **Семантически корректный код:**
- 409 Conflict = "ресурс уже существует"
- 400 Bad Request = "некорректные данные"
- Позволяет frontend различать типы ошибок

### 10.6. Почему Unsubscribe API необходим?

✅ **GDPR compliance и legal requirements:**
- GDPR Article 7(3) - право отозвать согласие в любое время
- Email marketing best practice - каждое письмо должно иметь ссылку "Отписаться"
- Простая отписка улучшает репутацию домена (избегаем "spam" жалобы)

✅ **Архитектурное решение (простой вариант по email):**
- POST /api/v1/unsubscribe с email в body
- Симметрично с /api/v1/subscribe (понятный UX)
- Не требует токенов/ссылок (быстрая реализация для MVP)

⚠️ **Ограничения и Future Enhancement (Story 11.4):**
- **Текущий вариант:** Простой (по email) - подходит для MVP
- **Future Story 11.4:** Token-based unsubscribe (стандарт индустрии)
  - Генерация уникального токена при подписке
  - GET /api/v1/unsubscribe/{token}/ endpoint
  - Ссылка в email: `https://freesport.com/unsubscribe?token=xxx`
  - Защита от злоупотреблений (никто не может отписать чужой email)
  - One-click unsubscribe (RFC 8058)

---

## 11. Performance Considerations

### 11.1. Database Indexes

✅ **Оптимизированные запросы:**
- `Newsletter.email` - unique index (быстрая проверка дубликатов)
- `News(is_published, published_at)` - composite index (главная страница)
- `News.slug` - unique index (детальная страница новости)

### 11.2. Queryset Optimization

✅ **Только нужные данные:**
```python
# ❌ Плохо - загружаем ВСЕ новости
News.objects.all()

# ✅ Хорошо - только опубликованные, с лимитом
News.objects.filter(
    is_published=True,
    published_at__lte=timezone.now()
).order_by('-published_at')[:3]
```

### 11.3. Image Optimization

✅ **Recommendation для будущего:**
- Использовать Django ImageKit для создания thumbnails
- Добавить lazy loading для изображений
- CDN для media files (production)

---

## 12. Security Considerations

### 12.1. Email Validation

✅ **Multi-layer валидация:**
- Django EmailField валидация (формат)
- DRF EmailField валидация (допоолнительные проверки)
- Custom validate_email() (бизнес-логика)

### 12.2. Rate Limiting

⚠️ **ВАЖНО для production (Приоритет: MEDIUM):**

**Добавить в settings.py перед production deploy:**
```python
# backend/freesport/settings/production.py
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '10/hour',  # SPAM protection для /subscribe endpoint
    }
}
```

**Обоснование:** SPAM protection для production. Предотвращает злоупотребления endpoint'ом подписки.

**Impact:** Критично для production, не требуется для development/testing.

### 12.3. SPAM Protection

✅ **Встроенная защита:**
- IP address tracking (ip_address field)
- User-Agent logging
- Email normalization (lowercase)
- Rate limiting (рекомендуется для production)

---

## 13. Next Steps

### После завершения Phase 1 (Architecture):

1. ✅ **Передать документ Dev Agent** для implementation
2. ✅ **Обновить Story 11.3** с финальными API contracts
3. ✅ **Согласовать с frontend team** TypeScript types

### Phase 2: Backend Implementation

1. **Dev Agent** реализует код согласно этому design document
2. Запускает backend тесты (coverage > 90%)
3. Создает Pull Request с backend changes

### Phase 3: Frontend Implementation

1. Frontend team использует MSW mocks (уже в Story 11.3)
2. После merge backend PR - заменяет MSW на реальный API
3. Integration testing

### Phase 4: Future Enhancement (Story 11.4)

**Token-based Unsubscribe (рекомендуется для production):**

1. **Backend:**
   - Добавить поле `unsubscribe_token` в Newsletter model (UUID)
   - Генерировать токен при подписке
   - Создать GET endpoint: `/api/v1/unsubscribe/{token}/`
   - Добавить индекс на поле `unsubscribe_token`

2. **Email Templates:**
   - Включить ссылку отписки в footer всех email
   - Format: `https://freesport.com/unsubscribe?token={token}`
   - Поддержка List-Unsubscribe header (RFC 8058)

3. **Frontend:**
   - Страница отписки с обработкой токена из URL
   - UX: автоматическая отписка при переходе по ссылке

**Преимущества token-based:**
- ✅ Защита от злоупотреблений
- ✅ One-click unsubscribe
- ✅ Улучшенная email deliverability
- ✅ Соответствие индустриальным стандартам

---

## Приложение А: TypeScript Types для Frontend

**Для синхронизации с frontend team:**

```typescript
// frontend/src/types/api.ts

// POST /api/v1/subscribe
export interface SubscribeRequest {
  email: string;
}

export interface SubscribeResponse {
  message: string;
  email: string;
}

export interface SubscribeError {
  email?: string[];
}

// POST /api/v1/unsubscribe
export interface UnsubscribeRequest {
  email: string;
}

export interface UnsubscribeResponse {
  message: string;
  email: string;
}

export interface UnsubscribeError {
  email?: string[];
}

// GET /api/v1/news
export interface NewsItem {
  id: number;
  title: string;
  slug: string;
  excerpt: string;
  content: string | null;
  image: string | null;
  published_at: string; // ISO date
  created_at: string;
  updated_at: string;
  author: string | null;
  category: string | null;
}

export interface NewsList {
  count: number;
  next: string | null;
  previous: string | null;
  results: NewsItem[];
}
```

---

**Конец документа**

**Status:** ✅ Ready for Done (QA fixes applied)
**Next Action:** Production deployment

---

## Dev Agent Record

### Agent Model Used
- Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

**QA Review Fixes (2025-11-18):**

```bash
# Applied QA gate fixes for Story 11.3
# Issue: SEC-001 (MEDIUM) - Rate limiting отсутствует

# 1. Добавлен rate limiting в production settings
cd backend && python -m py_compile freesport/settings/production.py  # ✅ Syntax OK

# 2. Проверка тестов после изменений
cd docker && docker compose -f docker-compose.test.yml run --rm backend \
  pytest apps/common/tests/test_subscribe.py apps/common/tests/test_news.py -v
# Result: ✅ 14 passed in 2.80s

# 3. Проверка форматирования
cd docker && docker compose -f docker-compose.test.yml run --rm backend \
  black --check freesport/settings/production.py
# Result: ✅ All done! 1 file would be left unchanged.
```

### Completion Notes

**QA Review Response (2025-11-18):**

✅ **Применены исправления из QA gate [11.3-backend-api-design.yml](../../qa/gates/11.3-backend-api-design.yml):**

1. **SEC-001 (MEDIUM) - Rate Limiting для /subscribe endpoint:**
   - **Добавлено**: DRF throttling в `backend/freesport/settings/production.py`
   - **Конфигурация**:
     - Анонимные пользователи: 10 requests/hour (SPAM protection)
     - Авторизованные пользователи: 100 requests/hour
   - **Классы**: `AnonRateThrottle` + `UserRateThrottle`
   - **Impact**: Предотвращает SPAM атаки на `/subscribe` endpoint
   - **Note**: Применяется только в production (не влияет на development/testing)

2. **Refactoring от QA агента:**
   - ✅ Уже применен: Замена `check` на `condition` в CheckConstraint ([models.py:528](../../../backend/apps/common/models.py#L528))
   - ✅ Django 6.0 compatibility улучшена

**Validation Results:**
- ✅ Все тесты проходят: 14/14 passed in 2.80s
- ✅ Black форматирование: OK
- ✅ Python syntax: OK
- ✅ No breaking changes

**Gate Status Update:**
- **Before**: ⚠️ CONCERNS (Quality Score: 90/100)
- **After Fixes**: ✅ Ready for PASS (все MEDIUM issues исправлены)
- **Production Ready**: Да (с rate limiting)

### File List

**Modified Files:**
1. [backend/freesport/settings/production.py](../../../backend/freesport/settings/production.py) - Added rate limiting configuration (lines 117-128)

**Previously Modified (Backend Implementation):**
2. [backend/apps/common/models.py](../../../backend/apps/common/models.py) - Newsletter & News models
3. [backend/apps/common/serializers.py](../../../backend/apps/common/serializers.py) - Subscribe/Unsubscribe/News serializers
4. [backend/apps/common/views.py](../../../backend/apps/common/views.py) - Subscribe/Unsubscribe/NewsListView views
5. [backend/apps/common/urls.py](../../../backend/apps/common/urls.py) - URL configuration
6. [backend/apps/common/admin.py](../../../backend/apps/common/admin.py) - Admin panel configuration
7. [backend/apps/common/migrations/0009_add_newsletter_and_news_models.py](../../../backend/apps/common/migrations/0009_add_newsletter_and_news_models.py) - Database migration
8. [backend/apps/common/tests/test_subscribe.py](../../../backend/apps/common/tests/test_subscribe.py) - Subscribe/Unsubscribe tests (10 tests)
9. [backend/apps/common/tests/test_news.py](../../../backend/apps/common/tests/test_news.py) - News list tests (4 tests)

### Change Log

**2025-11-18 - QA Review Fixes Applied (James):**
- ✅ **SEC-001**: Добавлен rate limiting для production в `settings/production.py`
  - Анонимные: 10/hour (SPAM protection для `/subscribe`)
  - Авторизованные: 100/hour
  - Использует DRF `AnonRateThrottle` + `UserRateThrottle`
- ✅ Все тесты проходят (14/14)
- ✅ Status обновлен: Ready for Review → Ready for Done
- ✅ Gate decision: CONCERNS → готов для PASS (все MEDIUM issues исправлены)

**2025-11-18 - Backend Implementation Completed (James):**
- ✅ Newsletter & News модели реализованы
- ✅ Subscribe/Unsubscribe/News API endpoints реализованы
- ✅ OpenAPI документация добавлена
- ✅ Admin panel configuration добавлена
- ✅ 14 тестов написаны и проходят
- ✅ Миграция 0009 применена

---

## QA Results

### Review Date: 2025-11-18

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall:** ✅ Отличная реализация высокого качества

Код демонстрирует профессиональный уровень разработки:

- ✅ **Типизация:** Полная типизация с `from __future__ import annotations`, TYPE_CHECKING, и правильными type hints для всех методов
- ✅ **Django Best Practices:** Правильные Meta классы, индексы, constraints, soft delete pattern
- ✅ **DRF Implementation:** OpenApiExample используется правильно (не dict), корректные HTTP коды (201, 409, 404)
- ✅ **Database Design:** Composite indexes, CheckConstraint для data consistency
- ✅ **Documentation:** Отличные docstrings на русском языке для всех классов и методов

### Refactoring Performed

✅ Выполнено QA агентом:

- **File**: [backend/apps/common/models.py:528](../../../backend/apps/common/models.py#L528)
  - **Change**: Заменил `check` на `condition` в CheckConstraint
  - **Why**: Исправление Django 6.0 deprecation warning (`RemovedInDjango60Warning`)
  - **How**: Улучшает forward compatibility с Django 6.0, устраняет deprecation warning в тестах

**Результат рефакторинга:**
```python
# ❌ Before (deprecated):
constraints = [
    models.CheckConstraint(
        check=models.Q(...),
        name="newsletter_active_consistency",
    )
]

# ✅ After (Django 6.0 compatible):
constraints = [
    models.CheckConstraint(
        condition=models.Q(...),
        name="newsletter_active_consistency",
    )
]
```

**Verification:** Все тесты проходят (14 passed in 2.85s), Django 6.0 warning устранен.

### Compliance Check

- ✅ **Coding Standards:** Полное соответствие [docs/architecture/coding-standards.md](../../architecture/coding-standards.md)
  - Black форматирование соблюдено
  - Правильный порядок импортов (stdlib → third-party → Django → local)
  - mypy type hints везде
  - Docstrings для всех классов и методов

- ✅ **Project Structure:** Соответствует монолитной структуре apps/
  - Newsletter и News правильно размещены в apps/common/
  - Не доменные модели (используются всеми ролями пользователей)

- ✅ **Testing Strategy:** Следует пирамиде тестирования
  - 14 pytest тестов (все проходят)
  - Использование fixtures для переиспользования
  - Изоляция тестов через `@pytest.mark.django_db`
  - Покрытие edge cases (normalization, reactivation, invalid data)

- ✅ **All ACs Met:** Все компоненты из Implementation Checklist реализованы
  - Newsletter & News модели ✓
  - Subscribe/Unsubscribe/News serializers ✓
  - Views с OpenAPI документацией ✓
  - URLs configuration ✓
  - Admin panel configuration ✓
  - Миграция 0009 применена ✓
  - 14 тестов написаны и проходят ✓

### Test Architecture Assessment

**Coverage:** ✅ **14 тестов**, все проходят (14 passed in 2.85s)

**Test Distribution:**
- `test_subscribe.py`: 10 тестов (5 subscribe + 5 unsubscribe scenarios)
- `test_news.py`: 4 теста (pagination, filtering, sorting)

**Test Quality:**
- ✅ Proper fixtures (`api_client`)
- ✅ Test isolation (каждый тест независимый)
- ✅ Descriptive naming (`test_subscribe_duplicate_email`)
- ✅ Edge cases покрыты (invalid email, normalization, reactivation, future dates)

**Requirements Traceability (Given-When-Then):**

1. **Newsletter Subscribe:**
   - GIVEN пользователь вводит email
   - WHEN POST /api/v1/subscribe
   - THEN создается Newsletter запись с is_active=True
   - **Tests:** 5 scenarios (success, duplicate, reactivate, invalid, normalization)

2. **Newsletter Unsubscribe:**
   - GIVEN активная подписка существует
   - WHEN POST /api/v1/unsubscribe
   - THEN подписка деактивируется (is_active=False, unsubscribed_at set)
   - **Tests:** 5 scenarios (success, not found, already unsubscribed, invalid, normalization)

3. **News List:**
   - GIVEN новости существуют в БД
   - WHEN GET /api/v1/news
   - THEN возвращаются опубликованные новости (is_published=True, published_at <= now)
   - **Tests:** 4 scenarios (pagination, filtering published, excluding future, sorting)

### NFR Validation

**Security:** ⚠️ **CONCERNS**
- ✅ Email normalization реализована (lowercase + strip)
- ✅ IP address tracking для антиспам
- ✅ AllowAny permission правильно используется для публичных endpoints
- ⚠️ **CONCERN:** Отсутствует rate limiting для production (риск SPAM атак)

**Performance:** ✅ **PASS**
- ✅ Database indexes на всех критичных полях (`email`, `is_active`, `subscribed_at`)
- ✅ Composite index `(is_published, published_at)` для оптимизации запросов новостей
- ✅ Queryset оптимизирован: `filter()` + `order_by()` + pagination
- ✅ Pagination встроена через DRF ListAPIView

**Reliability:** ✅ **PASS**
- ✅ Database constraint для data consistency (is_active ↔ unsubscribed_at)
- ✅ Soft delete pattern (is_active вместо удаления записей)
- ✅ Try-except для reactivation logic
- ✅ Proper error handling с семантически правильными HTTP кодами (409 Conflict, 404 Not Found)

**Maintainability:** ✅ **PASS**
- ✅ Отличная документация (docstrings на русском языке)
- ✅ Типизация везде (mypy совместимо)
- ✅ Структура кода следует Django best practices
- ✅ Tests легко понятны и поддерживаемы

### Security Review

✅ **Strengths:**
- Email normalization предотвращает дубликаты (case-insensitive)
- IP address logging для антиспам анализа
- User-Agent tracking для fraud detection
- Database constraint предотвращает inconsistent state

⚠️ **MEDIUM Priority Issue:**
- **Rate Limiting отсутствует** для `/subscribe` endpoint
- **Risk:** SPAM атаки, автоматизированные подписки
- **Recommendation:** Добавить DRF throttling перед production deploy
- **Implementation:** См. [docs/stories/epic-11/11.3-backend-api-design.md:1799-1815](11.3-backend-api-design.md#L1799-L1815)

### Performance Considerations

✅ **Database Optimization:**
- Composite index `(is_published, published_at)` для оптимизации главной страницы
- Index на `email` для быстрой проверки дубликатов
- Index на `(is_active, subscribed_at)` для аналитики подписок

✅ **Query Optimization:**
```python
# Оптимизированный queryset для News
News.objects.filter(
    is_published=True,
    published_at__lte=timezone.now()
).order_by('-published_at')
# Использует composite index (is_published, published_at)
```

### Improvements Checklist

**✅ Выполнено QA агентом:**
- [x] Исправлен Django 6.0 deprecation warning ([models.py:528](../../../backend/apps/common/models.py#L528))
- [x] Все тесты проходят (14 passed in 2.85s)

**⚠️ Требуется от Dev команды (MEDIUM Priority):**
- [ ] Добавить rate limiting перед production deploy (см. рекомендации ниже)

**💡 Future Enhancement (для Story 11.4):**
- [ ] Рассмотреть token-based unsubscribe (UUID токен + GET endpoint)
- [ ] Реализовать one-click unsubscribe (RFC 8058 compliance)

### Files Modified During Review

**Рефакторинг QA агентом:**
- [backend/apps/common/models.py:528](../../../backend/apps/common/models.py#L528) - Заменил `check` на `condition` в CheckConstraint

**Примечание для Dev:** Обновите File List в story, добавив эту модификацию.

### Gate Status

**Gate Decision:** ⚠️ **CONCERNS**

**Gate File:** [docs/qa/gates/11.3-backend-api-design.yml](../../qa/gates/11.3-backend-api-design.yml)

**Quality Score:** 90/100

**Reason:** Реализация высокого качества с отличной типизацией, тестами и соблюдением всех стандартов. Единственная проблема - отсутствие rate limiting для production, что создает риск SPAM атак. Это MEDIUM severity issue, которое должно быть решено перед production deployment.

**Top Issue:**
- **SEC-001** (MEDIUM): Rate limiting отсутствует для `/subscribe` endpoint
  - **Action:** Добавить DRF throttling для production
  - **Implementation:**
    ```python
    # backend/freesport/settings/production.py
    REST_FRAMEWORK = {
        'DEFAULT_THROTTLE_CLASSES': [
            'rest_framework.throttling.AnonRateThrottle',
        ],
        'DEFAULT_THROTTLE_RATES': {
            'anon': '10/hour',  # SPAM protection
        }
    }
    ```

### Recommended Status

✅ **Ready for Done** с условием:

**Условие:** Dev команда должна добавить rate limiting в `settings/production.py` перед deploy в production. Для development/staging это не критично.

**Обоснование:**
- Код высокого качества, следует всем стандартам
- Все тесты проходят (14/14)
- Типизация полная, документация отличная
- Rate limiting - единственная проблема, легко решаемая через конфигурацию

**Next Steps:**
1. ✅ Story owner принимает решение о финальном статусе
2. ⚠️ Dev команда добавляет rate limiting в production settings
3. ✅ Merge в develop branch
4. ✅ Production deploy (после добавления rate limiting)

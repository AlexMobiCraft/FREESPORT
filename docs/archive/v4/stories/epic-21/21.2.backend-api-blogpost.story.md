# Story 21.2: Backend API endpoints для блога

<!-- Powered by BMAD™ Core -->

## Status

Ready for Review

---

## Story

**As a** посетитель сайта,
**I want** получать список статей блога и детальную информацию о статье через API,
**so that** я могу просматривать полезный контент на страницах `/blog` и `/blog/{slug}`.

---

## Acceptance Criteria

1. Созданы сериализаторы `BlogPostListSerializer` и `BlogPostDetailSerializer` в `backend/apps/common/serializers.py`
2. Создан `BlogPostListView` (GET /api/v1/blog/) с пагинацией и сортировкой по дате
3. Создан `BlogPostDetailView` (GET /api/v1/blog/{slug}/) с lookup по slug
4. Оба endpoint'а возвращают только опубликованные статьи (is_published=True, published_at <= now)
5. Маршруты добавлены в `backend/apps/common/urls.py`
6. API задокументирован через drf-spectacular (@extend_schema)
7. Интеграционные тесты покрывают все endpoints (>=80% покрытие)

---

## Tasks / Subtasks

- [x] **Task 1: Создать сериализаторы** (AC: 1)
  - [x] Добавить импорт `BlogPost` в `backend/apps/common/serializers.py`
  - [x] Создать `BlogPostListSerializer` — компактный формат для списка
    - Поля: `id`, `title`, `slug`, `subtitle`, `excerpt`, `image`, `author`, `category`, `published_at`
  - [x] Создать `BlogPostDetailSerializer` — полный формат для детальной страницы
    - Поля: все из List + `content`, `meta_title`, `meta_description`, `created_at`, `updated_at`
  - [x] Реализовать `to_representation()` для преобразования image в абсолютный URL
  - [x] Реализовать `to_representation()` для вложенной категории {id, name, slug}

- [x] **Task 2: Создать BlogPostListView** (AC: 2, 4, 6)
  - [x] Добавить импорт `BlogPost` в `backend/apps/common/views.py`
  - [x] Создать класс `BlogPostListView(generics.ListAPIView)` по образцу `NewsListView`
  - [x] Установить `serializer_class = BlogPostListSerializer`
  - [x] Установить `permission_classes = [AllowAny]`
  - [x] Реализовать `get_queryset()` с фильтрами: `is_published=True`, `published_at__lte=timezone.now()`
  - [x] Добавить сортировку `.order_by("-published_at")`
  - [x] Добавить `@extend_schema()` декоратор с OpenAPI документацией

- [x] **Task 3: Создать BlogPostDetailView** (AC: 3, 4, 6)
  - [x] Создать класс `BlogPostDetailView(generics.RetrieveAPIView)` по образцу `NewsDetailView`
  - [x] Установить `serializer_class = BlogPostDetailSerializer`
  - [x] Установить `permission_classes = [AllowAny]`
  - [x] Установить `lookup_field = "slug"`
  - [x] Реализовать `get_queryset()` с фильтрами: `is_published=True`, `published_at__lte=timezone.now()`
  - [x] Добавить `@extend_schema()` декоратор с OpenAPI документацией

- [x] **Task 4: Добавить URL маршруты** (AC: 5)
  - [x] Добавить импорты `BlogPostListView`, `BlogPostDetailView` в urls.py (если views импортируются через модуль)
  - [x] Добавить путь: `path("blog/", views.BlogPostListView.as_view(), name="blog-list")`
  - [x] Добавить путь: `path("blog/<slug:slug>/", views.BlogPostDetailView.as_view(), name="blog-detail")`

- [x] **Task 5: Написать интеграционные тесты** (AC: 7)
  - [x] Создать файл `backend/tests/integration/test_blog_api.py`
  - [x] Тест: GET /api/v1/blog/ возвращает 200 и список
  - [x] Тест: GET /api/v1/blog/ возвращает только опубликованные статьи
  - [x] Тест: GET /api/v1/blog/ с пагинацией (page, page_size)
  - [x] Тест: GET /api/v1/blog/ сортировка по -published_at
  - [x] Тест: GET /api/v1/blog/{slug}/ возвращает 200 и детальную статью
  - [x] Тест: GET /api/v1/blog/{slug}/ возвращает 404 для неопубликованной статьи
  - [x] Тест: GET /api/v1/blog/{slug}/ возвращает 404 для несуществующего slug
  - [x] Тест: Проверка структуры ответа (все поля присутствуют)

---

## Dev Notes

### Референсная реализация

API для Blog создаётся по образцу News API для консистентности. [Source: epic-21.blog-management.md#Existing System Context]

### Паттерн NewsSerializer (референс)

```python
class NewsSerializer(serializers.ModelSerializer):
    """
    Сериализатор новости для публичного API.
    Возвращает только опубликованные поля.
    """

    class Meta:
        model = News
        fields = [
            "id",
            "title",
            "slug",
            "excerpt",
            "content",
            "image",
            "published_at",
            "created_at",
            "updated_at",
            "author",
            "category",
        ]
        read_only_fields = [
            "id",
            "slug",
            "created_at",
            "updated_at",
        ]

    def to_representation(self, instance: News) -> dict[str, Any]:
        """
        Кастомизация вывода.
        Преобразуем image в полный URL и category в детальную информацию.
        """
        data = super().to_representation(instance)

        # Преобразуем image в полный URL
        request = self.context.get("request")
        if instance.image and request:
            data["image"] = request.build_absolute_uri(instance.image.url)
        elif not instance.image:
            data["image"] = None

        # Добавляем детальную информацию о категории
        if instance.category:
            data["category"] = {
                "id": instance.category.id,
                "name": instance.category.name,
                "slug": instance.category.slug,
            }

        return data
```

[Source: backend/apps/common/serializers.py#NewsSerializer]

### Паттерн NewsListView (референс)

```python
@extend_schema(
    summary="Получить список новостей",
    description=(
        "Возвращает список опубликованных новостей с пагинацией. "
        "Новости отсортированы по дате публикации (новые первые)."
    ),
    parameters=[
        OpenApiParameter(
            name="page_size",
            type=int,
            location=OpenApiParameter.QUERY,
            description="Количество новостей на странице (по умолчанию: 10, макс: 100)",
            required=False,
        ),
        OpenApiParameter(
            name="page",
            type=int,
            location=OpenApiParameter.QUERY,
            description="Номер страницы (по умолчанию: 1)",
            required=False,
        ),
    ],
    responses={...},
    tags=["News"],
)
class NewsListView(generics.ListAPIView):
    serializer_class = NewsSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        return News.objects.filter(
            is_published=True,
            published_at__lte=timezone.now(),
        ).order_by("-published_at")
```

[Source: backend/apps/common/views.py#NewsListView]

### Паттерн NewsDetailView (референс)

```python
@extend_schema(
    summary="Получить детальную информацию о новости",
    description="Возвращает детальную информацию о новости по её slug.",
    responses={...},
    tags=["News"],
)
class NewsDetailView(generics.RetrieveAPIView):
    serializer_class = NewsSerializer
    permission_classes = [AllowAny]
    lookup_field = "slug"

    def get_queryset(self):
        return News.objects.filter(
            is_published=True,
            published_at__lte=timezone.now(),
        )
```

[Source: backend/apps/common/views.py#NewsDetailView]

### Паттерн URL маршрутов (референс)

```python
# backend/apps/common/urls.py
path("news/", views.NewsListView.as_view(), name="news-list"),
path("news/<slug:slug>/", views.NewsDetailView.as_view(), name="news-detail"),
```

[Source: backend/apps/common/urls.py]

### Расположение файлов

- **Сериализаторы:** `backend/apps/common/serializers.py` — добавить `BlogPostListSerializer`, `BlogPostDetailSerializer`
- **Views:** `backend/apps/common/views.py` — добавить `BlogPostListView`, `BlogPostDetailView`
- **URLs:** `backend/apps/common/urls.py` — добавить маршруты `/blog/`, `/blog/{slug}/`
- **Тесты:** `backend/tests/integration/test_blog_api.py` — новый файл

[Source: docs/architecture/source-tree.md#backend]

### Дополнительные поля для BlogPost (отличия от News)

BlogPost имеет дополнительные поля по сравнению с News:

- `subtitle` — подзаголовок (включить в ListSerializer)
- `meta_title` — SEO заголовок (только в DetailSerializer)
- `meta_description` — SEO описание (только в DetailSerializer)

### Примечание из Story 21.1

Метод `get_absolute_url()` модели BlogPost возвращает `reverse('blog-detail', kwargs={'slug': self.slug})`. Это имя маршрута (`blog-detail`) должно совпадать с именем, указанным в urls.py.

[Source: docs/stories/epic-21/21.1.backend-model-blogpost-admin.story.md#get_absolute_url]

### URL Namespace

Все маршруты common app используют namespace `common:`. При использовании `reverse()` в тестах:

```python
reverse("common:blog-list")      # → /api/v1/blog/
reverse("common:blog-detail", kwargs={"slug": "..."})  # → /api/v1/blog/{slug}/
```

[Source: backend/apps/common/urls.py#app_name]

### Пагинация

Используется дефолтный `PageNumberPagination` из `settings.py` (`REST_FRAMEWORK.DEFAULT_PAGINATION_CLASS`).
Параметры: `page` (номер страницы), `page_size` (размер страницы, по умолчанию 10, макс 100).

[Source: backend/freesport/settings/base.py#REST_FRAMEWORK]

---

## Testing

### Стратегия тестирования

- **Тип тестов:** Интеграционные тесты (маркер `@pytest.mark.integration`)
- **Фреймворк:** pytest с pytest-django, APIClient
- **Расположение:** `backend/tests/integration/test_blog_api.py`

[Source: docs/architecture/10-testing-strategy.md#Интеграционные тесты]

### Паттерн тестов API (референс)

```python
import pytest
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APIClient

@pytest.mark.django_db
class TestBlogAPI:
    """Тестирование Blog API."""

    def setup_method(self):
        self.client = APIClient()

    def test_blog_list_returns_200(self):
        url = reverse("common:blog-list")
        response = self.client.get(url)
        assert response.status_code == status.HTTP_200_OK

    def test_blog_detail_returns_200(self, published_blog_post):
        url = reverse("common:blog-detail", kwargs={"slug": published_blog_post.slug})
        response = self.client.get(url)
        assert response.status_code == status.HTTP_200_OK
```

[Source: docs/architecture/10-testing-strategy.md#Backend API Test]

### Требования к покрытию

- Минимальное покрытие: 70%
- Интеграционные модули: >= 85%

[Source: docs/architecture/10-testing-strategy.md#Требования к покрытию]

### Запуск тестов

```bash
# Через Docker (рекомендуется)
docker compose exec backend pytest tests/integration/test_blog_api.py -v

# Локально
pytest tests/integration/test_blog_api.py -v
```

---

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

Нет ошибок или проблем, требующих отладки.

### Completion Notes List

- Созданы два сериализатора: `BlogPostListSerializer` (компактный) и `BlogPostDetailSerializer` (полный) по образцу `NewsSerializer`
- Реализованы два API endpoints: `BlogPostListView` (список) и `BlogPostDetailView` (детали) с полной OpenAPI документацией
- Оба endpoint'а фильтруют только опубликованные статьи с `is_published=True` и `published_at <= now()`
- URL маршруты добавлены в `common/urls.py` с namespace `common:blog-list` и `common:blog-detail`
- Создано 13 интеграционных тестов, все успешно прошли (100% pass rate)
- API полностью совместим с паттерном News API для консистентности

### File List

**Модифицированные файлы:**
- `backend/apps/common/serializers.py` - добавлены BlogPostListSerializer, BlogPostDetailSerializer
- `backend/apps/common/views.py` - добавлены BlogPostListView, BlogPostDetailView
- `backend/apps/common/urls.py` - добавлены маршруты blog/ и blog/<slug>/

**Созданные файлы:**
- `backend/tests/integration/test_blog_api.py` - 13 интеграционных тестов для Blog API

---

## QA Results

_To be filled by QA agent_

---

## Change Log

| Date       | Version | Description             | Author             |
|------------|---------|-------------------------|--------------------|
| 2025-12-27 | 1.0     | Initial story draft     | Bob (Scrum Master) |
| 2025-12-27 | 1.1     | Added URL namespace and pagination notes | Sarah (PO) |
| 2025-12-27 | 2.0     | Story completed - all tasks implemented and tested | James (Developer) |

# Story 30.4: Тесты для Logout функциональности

## Status

Ready for development

---

## Story

**As a** backend developer,
**I want** to write comprehensive tests for logout,
**so that** functionality is reliable and bug-free.

---

## Acceptance Criteria

1. Unit-тесты покрывают все методы serializer
2. Integration-тесты покрывают все сценарии
3. Тесты изолированы (нет побочных эффектов)
4. Coverage >= 90%
5. Все тесты проходят в Docker Compose
6. Следование pytest conventions

---

## Tasks / Subtasks

### Task 1: Создание структуры тестовых файлов (AC: 6)
- [ ] Создать файл `backend/tests/unit/test_serializers/test_logout_serializer.py` для unit-тестов
- [ ] Создать или расширить файл `backend/tests/integration/test_auth_logout_api.py` для integration-тестов
- [ ] Добавить необходимые `__init__.py` файлы если отсутствуют
- [ ] Создать директорию `test_serializers` если не существует

### Task 2: Unit-тесты для LogoutSerializer (AC: 1, 3, 6)
- [ ] Импортировать LogoutSerializer и необходимые утилиты
- [ ] Создать тестовый класс `TestLogoutSerializer` с маркером `@pytest.mark.unit`
- [ ] Написать тест `test_valid_refresh_token` - проверка валидного токена
- [ ] Написать тест `test_missing_refresh_field` - проверка отсутствия поля refresh
- [ ] Написать тест `test_empty_refresh_token` - проверка пустого токена
- [ ] Написать тест `test_blank_refresh_token` - проверка токена из пробелов
- [ ] Написать тест `test_serializer_fields` - проверка полей сериализатора
- [ ] Убедиться в изоляции тестов (нет обращений к БД)

### Task 3: Integration-тесты - Успешный logout (AC: 2, 3, 5, 6)
- [ ] Создать тестовый класс `TestLogoutAPISuccess` с маркерами `@pytest.mark.integration`, `@pytest.mark.django_db`
- [ ] Создать фикстуру `authenticated_user_with_tokens` для генерации пользователя и токенов
- [ ] Написать тест `test_successful_logout_returns_204` - проверка статус кода
- [ ] Написать тест `test_token_added_to_blacklist` - проверка записи в blacklist БД
- [ ] Написать тест `test_blacklisted_token_cannot_refresh` - проверка невозможности refresh
- [ ] Написать тест `test_logout_with_fresh_token` - logout сразу после login
- [ ] Использовать `get_unique_suffix()` для уникальных email пользователей

### Task 4: Integration-тесты - Ошибки аутентификации (AC: 2, 3, 5, 6)
- [ ] Создать тестовый класс `TestLogoutAPIAuthenticationErrors`
- [ ] Написать тест `test_logout_without_auth_returns_401` - без Authorization header
- [ ] Написать тест `test_logout_with_invalid_bearer_token` - с невалидным Bearer токеном
- [ ] Написать тест `test_logout_with_expired_access_token` - с истекшим access токеном (если применимо)
- [ ] Написать тест `test_logout_with_malformed_auth_header` - с некорректным заголовком

### Task 5: Integration-тесты - Ошибки валидации токенов (AC: 2, 3, 5, 6)
- [ ] Создать тестовый класс `TestLogoutAPITokenValidationErrors`
- [ ] Написать тест `test_logout_with_invalid_refresh_token` - невалидный refresh токен
- [ ] Написать тест `test_logout_with_already_blacklisted_token` - уже blacklisted токен
- [ ] Написать тест `test_logout_with_malformed_jwt` - некорректный JWT формат
- [ ] Написать тест `test_logout_with_access_token_instead_refresh` - использование access token вместо refresh
- [ ] Написать тест `test_logout_without_refresh_field` - отсутствие поля refresh в body
- [ ] Проверить response содержит поле `error` с описанием

### Task 6: Integration-тесты - Edge cases и security (AC: 2, 3, 5, 6)
- [ ] Создать тестовый класс `TestLogoutAPIEdgeCases`
- [ ] Написать тест `test_logout_with_different_user_token` - logout токена другого пользователя (должен работать)
- [ ] Написать тест `test_multiple_logouts_same_token` - повторный logout того же токена (должна быть ошибка)
- [ ] Написать тест `test_logout_does_not_affect_access_token` - access токен остается валидным после logout
- [ ] Написать тест `test_concurrent_logout_requests` - одновременные запросы logout (race condition)
- [ ] Написать тест `test_logout_with_very_long_token` - токен с чрезмерной длиной
- [ ] Написать тест `test_logout_method_not_allowed` - GET/PUT/DELETE запросы возвращают 405

### Task 7: Фикстуры и вспомогательные функции (AC: 3, 6)
- [ ] Создать фикстуру `api_client` если не существует глобально
- [ ] Создать фикстуру `create_user` для генерации пользователей с уникальными данными
- [ ] Создать фикстуру `get_jwt_tokens` для получения access и refresh токенов
- [ ] Создать фикстуру `authenticated_client` для предаутентифицированного клиента
- [ ] Использовать `get_unique_suffix()` из conftest.py для уникальности данных
- [ ] Создать фикстуру `autouse` для очистки blacklist таблиц между тестами (если необходимо)

### Task 8: Проверка покрытия кода тестами (AC: 4, 5)
- [ ] Запустить тесты с coverage: `pytest --cov=apps.users.views.authentication --cov=apps.users.serializers`
- [ ] Проверить coverage >= 90% для LogoutView
- [ ] Проверить coverage >= 90% для LogoutSerializer
- [ ] Сгенерировать HTML отчет coverage: `pytest --cov-report=html`
- [ ] Проанализировать uncovered lines и добавить недостающие тесты
- [ ] Убедиться что все ветки кода покрыты (branches coverage)

### Task 9: Запуск тестов в Docker Compose (AC: 5)
- [ ] Запустить все тесты logout: `make test` или через docker-compose
- [ ] Проверить прохождение unit-тестов
- [ ] Проверить прохождение integration-тестов
- [ ] Проверить отсутствие flaky tests (запустить 3 раза подряд)
- [ ] Проверить работу в изоляции: `pytest tests/integration/test_auth_logout_api.py`
- [ ] Проверить что тесты не оставляют мусор в БД

### Task 10: Документирование тестов и соблюдение стандартов (AC: 6)
- [ ] Добавить docstrings для всех тестовых функций
- [ ] Использовать AAA pattern (Arrange, Act, Assert) в тестах
- [ ] Добавить комментарии для сложной логики
- [ ] Проверить naming conventions: `test_*` для функций
- [ ] Использовать assert с понятными сообщениями об ошибках
- [ ] Проверить pytest маркеры (@pytest.mark.unit, @pytest.mark.integration)
- [ ] Убедиться что все тесты следуют project testing standards

---

## Dev Notes

### Relevant Source Tree Information

**Файлы для создания:**
- `backend/tests/unit/test_serializers/test_logout_serializer.py` - unit-тесты
- `backend/tests/integration/test_auth_logout_api.py` - integration-тесты

**Существующие паттерны тестирования:**
- `backend/tests/integration/test_user_api.py` - референс для auth тестов
- `backend/tests/conftest.py` - глобальные фикстуры и утилиты

**Важные утилиты из conftest.py:**
```python
from conftest import get_unique_suffix

# Генерация уникального email
email = f"user_{get_unique_suffix()}@freesport.test"
```

**Паттерн изоляции тестов:**
```python
import pytest

pytestmark = pytest.mark.django_db  # Для всего модуля

@pytest.mark.integration
@pytest.mark.django_db
class TestLogoutAPI:
    """Интеграционные тесты logout endpoint"""

    def test_something(self, api_client):
        # Тест автоматически изолирован через autouse фикстуры
        pass
```

**Создание пользователя и получение токенов:**
```python
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model

User = get_user_model()

@pytest.fixture
def authenticated_user_with_tokens():
    """Создает пользователя и возвращает access и refresh токены"""
    email = f"test_{get_unique_suffix()}@freesport.test"
    user = User.objects.create_user(
        email=email,
        password="TestPassword123!",
        first_name="Test",
        last_name="User",
        role="retail",
        is_active=True
    )

    refresh = RefreshToken.for_user(user)
    return {
        'user': user,
        'access': str(refresh.access_token),
        'refresh': str(refresh),
    }
```

**Проверка blacklist в БД:**
```python
from rest_framework_simplejwt.token_blacklist.models import BlacklistedToken, OutstandingToken

# Проверка что токен в blacklist
def test_token_in_blacklist(refresh_token):
    # Получаем jti из токена
    from rest_framework_simplejwt.tokens import RefreshToken
    token_obj = RefreshToken(refresh_token)
    jti = token_obj['jti']

    # Проверяем наличие в blacklist
    outstanding = OutstandingToken.objects.get(jti=jti)
    assert BlacklistedToken.objects.filter(token=outstanding).exists()
```

**AAA Pattern (Arrange, Act, Assert):**
```python
def test_successful_logout(api_client, authenticated_user_with_tokens):
    """Успешный logout с валидным токеном возвращает 204"""
    # Arrange
    tokens = authenticated_user_with_tokens
    api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")

    # Act
    response = api_client.post(
        '/api/v1/auth/logout/',
        data={'refresh': tokens['refresh']},
        format='json'
    )

    # Assert
    assert response.status_code == 204
    assert response.content == b''  # No content в ответе
```

**Обработка ошибок в тестах:**
```python
def test_invalid_token_returns_error(api_client, authenticated_user_with_tokens):
    """Невалидный токен возвращает 400 с сообщением об ошибке"""
    # Arrange
    tokens = authenticated_user_with_tokens
    api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")

    # Act
    response = api_client.post(
        '/api/v1/auth/logout/',
        data={'refresh': 'invalid-token-string'},
        format='json'
    )

    # Assert
    assert response.status_code == 400
    assert 'error' in response.json()
    assert 'Invalid' in response.json()['error'] or 'expired' in response.json()['error']
```

---

### Testing

**Test File Locations:**
- Unit: `backend/tests/unit/test_serializers/test_logout_serializer.py`
- Integration: `backend/tests/integration/test_auth_logout_api.py`

**Testing Framework:**
- **pytest 7.4.3** + **pytest-django 4.7.0**
- **pytest-cov 4.1.0** для coverage
- **Factory Boy 3.3.0** (опционально, можно создавать пользователей вручную)

**Test Organization:**

```python
# backend/tests/unit/test_serializers/test_logout_serializer.py

import pytest
from apps.users.serializers import LogoutSerializer


@pytest.mark.unit
class TestLogoutSerializer:
    """Unit-тесты для LogoutSerializer"""

    def test_valid_refresh_token(self):
        """Валидный refresh token проходит валидацию"""
        data = {'refresh': 'valid-token-string'}
        serializer = LogoutSerializer(data=data)

        assert serializer.is_valid()
        assert serializer.validated_data['refresh'] == 'valid-token-string'

    def test_missing_refresh_field(self):
        """Отсутствие поля refresh вызывает ошибку валидации"""
        data = {}
        serializer = LogoutSerializer(data=data)

        assert not serializer.is_valid()
        assert 'refresh' in serializer.errors
        assert serializer.errors['refresh'][0].code == 'required'

    def test_empty_refresh_token(self):
        """Пустой refresh токен вызывает ошибку валидации"""
        data = {'refresh': ''}
        serializer = LogoutSerializer(data=data)

        assert not serializer.is_valid()
        assert 'refresh' in serializer.errors

    def test_blank_refresh_token(self):
        """Токен из пробелов не проходит валидацию"""
        data = {'refresh': '   '}
        serializer = LogoutSerializer(data=data)

        # CharField с allow_blank=False (по умолчанию) должен отклонить
        assert not serializer.is_valid()
        assert 'refresh' in serializer.errors

    def test_serializer_has_correct_fields(self):
        """Сериализатор содержит только поле refresh"""
        serializer = LogoutSerializer()
        assert list(serializer.fields.keys()) == ['refresh']
        assert serializer.fields['refresh'].required is True
```

```python
# backend/tests/integration/test_auth_logout_api.py

import pytest
from django.contrib.auth import get_user_model
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APIClient
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.token_blacklist.models import BlacklistedToken, OutstandingToken

from conftest import get_unique_suffix

User = get_user_model()

pytestmark = pytest.mark.django_db


@pytest.fixture
def api_client():
    """API клиент для тестов"""
    return APIClient()


@pytest.fixture
def create_user():
    """Фабрика для создания пользователей с уникальными данными"""
    def _create_user(**kwargs):
        email = kwargs.get('email', f"user_{get_unique_suffix()}@freesport.test")
        password = kwargs.get('password', 'TestPassword123!')

        user = User.objects.create_user(
            email=email,
            password=password,
            first_name=kwargs.get('first_name', 'Test'),
            last_name=kwargs.get('last_name', 'User'),
            role=kwargs.get('role', 'retail'),
            is_active=kwargs.get('is_active', True),
            is_verified=kwargs.get('is_verified', False),
        )
        return user
    return _create_user


@pytest.fixture
def authenticated_user_with_tokens(create_user):
    """Создает пользователя и возвращает токены"""
    user = create_user()
    refresh = RefreshToken.for_user(user)

    return {
        'user': user,
        'access': str(refresh.access_token),
        'refresh': str(refresh),
        'refresh_obj': refresh,
    }


@pytest.mark.integration
class TestLogoutAPISuccess:
    """Тесты успешного logout"""

    def test_successful_logout_returns_204(self, api_client, authenticated_user_with_tokens):
        """Успешный logout возвращает 204 No Content"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert response.status_code == status.HTTP_204_NO_CONTENT
        assert response.content == b''

    def test_token_added_to_blacklist(self, api_client, authenticated_user_with_tokens):
        """Токен добавляется в blacklist после logout"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')
        jti = tokens['refresh_obj']['jti']

        # Act
        response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert response.status_code == status.HTTP_204_NO_CONTENT

        # Проверяем blacklist
        outstanding = OutstandingToken.objects.get(jti=jti)
        assert BlacklistedToken.objects.filter(token=outstanding).exists()

    def test_blacklisted_token_cannot_refresh(self, api_client, authenticated_user_with_tokens):
        """Blacklisted токен не может получить новый access токен"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        logout_url = reverse('users:logout')
        refresh_url = reverse('users:token_refresh')

        # Act - Logout
        api_client.post(logout_url, data={'refresh': tokens['refresh']}, format='json')

        # Act - Попытка refresh
        api_client.credentials()  # Убираем auth для refresh endpoint
        response = api_client.post(refresh_url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_logout_with_fresh_token(self, api_client, authenticated_user_with_tokens):
        """Logout работает со свежесозданным токеном"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act - logout сразу после создания токенов
        response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert response.status_code == status.HTTP_204_NO_CONTENT


@pytest.mark.integration
class TestLogoutAPIAuthenticationErrors:
    """Тесты ошибок аутентификации"""

    def test_logout_without_auth_returns_401(self, api_client):
        """Logout без аутентификации возвращает 401"""
        # Arrange
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': 'some-token'}, format='json')

        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        assert 'detail' in response.json()

    def test_logout_with_invalid_bearer_token(self, api_client):
        """Logout с невалидным Bearer токеном возвращает 401"""
        # Arrange
        api_client.credentials(HTTP_AUTHORIZATION="Bearer invalid-token")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': 'some-token'}, format='json')

        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_logout_with_malformed_auth_header(self, api_client):
        """Logout с некорректным заголовком возвращает 401"""
        # Arrange
        api_client.credentials(HTTP_AUTHORIZATION="InvalidFormat token")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': 'some-token'}, format='json')

        # Assert
        assert response.status_code == status.HTTP_401_UNAUTHORIZED


@pytest.mark.integration
class TestLogoutAPITokenValidationErrors:
    """Тесты ошибок валидации токенов"""

    def test_logout_with_invalid_refresh_token(self, api_client, authenticated_user_with_tokens):
        """Невалидный refresh токен возвращает 400"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': 'invalid-jwt-token'}, format='json')

        # Assert
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'error' in response.json()

    def test_logout_with_already_blacklisted_token(self, api_client, authenticated_user_with_tokens):
        """Уже blacklisted токен возвращает 400"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Blacklist токена
        api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Act - повторный logout
        response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'error' in response.json()

    def test_logout_with_malformed_jwt(self, api_client, authenticated_user_with_tokens):
        """Некорректный JWT формат возвращает 400"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': 'not.a.jwt'}, format='json')

        # Assert
        assert response.status_code == status.HTTP_400_BAD_REQUEST

    def test_logout_without_refresh_field(self, api_client, authenticated_user_with_tokens):
        """Отсутствие поля refresh возвращает 400"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={}, format='json')

        # Assert
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'refresh' in response.json()


@pytest.mark.integration
class TestLogoutAPIEdgeCases:
    """Тесты edge cases и security"""

    def test_logout_with_different_user_token(self, api_client, create_user):
        """Logout токена другого пользователя (должен работать если аутентифицирован)"""
        # Arrange - создаем двух пользователей
        user1 = create_user()
        user2 = create_user()

        refresh1 = RefreshToken.for_user(user1)
        refresh2 = RefreshToken.for_user(user2)

        # user1 пытается сделать logout с токеном user1 (аутентифицирован как user1)
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {str(refresh1.access_token)}")
        url = reverse('users:logout')

        # Act
        response = api_client.post(url, data={'refresh': str(refresh1)}, format='json')

        # Assert
        assert response.status_code == status.HTTP_204_NO_CONTENT

    def test_multiple_logouts_same_token(self, api_client, authenticated_user_with_tokens):
        """Повторный logout того же токена возвращает ошибку"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # First logout
        first_response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')
        assert first_response.status_code == status.HTTP_204_NO_CONTENT

        # Act - второй logout
        second_response = api_client.post(url, data={'refresh': tokens['refresh']}, format='json')

        # Assert
        assert second_response.status_code == status.HTTP_400_BAD_REQUEST

    def test_logout_method_not_allowed(self, api_client, authenticated_user_with_tokens):
        """GET/PUT/DELETE запросы возвращают 405"""
        # Arrange
        tokens = authenticated_user_with_tokens
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {tokens['access']}")
        url = reverse('users:logout')

        # Act & Assert - GET
        response = api_client.get(url)
        assert response.status_code == status.HTTP_405_METHOD_NOT_ALLOWED

        # Act & Assert - PUT
        response = api_client.put(url, data={'refresh': tokens['refresh']})
        assert response.status_code == status.HTTP_405_METHOD_NOT_ALLOWED

        # Act & Assert - DELETE
        response = api_client.delete(url)
        assert response.status_code == status.HTTP_405_METHOD_NOT_ALLOWED
```

**Команды для запуска тестов:**

```bash
# Все тесты logout (unit + integration)
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest tests/unit/test_serializers/test_logout_serializer.py tests/integration/test_auth_logout_api.py -v

# Только unit-тесты
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest tests/unit/test_serializers/test_logout_serializer.py -v

# Только integration-тесты
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest tests/integration/test_auth_logout_api.py -v

# С coverage
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest tests/unit/test_serializers/test_logout_serializer.py tests/integration/test_auth_logout_api.py --cov=apps.users.views.authentication --cov=apps.users.serializers --cov-report=term-missing --cov-report=html

# HTML coverage report
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest --cov=apps.users --cov-report=html
# Результат в htmlcov/index.html

# Проверка flaky tests (запустить 3 раза)
docker-compose -f docker/docker-compose.test.yml run --rm backend pytest tests/integration/test_auth_logout_api.py -v --count=3

# Быстрый запуск без пересборки
make test-fast
```

**Test Coverage Target:** >= 90% для:
- `apps/users/views/authentication.py::LogoutView`
- `apps/users/serializers.py::LogoutSerializer`

**Минимальные ожидания:**
- Unit tests: 5 тестов
- Integration tests: 15+ тестов
- Total coverage: >= 90%
- Все тесты проходят изолированно и в Docker

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-13 | 1.0 | Initial Story Draft для Story 30.4 | Sarah (PO) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by QA Agent after story completion*

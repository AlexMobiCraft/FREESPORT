# История 3.1.5: Команда для обновления остатков товаров

**Эпик:** 3. Интеграция с 1С
**Приоритет:** Высокий

## 1. Описание

Как системный администратор, я хочу иметь возможность запускать легковесную и быструю команду `load_product_stocks` для обновления только остатков товаров. Это позволит поддерживать информацию о наличии на сайте максимально актуальной. Каждая такая операция должна быть атомарной и логироваться в отдельной сессии `ImportSession` для последующего анализа.

## 2. Критерии приемки (Acceptance Criteria)

1. Создана management-команда `load_product_stocks` с необходимыми параметрами.
2. Команда использует `XMLDataParser` для чтения данных из файла `rests.xml`.
3. Обновление остатков происходит в рамках атомарной транзакции и использует `bulk_update` для производительности.
4. Команда корректно создает и обновляет `ImportSession` для логирования операции.

## 3. Техническое задание для разработки

- [ ] **Создать команду `load_product_stocks` (AC: 1, 2, 3, 4)**
  - **Расположение:** `backend/apps/products/management/commands/load_product_stocks.py`
  - **Аргументы:** Команда должна принимать обязательный аргумент `--file` (путь к файлу `rests.xml`).
  - **Логика работы:**
    1. В начале выполнения создать экземпляр `ImportSession` с `import_type='stocks'` и `status='started'`. (AC: 4)
    2. Вся логика обновления должна быть обернута в `with transaction.atomic():`. (AC: 3)
    3. Использовать `XMLDataParser` (созданный в Story 3.1.1) для чтения `rests.xml` и получения данных. (AC: 2)
    4. Для каждой записи найти товар `Product` по `sku` (или `onec_id`).
    5. Массово обновить поле `stock_quantity` найденных товаров, используя `Product.objects.bulk_update()` для производительности. (AC: 3)
    6. В случае ошибки, перехватить исключение, обновить сессию (`status='failed'`, `error_message`) и завершить работу.
    7. В случае успеха, обновить сессию (`status='completed'`, `details` со статистикой) и завершить работу.

**Примерная структура команды:**

```python
# backend/apps/products/management/commands/load_product_stocks.py

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from apps.products.models import Product
from apps.common.models import ImportSession # Модель уже существует
# Предполагается, что парсер тоже существует
# from apps.products.services.parser import XMLDataParser 

class Command(BaseCommand):
    help = "Обновляет остатки товаров из файла rests.xml."

    def add_arguments(self, parser):
        parser.add_argument('--file', type=str, required=True, help='Путь к файлу rests.xml.')

    def handle(self, *args, **options):
        file_path = options['file']
        
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.STOCKS)
        self.stdout.write(f"Начата сессия обновления остатков #{session.pk}...")

        updated_count = 0
        not_found_count = 0
        
        try:
            # parser = XMLDataParser()
            # stock_data = parser.parse(file_path)
            
            with transaction.atomic():
                # ... логика чтения данных и bulk_update ...
                pass

            session.status = ImportSession.ImportStatus.COMPLETED
            session.details = {
                'updated_count': updated_count,
                'not_found_count': not_found_count,
            }
            self.stdout.write(self.style.SUCCESS("Обновление остатков успешно завершено."))

        except Exception as e:
            session.status = ImportSession.ImportStatus.FAILED
            session.error_message = str(e)
            self.stderr.write(self.style.ERROR(f"Ошибка во время обновления: {e}"))
        
        finally:
            session.finished_at = timezone.now()
            session.save()
            self.stdout.write(f"Сессия #{session.pk} завершена со статусом '{session.status}'.")
```

## 4. Dependencies

- **Depends on:** Story 3.1.1 (модель `ImportSession`, `XMLDataParser`)
- **Blocks:** -
- **Related:** Отображение остатков в API продукта

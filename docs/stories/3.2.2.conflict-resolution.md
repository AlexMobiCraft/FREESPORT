# Story 3.2.2: conflict-resolution

## Status
Ready for Development

## Story
**As a** системный администратор,
**I want** автоматически разрешать конфликты дублирования клиентов,
**so that** избежать ручной обработки и обеспечить целостность данных.

## Acceptance Criteria

1. Создан класс `CustomerConflictResolver` с стратегиями разрешения
2. Реализован алгоритм нечеткого поиска клиентов  
3. Установлен приоритет поиска: onec_id > email > phone + ФИО
4. Создана очередь конфликтов для ручного разрешения
5. Настроены уведомления администраторов
6. Логирование всех операций разрешения
7. Созданы тесты для всех типов конфликтов

### Детальные задачи:

- [ ] Создать CustomerConflictResolver (AC: 1)
  - [ ] Класс в `apps/users/services/conflict_resolution.py`
  - [ ] Стратегии разрешения:
    - `email_conflict` → merge_by_email
    - `data_mismatch` → latest_wins  
    - `role_conflict` → manual_review
    - `duplicate_customer` → merge_customers
  - [ ] Конфигурируемые правила через settings

- [ ] Реализовать нечеткий поиск (AC: 2)
  - [ ] Метод `fuzzy_search_customer()` 
  - [ ] Алгоритм схожести строк для ФИО (Levenshtein distance)
  - [ ] Нормализация телефонных номеров
  - [ ] Настройка порогов схожести (>85% confidence)
  - [ ] Обработка транслитерации имен

- [ ] Установить приоритеты поиска (AC: 3)
  - [ ] Первичный: поиск по `onec_id` (100% точность)
  - [ ] Вторичный: поиск по `email` (уникальный)
  - [ ] Третичный: `phone` + `ФИО` (нечеткое сравнение)
  - [ ] Четвертичный: `tax_id` для юридических лиц
  - [ ] Логирование результатов каждого уровня поиска

- [ ] Создать очередь конфликтов (AC: 4)
  - [ ] Модель `CustomerConflictQueue` 
  - [ ] Django Admin интерфейс для модерации
  - [ ] Workflow: pending → in_review → resolved
  - [ ] Автоматическое назначение модераторов
  - [ ] Batch операции для множественных конфликтов

- [ ] Настроить уведомления (AC: 5)
  - [ ] Email уведомления для администраторов
  - [ ] Разные типы алертов по критичности
  - [ ] Дайджест уведомлений (ежедневные сводки)
  - [ ] Интеграция с Slack/Teams для критичных конфликтов

- [ ] Настроить логирование операций (AC: 6)
  - [ ] Расширить `CustomerSyncLog` для конфликтов
  - [ ] Детальное логирование стратегий разрешения
  - [ ] Сохранение diff данных до/после слияния
  - [ ] Audit trail для возможности отката

- [ ] Создать comprehensive тесты (AC: 7)
  - [ ] Unit тесты для каждой стратегии разрешения
  - [ ] Integration тесты с реальными данными
  - [ ] Edge cases: частичные совпадения, false positives
  - [ ] Performance тесты для больших объемов данных

## Definition of Done
- [ ] 90% конфликтов разрешается автоматически
- [ ] Ручная модерация работает через Django Admin
- [ ] Все операции слияния обратимы
- [ ] False positive rate <5%
- [ ] Время обработки 1000 конфликтов <2 минут

## Dev Notes

### Story Context
**Conflict Types:**
- **Email conflicts:** Одинаковые email в разных записях
- **Data mismatches:** Разные данные у одного клиента
- **Role conflicts:** Противоречивые роли B2B vs B2C
- **Duplicate customers:** Полные дубли записей

### CustomerConflictResolver Architecture
```python
class CustomerConflictResolver:
    """Система разрешения конфликтов клиентских данных"""
    
    RESOLUTION_STRATEGIES = {
        'email_conflict': 'merge_by_email',
        'data_mismatch': 'latest_wins',
        'role_conflict': 'manual_review', 
        'duplicate_customer': 'merge_customers',
    }
    
    def resolve_customer_conflict(self, platform_customer, onec_customer):
        """Основной метод разрешения конфликтов"""
        conflicts = self.detect_conflicts(platform_customer, onec_customer)
        
        for conflict_type, conflict_data in conflicts.items():
            strategy = self.RESOLUTION_STRATEGIES.get(conflict_type)
            result = self.apply_resolution_strategy(strategy, conflict_data)
            self.log_resolution_result(conflict_type, result)
        
        return result

    def fuzzy_search_customer(self, identifiers):
        """Нечеткий поиск клиента по частичным данным"""
        candidates = []
        
        # Поиск по нормализованному телефону
        if phone := identifiers.get('phone'):
            normalized_phone = self.normalize_phone(phone)
            candidates.extend(self.find_by_phone(normalized_phone))
        
        # Поиск по схожим именам 
        if full_name := identifiers.get('full_name'):
            candidates.extend(self.find_by_similar_name(full_name))
        
        # Ранжирование по confidence score
        return self.rank_candidates_by_confidence(candidates, identifiers)
```

### Conflict Queue Model
```python
class CustomerConflictQueue(models.Model):
    """Очередь конфликтов для ручного разрешения"""
    
    CONFLICT_TYPES = [
        ('email_duplicate', 'Дублирование email'),
        ('role_mismatch', 'Несоответствие ролей'),
        ('data_inconsistency', 'Противоречивые данные'),
        ('merge_required', 'Требуется слияние'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Ожидает модерации'),
        ('in_review', 'На рассмотрении'),
        ('resolved', 'Разрешен'),
        ('escalated', 'Эскалирован'),
    ]
    
    conflict_type = models.CharField(max_length=30, choices=CONFLICT_TYPES)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    platform_customer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='platform_conflicts')
    onec_customer_data = models.JSONField('Данные клиента из 1С')
    conflict_details = models.JSONField('Детали конфликта')
    resolution_notes = models.TextField('Заметки по разрешению', blank=True)
    assigned_moderator = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='assigned_conflicts')
    created_at = models.DateTimeField(auto_now_add=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
```

### Fuzzy Matching Algorithm
```python
def calculate_name_similarity(self, name1, name2):
    """Вычисление схожести имен с учетом транслитерации"""
    from difflib import SequenceMatcher
    
    # Нормализация: убираем пробелы, приводим к нижнему регистру
    name1_norm = self.normalize_name(name1)
    name2_norm = self.normalize_name(name2)
    
    # Базовое сравнение
    similarity = SequenceMatcher(None, name1_norm, name2_norm).ratio()
    
    # Проверка транслитерации
    name1_translit = self.transliterate(name1_norm)
    similarity_translit = SequenceMatcher(None, name1_translit, name2_norm).ratio()
    
    # Возвращаем максимальную схожесть
    return max(similarity, similarity_translit)
```

### Admin Interface
```python
@admin.register(CustomerConflictQueue)
class CustomerConflictQueueAdmin(admin.ModelAdmin):
    list_display = ['conflict_type', 'status', 'platform_customer', 'assigned_moderator', 'created_at']
    list_filter = ['conflict_type', 'status', 'created_at']
    actions = ['bulk_auto_resolve', 'assign_to_me', 'mark_as_resolved']
    
    def bulk_auto_resolve(self, request, queryset):
        """Bulk автоматическое разрешение выбранных конфликтов"""
        resolver = CustomerConflictResolver()
        for conflict in queryset:
            result = resolver.auto_resolve_if_possible(conflict)
            if result.success:
                conflict.status = 'resolved'
                conflict.save()
```

### Dependencies
- **Depends on:** Story 3.2.1 (customer import)
- **Integrates with:** Django Admin, notification system
- **Related:** Data integrity, audit logging

## Story Points
**13** (Highest complexity - multiple algorithms and edge cases)

## Priority
**High** - Критично для качества данных

## Labels
`epic-3` `conflict-resolution` `data-quality` `fuzzy-matching` `admin-tools`
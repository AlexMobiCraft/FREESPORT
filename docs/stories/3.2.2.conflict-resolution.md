# Story 3.2.2: conflict-resolution

## Status

Ready for Development

## Story

**As a** системный администратор,
**I want** автоматически разрешать конфликты дублирования клиентов,
**so that** избежать ручной обработки и обеспечить целостность данных.

## Acceptance Criteria

1. Создан `CustomerConflictResolver` со стратегиями разрешения конфликтов.
2. Реализован алгоритм нечеткого поиска (fuzzy search) с приоритетами.
3. Создана очередь конфликтов для ручного разрешения через Django Admin.
4. Настроены уведомления для администраторов о новых конфликтах.
5. Все операции по разрешению конфликтов логируются.
6. Созданы тесты для всех типов конфликтов.

### Детальные задачи

- [ ] **Создать `CustomerConflictResolver` и интегрировать его (AC: 1)**
  - [ ] Расположить класс в `apps/users/services/conflict_resolution.py`.
  - [ ] `CustomerDataProcessor` (из Story 3.2.1) должен вызывать `CustomerConflictResolver` при обработке каждой записи.
  - [ ] Стратегии разрешения:
    - `email_conflict` → merge_by_email
    - `data_mismatch` → latest_wins
    - `role_conflict` → manual_review
    - `duplicate_customer` → merge_customers
  - [ ] Конфигурируемые правила через settings

- [ ] **Реализовать нечеткий поиск (AC: 2)**
  - [ ] Метод `fuzzy_search_customer()`
  - [ ] Алгоритм схожести строк для ФИО (Levenshtein distance)
  - [ ] Нормализация телефонных номеров
  - [ ] Настройка порогов схожести (>85% confidence)
  - [ ] Обработка транслитерации имен

- [ ] **Установить приоритеты поиска (AC: 2)**
  - [ ] Первичный: поиск по `onec_id` (100% точность)
  - [ ] Вторичный: поиск по `email` (уникальный)
  - [ ] Третичный: `phone` + `ФИО` (нечеткое сравнение)
  - [ ] Четвертичный: `tax_id` для юридических лиц
  - [ ] Логирование результатов каждого уровня поиска

- [ ] **Создать очередь конфликтов (AC: 3)**
  - [ ] Реализовать модель `SyncConflict` (в соответствии с `docs/architecture/02-data-models.md`).
  - [ ] Создать Django Admin интерфейс для модерации записей в `SyncConflict`.
  - [ ] Реализовать Workflow: `pending` → `in_review` → `resolved`.
  - [ ] Добавить логику автоматического назначения модераторов.
  - [ ] Реализовать `actions` в админ-панели для массовой обработки конфликтов.

- [ ] **Настроить уведомления (AC: 4)**
  - [ ] Email уведомления для администраторов
  - [ ] Разные типы алертов по критичности
  - [ ] Дайджест уведомлений (ежедневные сводки)
  - [ ] Интеграция с Slack/Teams для критичных конфликтов

- [ ] **Настроить логирование операций (AC: 5)**
  - [ ] Расширить `CustomerSyncLog` для конфликтов
  - [ ] Детальное логирование стратегий разрешения
  - [ ] Сохранение diff данных до/после слияния
  - [ ] Audit trail для возможности отката

- [ ] **Создать comprehensive тесты (AC: 6)**
  - [ ] Unit тесты для каждой стратегии разрешения
  - [ ] Integration тесты с реальными данными
  - [ ] Edge cases: частичные совпадения, false positives
  - [ ] Performance тесты для больших объемов данных

## Definition of Done

- [ ] 90% конфликтов разрешается автоматически
- [ ] Ручная модерация работает через Django Admin
- [ ] Все операции слияния обратимы
- [ ] False positive rate <5%
- [ ] Время обработки 1000 конфликтов <2 минут

## Dev Notes

### Story Context

**Conflict Types:**

- **Email conflicts:** Одинаковые email в разных записях
- **Data mismatches:** Разные данные у одного клиента
- **Role conflicts:** Противоречивые роли B2B vs B2C
- **Duplicate customers:** Полные дубли записей

### CustomerConflictResolver Architecture

```python
class CustomerConflictResolver:
    """Система разрешения конфликтов клиентских данных"""
    
    RESOLUTION_STRATEGIES = {
        'email_conflict': 'merge_by_email',
        'data_mismatch': 'latest_wins',
        'role_conflict': 'manual_review',
        'duplicate_customer': 'merge_customers',
    }
    
    def resolve_customer_conflict(self, platform_customer, onec_customer):
        """Основной метод разрешения конфликтов"""
        conflicts = self.detect_conflicts(platform_customer, onec_customer)
        
        for conflict_type, conflict_data in conflicts.items():
            strategy = self.RESOLUTION_STRATEGIES.get(conflict_type)
            result = self.apply_resolution_strategy(strategy, conflict_data)
            self.log_resolution_result(conflict_type, result)
        
        return result

    def fuzzy_search_customer(self, identifiers):
        """Нечеткий поиск клиента по частичным данным"""
        candidates = []
        
        # Поиск по нормализованному телефону
        if phone := identifiers.get('phone'):
            normalized_phone = self.normalize_phone(phone)
            candidates.extend(self.find_by_phone(normalized_phone))
        
        # Поиск по схожим именам
        if full_name := identifiers.get('full_name'):
            candidates.extend(self.find_by_similar_name(full_name))
        
        # Ранжирование по confidence score
        return self.rank_candidates_by_confidence(candidates, identifiers)
```

### Conflict Queue Model

```python
class CustomerConflictQueue(models.Model):
    """Очередь конфликтов для ручного разрешения"""
    
    CONFLICT_TYPES = [
        ('email_duplicate', 'Дублирование email'),
        ('role_mismatch', 'Несоответствие ролей'),
        ('data_inconsistency', 'Противоречивые данные'),
        ('merge_required', 'Требуется слияние'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Ожидает модерации'),
        ('in_review', 'На рассмотрении'),
        ('resolved', 'Разрешен'),
        ('escalated', 'Эскалирован'),
    ]
    
    conflict_type = models.CharField(max_length=30, choices=CONFLICT_TYPES)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    platform_customer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='platform_conflicts')
    onec_customer_data = models.JSONField('Данные клиента из 1С')
    conflict_details = models.JSONField('Детали конфликта')
    resolution_notes = models.TextField('Заметки по разрешению', blank=True)
    assigned_moderator = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='assigned_conflicts')
    created_at = models.DateTimeField(auto_now_add=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
```

### Fuzzy Matching Algorithm

```python
def calculate_name_similarity(self, name1, name2):
    """Вычисление схожести имен с учетом транслитерации"""
    from difflib import SequenceMatcher
    
    # Нормализация: убираем пробелы, приводим к нижнему регистру
    name1_norm = self.normalize_name(name1)
    name2_norm = self.normalize_name(name2)
    
    # Базовое сравнение
    similarity = SequenceMatcher(None, name1_norm, name2_norm).ratio()
    
    # Проверка транслитерации
    name1_translit = self.transliterate(name1_norm)
    similarity_translit = SequenceMatcher(None, name1_translit, name2_norm).ratio()
    
    # Возвращаем максимальную схожесть
    return max(similarity, similarity_translit)
```

### Admin Interface

```python
@admin.register(CustomerConflictQueue)
class CustomerConflictQueueAdmin(admin.ModelAdmin):
    list_display = ['conflict_type', 'status', 'platform_customer', 'assigned_moderator', 'created_at']
    list_filter = ['conflict_type', 'status', 'created_at']
    actions = ['bulk_auto_resolve', 'assign_to_me', 'mark_as_resolved']
    
    def bulk_auto_resolve(self, request, queryset):
        """Bulk автоматическое разрешение выбранных конфликтов"""
        resolver = CustomerConflictResolver()
        for conflict in queryset:
            result = resolver.auto_resolve_if_possible(conflict)
            if result.success:
                conflict.status = 'resolved'
                conflict.save()
```

### Dependencies

- **Depends on:** Story 3.2.1 (customer import)
- **Integrates with:** Django Admin, notification system
- **Related:** Data integrity, audit logging

## Story Points

**13** (Highest complexity - multiple algorithms and edge cases)

## Priority

**High** - Критично для качества данных

## Labels

`epic-3` `conflict-resolution` `data-quality` `fuzzy-matching` `admin-tools`

# Story 2.9: filtering-api

## Status
Ready for Review

## Story
**As a** покупатель,
**I want** фильтровать товары по цене и размеру,
**so that** найти товары, соответствующие моим требованиям.

## Acceptance Criteria

1. Фильтр по цене: min_price, max_price параметры
2. Фильтр по размеру из specifications JSON field
3. Фильтр по наличию: in_stock=true/false
4. Фильтр по бренду: brand=slug
5. Комбинирование нескольких фильтров одновременно

- [x] Реализовать фильтрацию по цене (AC: 1)
  - [x] Добавить min_price filter в ProductFilter
  - [x] Добавить max_price filter в ProductFilter
  - [x] Учитывать ролевые цены при фильтрации
  - [x] Валидировать корректность price range
  - [x] Обработать edge cases (min > max)

- [x] Фильтрация по размерам (AC: 2)
  - [x] Создать custom filter для JSON specifications
  - [x] Поддержать поиск по размерам в JSON field
  - [x] Добавить size parameter в API
  - [x] Использовать PostgreSQL JSON operators
  - [x] Обработать различные форматы размеров

- [x] Фильтр по наличию (AC: 3)
  - [x] Добавить in_stock boolean filter
  - [x] Фильтровать по stock_quantity > 0
  - [x] Учитывать is_active flag товара
  - [x] Добавить логику для предзаказов
  - [x] Валидировать boolean parameter

- [x] Фильтрация по бренду (AC: 4)
  - [x] Добавить brand filter по slug
  - [x] Настроить lookup через brand__slug
  - [x] Валидировать существование бренда
  - [x] Поддержать multiple brands (brand=nike,adidas)
  - [x] Обработать case-insensitive search

- [x] Комбинирование фильтров (AC: 5)
  - [x] Протестировать все комбинации фильтров
  - [x] Оптимизировать SQL запросы с multiple WHERE
  - [x] Добавить индексы для часто используемых комбинаций
  - [x] Валидировать совместимость параметров
  - [x] Обработать empty results gracefully

## Dev Notes

### Story Context
**Existing System Integration:**
- Интегрируется с: Products API, Product model specifications
- Технология: django-filter с custom filter classes
- Следует паттерну: DRF filter backends
- Точки касания: Product ViewSet, query optimization

### Technical Notes
- **Integration Approach:** django-filter FilterSet с custom методами для JSON поля
- **Existing Pattern Reference:** DRF filter backends с чистыми query parameters
- **Key Constraints:** JSON field поиск должен использовать PostgreSQL индексы

### Custom JSON Filter Implementation
```python
import django_filters
from django.contrib.postgres.fields import JSONField
from django.db.models import Q

class JSONFieldFilter(django_filters.CharFilter):
    """
    Custom filter для поиска в JSON specifications field
    """
    def filter(self, qs, value):
        if not value:
            return qs
        
        # Поиск размера в различных вариантах JSON структуры
        size_queries = Q()
        
        # Вариант 1: {"size": "XL"}
        size_queries |= Q(specifications__size=value)
        
        # Вариант 2: {"sizes": ["M", "L", "XL"]}
        size_queries |= Q(specifications__sizes__contains=[value])
        
        # Вариант 3: {"размер": "XL"} (русский ключ)
        size_queries |= Q(specifications__размер=value)
        
        return qs.filter(size_queries)

class RolePriceFilter(django_filters.RangeFilter):
    """
    Custom filter для фильтрации по цене с учетом роли пользователя
    """
    def filter(self, qs, value):
        if not value:
            return qs
        
        user = self.parent.request.user if self.parent.request.user.is_authenticated else None
        price_field = self.get_price_field_for_user(user)
        
        if value.start is not None:
            qs = qs.filter(**{f'{price_field}__gte': value.start})
        if value.stop is not None:
            qs = qs.filter(**{f'{price_field}__lte': value.stop})
        
        return qs
    
    def get_price_field_for_user(self, user):
        if not user:
            return 'retail_price'
        
        role_to_field = {
            'retail': 'retail_price',
            'wholesale_level1': 'opt1_price',
            'wholesale_level2': 'opt2_price',
            'wholesale_level3': 'opt3_price',
            'trainer': 'trainer_price',
            'federation_rep': 'federation_price',
        }
        return role_to_field.get(user.role, 'retail_price')
```

### Enhanced ProductFilter
```python
class ProductFilter(django_filters.FilterSet):
    # Existing filters
    search = ProductSearchFilter()
    category_id = django_filters.NumberFilter()
    
    # New filters for this story
    min_price = django_filters.NumberFilter(method='filter_by_price_range')
    max_price = django_filters.NumberFilter(method='filter_by_price_range')
    size = JSONFieldFilter(field_name='specifications')
    in_stock = django_filters.BooleanFilter(method='filter_by_stock')
    brand = django_filters.CharFilter(field_name='brand__slug', lookup_expr='iexact')
    
    class Meta:
        model = Product
        fields = ['search', 'category_id', 'min_price', 'max_price', 'size', 'in_stock', 'brand']
    
    def filter_by_price_range(self, queryset, name, value):
        user = self.request.user if self.request.user.is_authenticated else None
        price_field = self.get_price_field_for_user(user)
        
        if name == 'min_price':
            return queryset.filter(**{f'{price_field}__gte': value})
        elif name == 'max_price':
            return queryset.filter(**{f'{price_field}__lte': value})
        
        return queryset
    
    def filter_by_stock(self, queryset, name, value):
        if value:
            return queryset.filter(stock_quantity__gt=0, is_available=True)
        else:
            return queryset.filter(Q(stock_quantity=0) | Q(is_available=False))
```

### Database Indexes for Performance
```sql
-- Индекс для фильтрации по цене и наличию
CREATE INDEX products_price_stock_idx ON products(retail_price, stock_quantity) 
WHERE is_available = true;

-- GIN индекс для JSON specifications
CREATE INDEX products_specifications_gin_idx ON products 
USING GIN(specifications);

-- Составной индекс для brand + price фильтрации
CREATE INDEX products_brand_price_idx ON products(brand_id, retail_price);
```

### Testing
- Unit тесты для каждого типа фильтра
- Тестирование JSON field поиска
- Проверка ролевого ценообразования в фильтрах
- Performance тесты для комбинированных фильтров
- Валидация edge cases и empty results

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial brownfield story creation | BMad Orchestrator |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
- Проверена реализация фильтрации API согласно AC
- Запущены и пройдены все интеграционные тесты (18/18)
- Запущены и пройдены все unit-тесты (21/21)
- Проверена валидация edge cases и обработка ошибок

### Completion Notes List
✅ **Все критерии приемки выполнены:**
1. Фильтр по цене с учетом ролевых цен (min_price, max_price)
2. Фильтр по размеру из JSON specifications с поддержкой различных форматов
3. Фильтр по наличию (in_stock) с учетом stock_quantity и is_active
4. Фильтр по бренду (brand) с поддержкой множественного выбора и case-insensitive
5. Комбинирование всех фильтров с оптимизированными SQL запросами

✅ **Качество кода:**
- Все тесты проходят: интеграционные (18/18) и unit-тесты (21/21)
- Покрытие тестами критически важных функций фильтрации
- Валидация входных данных и обработка edge cases
- PostgreSQL оптимизации (JSON операторы, индексы)

### File List
- **backend/apps/products/filters.py** - Основная реализация фильтров ProductFilter
- **backend/apps/products/views.py** - ProductViewSet с подключением фильтров
- **backend/tests/unit/test_product_filters.py** - Unit-тесты фильтров (21 тест)
- **backend/tests/integration/test_product_filtering_api.py** - Интеграционные API тесты (18 тестов)

## QA Results

### Review Date: 2025-01-02

### Reviewed By: Quinn (Test Architect)

### Analysis Summary
Story 2.9 успешно реализует все пять критериев приемки с высоким качеством:

✅ **Функциональная полнота:**
- Фильтрация по цене с учетом ролевых цен (min_price, max_price)
- JSON-поиск по размерам с поддержкой различных форматов
- Фильтрация по наличию товаров с валидацией stock_quantity
- Фильтрация по бренду с case-insensitive поиском
- Комбинирование всех фильтров с оптимизированными SQL запросами

✅ **Качество реализации:**
- Комплексное тестирование: 18 интеграционных + 21 unit-тест (100% успешность)
- PostgreSQL оптимизации (GIN индексы для JSON, составные индексы)
- Корректная обработка edge cases и валидация входных данных
- Следование архитектурным паттернам DRF и django-filter

✅ **Производительность:**
- Индексы для часто используемых комбинаций фильтров
- Эффективные PostgreSQL JSON операторы
- Оптимизированные SQL запросы для комбинированной фильтрации

### Gate Status

Gate: PASS → docs/qa/gates/2.9-filtering-api.yml
# Story 2.9: filtering-api

## Status
Ready for Development

## Story
**As a** покупатель,
**I want** фильтровать товары по цене и размеру,
**so that** найти товары, соответствующие моим требованиям.

## Acceptance Criteria

1. Фильтр по цене: min_price, max_price параметры
2. Фильтр по размеру из specifications JSON field
3. Фильтр по наличию: in_stock=true/false
4. Фильтр по бренду: brand=slug
5. Комбинирование нескольких фильтров одновременно

- [ ] Реализовать фильтрацию по цене (AC: 1)
  - [ ] Добавить min_price filter в ProductFilter
  - [ ] Добавить max_price filter в ProductFilter
  - [ ] Учитывать ролевые цены при фильтрации
  - [ ] Валидировать корректность price range
  - [ ] Обработать edge cases (min > max)

- [ ] Фильтрация по размерам (AC: 2)
  - [ ] Создать custom filter для JSON specifications
  - [ ] Поддержать поиск по размерам в JSON field
  - [ ] Добавить size parameter в API
  - [ ] Использовать PostgreSQL JSON operators
  - [ ] Обработать различные форматы размеров

- [ ] Фильтр по наличию (AC: 3)
  - [ ] Добавить in_stock boolean filter
  - [ ] Фильтровать по stock_quantity > 0
  - [ ] Учитывать is_available flag товара
  - [ ] Добавить логику для предзаказов
  - [ ] Валидировать boolean parameter

- [ ] Фильтрация по бренду (AC: 4)
  - [ ] Добавить brand filter по slug
  - [ ] Настроить lookup через brand__slug
  - [ ] Валидировать существование бренда
  - [ ] Поддержать multiple brands (brand=nike,adidas)
  - [ ] Обработать case-insensitive search

- [ ] Комбинирование фильтров (AC: 5)
  - [ ] Протестировать все комбинации фильтров
  - [ ] Оптимизировать SQL запросы с multiple WHERE
  - [ ] Добавить индексы для часто используемых комбинаций
  - [ ] Валидировать совместимость параметров
  - [ ] Обработать empty results gracefully

## Dev Notes

### Story Context
**Existing System Integration:**
- Интегрируется с: Products API, Product model specifications
- Технология: django-filter с custom filter classes
- Следует паттерну: DRF filter backends
- Точки касания: Product ViewSet, query optimization

### Technical Notes
- **Integration Approach:** django-filter FilterSet с custom методами для JSON поля
- **Existing Pattern Reference:** DRF filter backends с чистыми query parameters
- **Key Constraints:** JSON field поиск должен использовать PostgreSQL индексы

### Custom JSON Filter Implementation
```python
import django_filters
from django.contrib.postgres.fields import JSONField
from django.db.models import Q

class JSONFieldFilter(django_filters.CharFilter):
    """
    Custom filter для поиска в JSON specifications field
    """
    def filter(self, qs, value):
        if not value:
            return qs
        
        # Поиск размера в различных вариантах JSON структуры
        size_queries = Q()
        
        # Вариант 1: {"size": "XL"}
        size_queries |= Q(specifications__size=value)
        
        # Вариант 2: {"sizes": ["M", "L", "XL"]}
        size_queries |= Q(specifications__sizes__contains=[value])
        
        # Вариант 3: {"размер": "XL"} (русский ключ)
        size_queries |= Q(specifications__размер=value)
        
        return qs.filter(size_queries)

class RolePriceFilter(django_filters.RangeFilter):
    """
    Custom filter для фильтрации по цене с учетом роли пользователя
    """
    def filter(self, qs, value):
        if not value:
            return qs
        
        user = self.parent.request.user if self.parent.request.user.is_authenticated else None
        price_field = self.get_price_field_for_user(user)
        
        if value.start is not None:
            qs = qs.filter(**{f'{price_field}__gte': value.start})
        if value.stop is not None:
            qs = qs.filter(**{f'{price_field}__lte': value.stop})
        
        return qs
    
    def get_price_field_for_user(self, user):
        if not user:
            return 'retail_price'
        
        role_to_field = {
            'retail': 'retail_price',
            'wholesale_level1': 'opt1_price',
            'wholesale_level2': 'opt2_price',
            'wholesale_level3': 'opt3_price',
            'trainer': 'trainer_price',
            'federation_rep': 'federation_price',
        }
        return role_to_field.get(user.role, 'retail_price')
```

### Enhanced ProductFilter
```python
class ProductFilter(django_filters.FilterSet):
    # Existing filters
    search = ProductSearchFilter()
    category_id = django_filters.NumberFilter()
    
    # New filters for this story
    min_price = django_filters.NumberFilter(method='filter_by_price_range')
    max_price = django_filters.NumberFilter(method='filter_by_price_range')
    size = JSONFieldFilter(field_name='specifications')
    in_stock = django_filters.BooleanFilter(method='filter_by_stock')
    brand = django_filters.CharFilter(field_name='brand__slug', lookup_expr='iexact')
    
    class Meta:
        model = Product
        fields = ['search', 'category_id', 'min_price', 'max_price', 'size', 'in_stock', 'brand']
    
    def filter_by_price_range(self, queryset, name, value):
        user = self.request.user if self.request.user.is_authenticated else None
        price_field = self.get_price_field_for_user(user)
        
        if name == 'min_price':
            return queryset.filter(**{f'{price_field}__gte': value})
        elif name == 'max_price':
            return queryset.filter(**{f'{price_field}__lte': value})
        
        return queryset
    
    def filter_by_stock(self, queryset, name, value):
        if value:
            return queryset.filter(stock_quantity__gt=0, is_available=True)
        else:
            return queryset.filter(Q(stock_quantity=0) | Q(is_available=False))
```

### Database Indexes for Performance
```sql
-- Индекс для фильтрации по цене и наличию
CREATE INDEX products_price_stock_idx ON products(retail_price, stock_quantity) 
WHERE is_available = true;

-- GIN индекс для JSON specifications
CREATE INDEX products_specifications_gin_idx ON products 
USING GIN(specifications);

-- Составной индекс для brand + price фильтрации
CREATE INDEX products_brand_price_idx ON products(brand_id, retail_price);
```

### Testing
- Unit тесты для каждого типа фильтра
- Тестирование JSON field поиска
- Проверка ролевого ценообразования в фильтрах
- Performance тесты для комбинированных фильтров
- Валидация edge cases и empty results

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial brownfield story creation | BMad Orchestrator |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
_TBD - будет заполнено dev агентом_

### Completion Notes List
_TBD - будет заполнено dev агентом_

### File List
_TBD - будет заполнено dev агентом_

## QA Results
_TBD - будет заполнено QA агентом_
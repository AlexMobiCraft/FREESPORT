# Story 2.10: pages-api

## Status
Ready for Review

## Story
**As a** пользователь сайта,
**I want** получать содержимое статических страниц через API,
**so that** читать информацию о компании и условиях.

## Acceptance Criteria

1. GET `/pages/` возвращает список опубликованных страниц
2. GET `/pages/{slug}/` отдает содержимое страницы
3. Поддержка HTML контента в content field
4. SEO метаданные включены в response
5. Кэширование статических страниц

- [x] Создать Page model (AC: 1, 2)
  - [x] Создать Page model с полями: title, slug, content, is_published
  - [x] Добавить SEO поля: seo_title, seo_description
  - [x] Настроить SlugField с unique constraint
  - [x] Добавить timestamps: created_at, updated_at
  - [x] Создать миграцию для Page model

- [x] Реализовать Pages API (AC: 1, 2)
  - [x] Создать PageSerializer с основными полями
  - [x] Реализовать PageViewSet как ReadOnlyModelViewSet
  - [x] Настроить GET /pages/ для списка страниц
  - [x] Реализовать GET /pages/{slug}/ для детали
  - [x] Фильтровать только опубликованные страницы

- [x] Поддержка HTML контента (AC: 3)
  - [x] Использовать TextField для content
  - [x] Добавить валидацию безопасности HTML
  - [x] Настроить HTML sanitization при сохранении
  - [x] Поддержать базовые HTML теги: p, h1-h6, ul, ol, li, a
  - [x] Обработать encoding и special characters

- [x] SEO метаданные (AC: 4)
  - [x] Включить seo_title в serializer
  - [x] Добавить seo_description в response
  - [x] Автогенерация SEO полей из title/content если пусто
  - [x] Валидировать длину SEO полей
  - [x] Поддержать Open Graph метаданные

- [x] Кэширование страниц (AC: 5)
  - [x] Настроить cache для статических страниц
  - [x] Использовать Redis/Memcached для кэша
  - [x] Кэшировать на 24 часа для статики
  - [x] Автоматическая инвалидация при обновлении
  - [x] Cache headers для browser caching

## Dev Notes

### Story Context
**Existing System Integration:**
- Интегрируется с: Django CMS функционал
- Технология: Page model с DRF ReadOnlyViewSet
- Следует паттерну: Django slug-based URL routing
- Точки касания: Static content delivery, SEO metadata

### Technical Notes
- **Integration Approach:** Simple Page model с ReadOnlyViewSet
- **Existing Pattern Reference:** Django slug field с автогенерацией
- **Key Constraints:** HTML content должен быть безопасным

### Page Model Structure
```python
from django.db import models
from django.utils.text import slugify
from django.core.validators import RegexValidator
import bleach

class Page(models.Model):
    title = models.CharField(max_length=200, verbose_name="Заголовок")
    slug = models.SlugField(unique=True, max_length=200, verbose_name="URL slug")
    content = models.TextField(verbose_name="Содержимое")
    
    # SEO fields
    seo_title = models.CharField(max_length=60, blank=True, verbose_name="SEO заголовок")
    seo_description = models.TextField(max_length=160, blank=True, verbose_name="SEO описание")
    
    # Publication
    is_published = models.BooleanField(default=False, verbose_name="Опубликовано")
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = "Страница"
        verbose_name_plural = "Страницы"
        ordering = ['title']
    
    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        # Автогенерация slug если не задан
        if not self.slug:
            self.slug = slugify(self.title)
        
        # Автогенерация SEO полей
        if not self.seo_title:
            self.seo_title = self.title[:60]
        
        if not self.seo_description:
            # Извлекаем первые 160 символов из content без HTML
            clean_content = bleach.clean(self.content, tags=[], strip=True)
            self.seo_description = clean_content[:160]
        
        # HTML sanitization
        allowed_tags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'a', 'strong', 'em', 'br']
        allowed_attributes = {'a': ['href', 'title']}
        self.content = bleach.clean(self.content, tags=allowed_tags, attributes=allowed_attributes)
        
        super().save(*args, **kwargs)
```

### Page API Implementation
```python
from rest_framework import viewsets, serializers
from django.core.cache import cache
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

class PageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Page
        fields = ['id', 'title', 'slug', 'content', 'seo_title', 'seo_description', 'updated_at']

class PageViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = PageSerializer
    lookup_field = 'slug'
    
    def get_queryset(self):
        return Page.objects.filter(is_published=True)
    
    @method_decorator(cache_page(60 * 60 * 24))  # Cache for 24 hours
    def retrieve(self, request, *args, **kwargs):
        return super().retrieve(request, *args, **kwargs)
    
    def list(self, request, *args, **kwargs):
        # Cache list of pages
        cache_key = 'pages_list'
        cached_result = cache.get(cache_key)
        
        if cached_result is None:
            result = super().list(request, *args, **kwargs)
            cache.set(cache_key, result.data, 60 * 60 * 24)  # 24 hours
            return result
        
        return Response(cached_result)
```

### URL Configuration
```python
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PageViewSet

router = DefaultRouter()
router.register(r'pages', PageViewSet, basename='pages')

urlpatterns = [
    path('api/v1/', include(router.urls)),
]
```

### Cache Invalidation Signal
```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache

@receiver([post_save, post_delete], sender=Page)
def invalidate_page_cache(sender, instance, **kwargs):
    # Инвалидация кэша при изменении страницы
    cache.delete('pages_list')
    cache.delete(f'page_detail_{instance.slug}')
```

### Admin Interface
```python
from django.contrib import admin

@admin.register(Page)
class PageAdmin(admin.ModelAdmin):
    list_display = ['title', 'slug', 'is_published', 'updated_at']
    list_filter = ['is_published', 'created_at']
    search_fields = ['title', 'content']
    prepopulated_fields = {'slug': ('title',)}
    
    fieldsets = (
        ('Основное', {
            'fields': ('title', 'slug', 'content', 'is_published')
        }),
        ('SEO', {
            'fields': ('seo_title', 'seo_description'),
            'classes': ('collapse',)
        }),
    )
```

### Testing
- Unit тесты для Page model и API
- Тестирование HTML sanitization
- Проверка кэширования и инвалидации
- Валидация SEO полей
- Тестирование slug generation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-05 | 1.1 | QA fixes applied: SEC-001, TEST-001, PERF-001 resolved. All 35 tests passing. Enhanced security, comprehensive test coverage, performance validation. | James (Dev Agent) |
| 2025-08-16 | 1.0 | Initial brownfield story creation | BMad Orchestrator |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
**QA Fixes Applied (2025-09-05):**
- Unit tests: `python manage.py test apps.pages.tests` → 10/10 ✅
- Integration tests: `python manage.py test tests.integration.test_pages_api` → 18/18 ✅  
- Performance tests: `python manage.py test tests.integration.test_pages_performance` → 7/7 ✅
- **Total: 35/35 tests passing** ✅

### Completion Notes List
**Story 2.10 Completion (2025-09-05):**

✅ **ALL TASKS COMPLETED SUCCESSFULLY**
- All acceptance criteria checkboxes marked as completed [x]
- Story status confirmed as "Ready for Review"
- Full regression testing passed: 35/35 tests ✅
- QA gate passed with all security, performance, and testing requirements met

**QA Issues Resolved (2025-09-05):**

1. **SEC-001 (MEDIUM)** - HTML Sanitization Security → **FIXED** ✅
   - Added comprehensive security tests (6 test methods) covering XSS protection
   - Enhanced HTML sanitization with `bleach.clean(strip=True)` configuration
   - Tests validate script removal, dangerous attributes blocking, iframe/embed prevention
   - CSS injection and data URI attacks properly mitigated

2. **TEST-001 (MEDIUM)** - Integration Test Coverage → **FIXED** ✅
   - Expanded integration test suite from basic to comprehensive coverage
   - Added 4 new test classes: Caching, EdgeCases, Performance benchmarks
   - Enhanced API response structure validation for paginated results
   - Added Unicode content, special characters, and large dataset handling

3. **PERF-001 (LOW)** - Cache Performance Under Load → **FIXED** ✅
   - Created dedicated performance test suite (`test_pages_performance.py`)
   - Added concurrent access testing with threading (20 parallel requests)
   - Implemented cache invalidation accuracy tests under load
   - Added stress tests for large datasets (200+ pages) with response time validation

4. **Additional Technical Improvements:**
   - Fixed Cyrillic slug generation using `transliterate` library
   - Updated dependencies: added `transliterate==1.10.2`
   - Enhanced model's HTML sanitization configuration
   - Improved test reliability with proper paginated API response handling

### File List
**Modified Files:**
- `backend/apps/pages/models.py` - Enhanced HTML sanitization and Cyrillic slug generation
- `backend/apps/pages/tests.py` - Added comprehensive security tests (10 test methods)
- `backend/tests/integration/test_pages_api.py` - Enhanced integration tests (18 test methods)
- `backend/requirements.txt` - Added transliterate dependency

**New Files:**
- `backend/tests/integration/test_pages_performance.py` - Performance and load tests (7 test methods)

## QA Results

### Review Date: 2025-09-05

### Reviewed By: Quinn (Test Architect)

**Quality Assessment:**
- ✅ Acceptance criteria четко определены и покрывают все требования
- ✅ Техническое решение следует Django best practices  
- ✅ Модель Page имеет proper validation и SEO автогенерацию
- ✅ API реализован через ReadOnlyViewSet с правильным кэшированием
- ⚠️ HTML sanitization требует дополнительной security validation
- ⚠️ Интеграционные тесты должны покрывать полный workflow
- ⚠️ Cache invalidation strategy нуждается в performance тестировании

**Risk Assessment:**
- Security: MEDIUM (HTML sanitization)
- Performance: LOW (cache strategy optimization) 
- Testing: MEDIUM (integration test coverage)

**Recommendations:**
1. Добавить security тесты для HTML content validation
2. Создать comprehensive integration тесты для API endpoints
3. Провести performance тестирование cache invalidation под нагрузкой

### Gate Status

Gate: PASS → docs/qa/gates/2.10-pages-api.yml

**Update: 2025-09-05 17:45**
- SEC-001 (HTML sanitization security) → **RESOLVED** ✅
- TEST-001 (Integration test coverage) → **RESOLVED** ✅  
- PERF-001 (Cache performance under load) → **RESOLVED** ✅
- All 35 tests passing, story ready for production deployment
# Story 2.10: pages-api

## Status
Ready for Development

## Story
**As a** пользователь сайта,
**I want** получать содержимое статических страниц через API,
**so that** читать информацию о компании и условиях.

## Acceptance Criteria

1. GET `/pages/` возвращает список опубликованных страниц
2. GET `/pages/{slug}/` отдает содержимое страницы
3. Поддержка HTML контента в content field
4. SEO метаданные включены в response
5. Кэширование статических страниц

- [ ] Создать Page model (AC: 1, 2)
  - [ ] Создать Page model с полями: title, slug, content, is_published
  - [ ] Добавить SEO поля: seo_title, seo_description
  - [ ] Настроить SlugField с unique constraint
  - [ ] Добавить timestamps: created_at, updated_at
  - [ ] Создать миграцию для Page model

- [ ] Реализовать Pages API (AC: 1, 2)
  - [ ] Создать PageSerializer с основными полями
  - [ ] Реализовать PageViewSet как ReadOnlyModelViewSet
  - [ ] Настроить GET /pages/ для списка страниц
  - [ ] Реализовать GET /pages/{slug}/ для детали
  - [ ] Фильтровать только опубликованные страницы

- [ ] Поддержка HTML контента (AC: 3)
  - [ ] Использовать TextField для content
  - [ ] Добавить валидацию безопасности HTML
  - [ ] Настроить HTML sanitization при сохранении
  - [ ] Поддержать базовые HTML теги: p, h1-h6, ul, ol, li, a
  - [ ] Обработать encoding и special characters

- [ ] SEO метаданные (AC: 4)
  - [ ] Включить seo_title в serializer
  - [ ] Добавить seo_description в response
  - [ ] Автогенерация SEO полей из title/content если пусто
  - [ ] Валидировать длину SEO полей
  - [ ] Поддержать Open Graph метаданные

- [ ] Кэширование страниц (AC: 5)
  - [ ] Настроить cache для статических страниц
  - [ ] Использовать Redis/Memcached для кэша
  - [ ] Кэшировать на 24 часа для статики
  - [ ] Автоматическая инвалидация при обновлении
  - [ ] Cache headers для browser caching

## Dev Notes

### Story Context
**Existing System Integration:**
- Интегрируется с: Django CMS функционал
- Технология: Page model с DRF ReadOnlyViewSet
- Следует паттерну: Django slug-based URL routing
- Точки касания: Static content delivery, SEO metadata

### Technical Notes
- **Integration Approach:** Simple Page model с ReadOnlyViewSet
- **Existing Pattern Reference:** Django slug field с автогенерацией
- **Key Constraints:** HTML content должен быть безопасным

### Page Model Structure
```python
from django.db import models
from django.utils.text import slugify
from django.core.validators import RegexValidator
import bleach

class Page(models.Model):
    title = models.CharField(max_length=200, verbose_name="Заголовок")
    slug = models.SlugField(unique=True, max_length=200, verbose_name="URL slug")
    content = models.TextField(verbose_name="Содержимое")
    
    # SEO fields
    seo_title = models.CharField(max_length=60, blank=True, verbose_name="SEO заголовок")
    seo_description = models.TextField(max_length=160, blank=True, verbose_name="SEO описание")
    
    # Publication
    is_published = models.BooleanField(default=False, verbose_name="Опубликовано")
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = "Страница"
        verbose_name_plural = "Страницы"
        ordering = ['title']
    
    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        # Автогенерация slug если не задан
        if not self.slug:
            self.slug = slugify(self.title)
        
        # Автогенерация SEO полей
        if not self.seo_title:
            self.seo_title = self.title[:60]
        
        if not self.seo_description:
            # Извлекаем первые 160 символов из content без HTML
            clean_content = bleach.clean(self.content, tags=[], strip=True)
            self.seo_description = clean_content[:160]
        
        # HTML sanitization
        allowed_tags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'a', 'strong', 'em', 'br']
        allowed_attributes = {'a': ['href', 'title']}
        self.content = bleach.clean(self.content, tags=allowed_tags, attributes=allowed_attributes)
        
        super().save(*args, **kwargs)
```

### Page API Implementation
```python
from rest_framework import viewsets, serializers
from django.core.cache import cache
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

class PageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Page
        fields = ['id', 'title', 'slug', 'content', 'seo_title', 'seo_description', 'updated_at']

class PageViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = PageSerializer
    lookup_field = 'slug'
    
    def get_queryset(self):
        return Page.objects.filter(is_published=True)
    
    @method_decorator(cache_page(60 * 60 * 24))  # Cache for 24 hours
    def retrieve(self, request, *args, **kwargs):
        return super().retrieve(request, *args, **kwargs)
    
    def list(self, request, *args, **kwargs):
        # Cache list of pages
        cache_key = 'pages_list'
        cached_result = cache.get(cache_key)
        
        if cached_result is None:
            result = super().list(request, *args, **kwargs)
            cache.set(cache_key, result.data, 60 * 60 * 24)  # 24 hours
            return result
        
        return Response(cached_result)
```

### URL Configuration
```python
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PageViewSet

router = DefaultRouter()
router.register(r'pages', PageViewSet, basename='pages')

urlpatterns = [
    path('api/v1/', include(router.urls)),
]
```

### Cache Invalidation Signal
```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache

@receiver([post_save, post_delete], sender=Page)
def invalidate_page_cache(sender, instance, **kwargs):
    # Инвалидация кэша при изменении страницы
    cache.delete('pages_list')
    cache.delete(f'page_detail_{instance.slug}')
```

### Admin Interface
```python
from django.contrib import admin

@admin.register(Page)
class PageAdmin(admin.ModelAdmin):
    list_display = ['title', 'slug', 'is_published', 'updated_at']
    list_filter = ['is_published', 'created_at']
    search_fields = ['title', 'content']
    prepopulated_fields = {'slug': ('title',)}
    
    fieldsets = (
        ('Основное', {
            'fields': ('title', 'slug', 'content', 'is_published')
        }),
        ('SEO', {
            'fields': ('seo_title', 'seo_description'),
            'classes': ('collapse',)
        }),
    )
```

### Testing
- Unit тесты для Page model и API
- Тестирование HTML sanitization
- Проверка кэширования и инвалидации
- Валидация SEO полей
- Тестирование slug generation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial brownfield story creation | BMad Orchestrator |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
_TBD - будет заполнено dev агентом_

### Completion Notes List
_TBD - будет заполнено dev агентом_

### File List
_TBD - будет заполнено dev агентом_

## QA Results
_TBD - будет заполнено QA агентом_
# История 3.2.4: Продвинутое управление логами синхронизации

## Status

Ready for Development

## Story

**As a** системный администратор,
**I want** иметь продвинутые инструменты для анализа, мониторинга и управления логами синхронизации,
**so that** я могу эффективно поддерживать систему, быстро находить проблемы и готовить отчеты.

## Acceptance Criteria

1. Настроен расширенный интерфейс в Django Admin для просмотра и фильтрации логов `CustomerSyncLog`.
2. Реализована система генерации и рассылки отчетов по синхронизации.
3. Настроена автоматическая ротация и архивирование старых логов.
4. Добавлены метрики и интеграция с внешними системами мониторинга (Prometheus/Grafana, ELK).

### Детальные задачи

- [ ] **Настроить Django Admin для `CustomerSyncLog` (AC: 1)**
  - [ ] Создать `ModelAdmin` для `CustomerSyncLog`.
  - [ ] Добавить фильтры: `operation_type`, `status`, `created_at` (date range).
  - [ ] Настроить поиск по `customer_email`, `onec_id`, `correlation_id`.
  - [ ] Реализовать `action` для экспорта выбранных логов в CSV.

- [ ] **Создать систему отчетности (AC: 2)**
  - [ ] Создать management-команду `generate_sync_report`.
  - [ ] Реализовать генерацию отчетов: ежедневная сводка, еженедельный анализ ошибок.
  - [ ] Настроить отправку отчетов по email заданным стейкхолдерам.

- [ ] **Настроить ротацию логов (AC: 3)**
  - [ ] Создать management-команду `cleanup_sync_logs`.
  - [ ] Реализовать логику удаления логов старше 90 дней.
  - [ ] (Out of Scope) Архивация логов в S3 на данном этапе не реализуется.
  - [ ] Добавить cron-задачу для ежедневного запуска команды.

- [ ] **Интегрировать с системами мониторинга (AC: 4)**
  - [ ] Добавить метрики для Prometheus (количество операций, ошибок, длительность).
  - [ ] Обеспечить структурированное логирование (например, в JSON-формате) для будущей интеграции с ELK-стеком (развертывание ELK не входит в эту задачу).
  - [ ] Настроить real-time алерты через webhooks для критических ошибок.

## Definition of Done

- [ ] Все операции синхронизации логируются
- [ ] Логи доступны через Django Admin
- [ ] Генерируются ежедневные отчеты
- [ ] Настроены алерты для критических ошибок
- [ ] Соблюдается retention policy

## Dev Notes

### Story Context

**Место в системе интеграции с 1С:**

Эта история является сквозным компонентом для мониторинга и аудита всех операций синхронизации клиентов между 1С и платформой:

1. **Импорт клиентов (Story 3.2.1)** - логирование импорта существующих клиентов из 1С
2. **Идентификация клиентов (Story 3.3.1)** - логирование детерминированного поиска по ИНН/email
3. **Разрешение конфликтов (Story 3.2.2)** - логирование автоматического разрешения конфликтов (стратегия onec_wins)
4. **Двусторонняя синхронизация (Story 3.2.3)** - логирование экспорта новых регистраций и изменений
5. **Управление логами (эта история)** - централизованная система анализа, мониторинга и отчетности

**Процесс логирования операций:**

- Все операции синхронизации логируются в CustomerSyncLog
- Каждый лог содержит корреляционный ID для отслеживания связанных операций
- Система предоставляет детальную информацию для аудита и отладки
- Автоматические отчеты и алерты для операционной поддержки

**Logging Requirements:**

- **Compliance:** Полный audit trail всех изменений данных клиентов
- **Debugging:** Детальная информация для диагностики проблем
- **Monitoring:** Real-time метрики для операционной поддержки
- **Reporting:** Регулярные отчеты для менеджмента

### Технические требования

**Используемые технологии:**

- **Мониторинг:** Prometheus для сбора метрик, Grafana для визуализации
- **Логирование:** structlog для структурированного логирования в JSON-формате
- **Анализ логов:** Django ORM с оптимизацией запросов для фильтрации логов
- **Отчетность:** Django templates для генерации HTML-отчетов, WeasyPrint для PDF
- **Уведомления:** Django email backend для отправки отчетов
- **Административный интерфейс:** Django Admin с кастомными фильтрами и actions
- **Асинхронные задачи:** Celery для фонового выполнения отчетов и очистки логов

**Переменные окружения:**

- `SYNC_LOG_RETENTION_DAYS`: Количество дней хранения логов (по умолчанию: 90)
- `SYNC_REPORT_EMAILS`: Список email для получения отчетов (через запятую)
- `SYNC_REPORT_SCHEDULE`: Расписание отправки отчетов в cron-формате (по умолчанию: "08***")
- `PROMETHEUS_METRICS_ENABLED`: Включить сбор метрик Prometheus (True/False)
- `SYNC_LOG_LEVEL`: Уровень детализации логов (INFO, DEBUG, WARNING)
- `WEBHOOK_ALERT_URL`: URL для отправки критических алертов
- `SYNC_LOG_BATCH_SIZE`: Размер пакета для обработки логов (по умолчанию: 1000)

### CustomerSyncLog Model

```python
class CustomerSyncLog(models.Model):
    """Детальное логирование всех операций синхронизации клиентов"""
    
    OPERATION_TYPES = [
        ('import_from_1c', 'Импорт из 1С'),
        ('export_to_1c', 'Экспорт в 1С'),
        ('sync_changes', 'Синхронизация изменений'),
        ('customer_identification', 'Идентификация клиента'),
        ('conflict_resolution', 'Разрешение конфликтов'),
        ('data_validation', 'Валидация данных'),
        ('batch_operation', 'Пакетная операция'),
    ]
    
    STATUS_CHOICES = [
        ('success', 'Успешно'),
        ('error', 'Ошибка'),
        ('warning', 'Предупреждение'),
        ('skipped', 'Пропущено'),
        ('pending', 'В процессе'),
    ]
    
    # Основные поля
    operation_type = models.CharField('Тип операции', max_length=30, choices=OPERATION_TYPES)
    status = models.CharField('Статус', max_length=20, choices=STATUS_CHOICES)
    
    # Связь с клиентом (может быть null если клиент не найден)
    customer = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, related_name='sync_logs')
    customer_email = models.EmailField('Email клиента', blank=True)
    onec_id = models.CharField('ID в 1С', max_length=100, blank=True)
    
    # Детальная информация
    details = models.JSONField('Детали операции', default=dict, help_text='Структурированные данные операции')
    error_message = models.TextField('Сообщение об ошибке', blank=True)
    
    # Метаданные
    duration_ms = models.PositiveIntegerField('Длительность (мс)', null=True, blank=True)
    correlation_id = models.CharField('Correlation ID', max_length=50, blank=True, db_index=True)
    
    # Временные метки
    created_at = models.DateTimeField('Дата операции', auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField('Обновлено', auto_now=True)
    
    class Meta:
        verbose_name = 'Лог синхронизации клиентов'
        verbose_name_plural = 'Логи синхронизации клиентов'
        db_table = 'customer_sync_logs'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['operation_type', 'status', 'created_at']),
            models.Index(fields=['customer_email']),
            models.Index(fields=['onec_id']),
        ]
```

### CustomerSyncLogger Service

```python
class CustomerSyncLogger:
    """Специализированное логирование синхронизации клиентов"""
    
    def __init__(self, correlation_id=None):
        self.correlation_id = correlation_id or self.generate_correlation_id()
    
    def log_customer_import(self, customer_data, result):
        """Логирование импорта клиента из 1С"""
        details = {
            'source': '1c_export',
            'import_timestamp': timezone.now().isoformat(),
            '1c_customer_id': customer_data.get('id'),
            'customer_type': customer_data.get('customer_type'),
            'data_fields': list(customer_data.keys()),
        }
        
        if result.success:
            details.update({
                'platform_customer_id': result.customer.id,
                'assigned_role': result.customer.role,
                'created_new': result.created,
            })
        
        CustomerSyncLog.objects.create(
            operation_type='import_from_1c',
            customer=result.customer if result.success else None,
            customer_email=customer_data.get('email'),
            onec_id=customer_data.get('id'),
            status='success' if result.success else 'error',
            details=details,
            error_message=result.error_message if not result.success else '',
            duration_ms=result.duration_ms,
            correlation_id=self.correlation_id
        )
    
    def log_customer_export(self, platform_customer, result):
        """Логирование экспорта клиента в 1С"""
        details = {
            'destination': '1c_api',
            'export_timestamp': timezone.now().isoformat(),
            'platform_customer_id': platform_customer.id,
            'customer_role': platform_customer.role,
            'export_format': result.export_format,
            'exported_fields': result.exported_fields,
        }
        
        if result.success:
            details.update({
                'assigned_1c_id': result.onec_id,
                '1c_response': result.response_data,
            })
        
        CustomerSyncLog.objects.create(
            operation_type='export_to_1c',
            customer=platform_customer,
            customer_email=platform_customer.email,
            onec_id=result.onec_id if result.success else platform_customer.onec_id,
            status='success' if result.success else 'error',
            details=details,
            error_message=result.error_message if not result.success else '',
            duration_ms=result.duration_ms,
            correlation_id=self.correlation_id
        )
    
    def log_customer_identification(self, onec_data, identification_result):
        """Логирование идентификации клиента (Story 3.3.1)"""
        CustomerSyncLog.objects.create(
            operation_type='customer_identification',
            customer=identification_result.get('customer'),
            customer_email=onec_data.get('email'),
            onec_id=onec_data.get('onec_id'),
            status='success' if identification_result.get('found') else 'skipped',
            details={
                'search_method': identification_result.get('method'),  # 'onec_id', 'onec_guid', 'tax_id', 'email'
                'search_value': identification_result.get('search_value'),
                'normalized_value': identification_result.get('normalized_value'),
                'found': identification_result.get('found', False),
                'customer_id': identification_result.get('customer').id if identification_result.get('customer') else None,
            },
            duration_ms=identification_result.get('duration_ms'),
            correlation_id=self.correlation_id
        )
    
    def log_conflict_resolution(self, existing_customer, onec_data, conflict_source, resolution_result):
        """Логирование разрешения конфликтов (стратегия onec_wins)"""
        CustomerSyncLog.objects.create(
            operation_type='conflict_resolution',
            customer=existing_customer,
            customer_email=existing_customer.email,
            onec_id=onec_data.get('onec_id'),
            status='success' if resolution_result.get('success') else 'error',
            details={
                'conflict_source': conflict_source,  # 'portal_registration' или 'data_import'
                'resolution_strategy': 'onec_wins',  # Единственная стратегия
                'conflicting_fields': resolution_result.get('conflicting_fields', []),
                'changes_made': resolution_result.get('changes_made', {}),
                'action': resolution_result.get('action'),  # 'confirmed_client' или 'data_updated'
                'email_sent': resolution_result.get('email_sent', False),
                'sync_conflict_id': resolution_result.get('sync_conflict_id'),  # ID записи в SyncConflict
            },
            error_message=resolution_result.get('error_message', ''),
            duration_ms=resolution_result.get('duration_ms'),
            correlation_id=self.correlation_id
        )
```

### Django Admin Configuration

```python
@admin.register(CustomerSyncLog)
class CustomerSyncLogAdmin(admin.ModelAdmin):
    list_display = ['created_at', 'operation_type', 'status', 'customer_email', 'onec_id', 'duration_ms']
    list_filter = [
        'operation_type',
        'status',
        ('created_at', admin.DateFieldListFilter),
        'customer__role',
    ]
    search_fields = ['customer_email', 'onec_id', 'correlation_id', 'error_message']
    readonly_fields = ['created_at', 'updated_at', 'correlation_id']
    date_hierarchy = 'created_at'
    actions = ['export_to_csv', 'mark_as_reviewed']
    
    fieldsets = (
        ('Основная информация', {
            'fields': ('operation_type', 'status', 'customer', 'customer_email', 'onec_id')
        }),
        ('Детали операции', {
            'fields': ('details', 'error_message', 'duration_ms', 'correlation_id'),
            'classes': ('collapse',)
        }),
        ('Временные метки', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    def export_to_csv(self, request, queryset):
        """Export selected logs to CSV"""
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="sync_logs.csv"'
        
        writer = csv.writer(response)
        writer.writerow(['Date', 'Operation', 'Status', 'Email', '1C ID', 'Duration', 'Error'])
        
        for log in queryset:
            writer.writerow([
                log.created_at.strftime('%Y-%m-%d %H:%M'),
                log.get_operation_type_display(),
                log.get_status_display(),
                log.customer_email,
                log.onec_id,
                log.duration_ms,
                log.error_message
            ])
        
        return response
    export_to_csv.short_description = "Export to CSV"
```

### Reporting System

```python
class SyncReportGenerator:
    """Генератор отчетов по синхронизации"""
    
    def generate_daily_summary(self, date=None):
        """Ежедневный сводный отчет"""
        date = date or timezone.now().date()
        logs = CustomerSyncLog.objects.filter(created_at__date=date)
        
        return {
            'date': date,
            'total_operations': logs.count(),
            'by_type': logs.values('operation_type').annotate(count=models.Count('id')),
            'by_status': logs.values('status').annotate(count=models.Count('id')),
            'avg_duration': logs.aggregate(avg_duration=models.Avg('duration_ms'))['avg_duration'],
            'top_errors': logs.filter(status='error').values('error_message').annotate(count=models.Count('id')).order_by('-count')[:10],
        }
    
    def generate_weekly_error_analysis(self, start_date=None):
        """Еженедельный анализ ошибок"""
        start_date = start_date or (timezone.now().date() - timedelta(days=7))
        end_date = start_date + timedelta(days=7)
        
        error_logs = CustomerSyncLog.objects.filter(
            created_at__date__gte=start_date,
            created_at__date__lt=end_date,
            status='error'
        )
        
        return {
            'period': f"{start_date} - {end_date}",
            'total_errors': error_logs.count(),
            'error_rate': self.calculate_error_rate(start_date, end_date),
            'errors_by_type': error_logs.values('operation_type').annotate(count=models.Count('id')),
            'common_errors': self.analyze_common_errors(error_logs),
            'affected_customers': error_logs.values('customer').distinct().count(),
        }
```

### Dependencies

- **Depends on:** All other 3.2 stories (import, export, conflicts)
- **Integrates with:** Django Admin, monitoring systems, reporting
- **Related:** Compliance requirements, debugging tools

### Информация из предыдущих историй

**Story 3.1.1 (ImportSession model):**

- Модель ImportSession используется для отслеживания сессий импорта/экспорта
- Поля: `import_type`, `status`, `started_at`, `finished_at`, `report_details`, `error_message`
- Типы импорта: `CATALOG`, `STOCKS`, `PRICES`, `CUSTOMERS`
- Статусы: `STARTED`, `COMPLETED`, `FAILED`

**Story 3.2.1 (CustomerDataProcessor):**

- CustomerDataProcessor обрабатывает импорт клиентов из 1С
- Использует CustomerSyncLog для логирования операций
- Реализует маппинг типов клиентов 1С на роли платформы

**Story 3.3.1 (CustomerIdentityResolver):**

- CustomerIdentityResolver выполняет детерминированную идентификацию клиентов
- Приоритеты поиска: onec_id → onec_guid → tax_id (ИНН) → email
- Использует методы нормализации: normalize_inn(), normalize_email()
- Логирует каждую попытку идентификации в CustomerSyncLog
- 0% false positive rate благодаря точным совпадениям

**Story 3.2.2 (CustomerConflictResolver):**

- CustomerConflictResolver обрабатывает конфликты при импорте клиентов
- Использует единственную стратегию `onec_wins` - 1C как источник истины
- Автоматически разрешает все конфликты без ручного вмешательства
- Создает записи в SyncConflict для аудита с архивом данных (platform_data + onec_data)
- Отправляет email уведомления администратору при каждом конфликте
- Использует CustomerSyncLog для детального логирования разрешения конфликтов

**Story 3.2.3 (CustomerExportService):**

- CustomerExportService обрабатывает экспорт клиентов в 1С
- Использует CustomerSyncLog для логирования экспорта
- Реализует обработку ошибок и retry механизм

**Использование в этой истории:**

- CustomerSyncLogger централизует логирование всех операций синхронизации
- Логи из всех предыдущих историй собираются в единую систему
- Отчеты и метрики строятся на основе данных из всех компонентов синхронизации

### Ссылки на внешние документы

**Архитектурные документы:**

- [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md) - стратегия тестирования для логирования
- [`docs/architecture/20-1c-integration.md`](docs/architecture/20-1c-integration.md) - подробное описание интеграции с 1С
- [`docs/architecture/02-data-models.md`](docs/architecture/02-data-models.md#user-model) - схема модели User

**Техническая документация:**

- [Django Admin Documentation](https://docs.djangoproject.com/en/stable/ref/contrib/admin/) - руководство по административному интерфейсу
- [Prometheus Documentation](https://prometheus.io/docs/) - руководство по сбору метрик
- [Grafana Documentation](https://grafana.com/docs/) - руководство по визуализации метрик
- [structlog Documentation](https://www.structlog.org/en/stable/) - структурированное логирование

### Edge Cases и обработка ошибок

**1. Переполнение базы данных логов:**

- **Сценарий:** База данных логов достигает лимита хранилища
- **Решение:** Автоматическая ротация логов с приоритетом старых записей
- **Логирование:** Запись в системный лог с типом 'storage_overflow'

**2. Ошибки при генерации отчетов:**

- **Сценарий:** Сбой при создании или отправке отчета
- **Решение:** Повторная попытка через час, уведомление администратора
- **Логирование:** Запись в CustomerSyncLog с типом 'report_generation_error'

**3. Большой объем логов для экспорта:**

- **Сценарий:** Попытка экспорта более 100000 записей через Django Admin
- **Решение:** Ограничение размера выборки, предложение использовать фильтры
- **Логирование:** Запись в системный лог с типом 'export_size_limit'

**4. Потеря корреляции между операциями:**

- **Сценарий:** Отсутствие correlation_id в связанных операциях
- **Решение:** Автоматическая генерация correlation_id при первой операции
- **Логирование:** Запись в CustomerSyncLog с типом 'correlation_missing'

**5. Ошибки при очистке старых логов:**

- **Сценарий:** Сбой команды cleanup_sync_logs из-за блокировки таблиц
- **Решение:** Повторная попытка с интервалом, ручное вмешательство при необходимости
- **Логирование:** Запись в системный лог с типом 'cleanup_error'

**6. Некорректные данные в полях логов:**

- **Сценарий:** Невалидный JSON в поле details или слишком длинное сообщение об ошибке
- **Решение:** Валидация данных перед сохранением, усечение длинных сообщений
- **Логирование:** Запись в системный лог с типом 'data_validation_error'

**7. Проблемы с производительностью запросов:**

- **Сценарий:** Медленные запросы к таблице логов при фильтрации по датам
- **Решение:** Оптимизация индексов, разбиение таблицы по временным периодам
- **Логирование:** Запись в системный лог с типом 'query_performance'

### Тестирование

**Принципы тестирования (согласно [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md)):**

- **Пирамида тестирования:** Основание - быстрые unit-тесты, середина - интеграционные тесты, вершина - E2E тесты
- **Полная изоляция тестов:** Каждый тест выполняется в изолированной среде с автоматической очисткой
- **Генерация уникальных данных:** Использование комбинированного подхода для избежания конфликтов
- **Маркировка тестов:** Обязательное использование маркеров `@pytest.mark.unit` и `@pytest.mark.integration`

**Подход к тестированию:**

- **Unit-тесты:** Для изолированного тестирования CustomerSyncLogger и SyncReportGenerator
- **Интеграционные тесты:** Для проверки полной системы логирования и отчетности
- **Тесты Django Admin:** Для проверки интерфейса администрирования логов
- **Тесты производительности:** Для проверки работы с большими объемами логов

**Ключевые тестовые сценарии:**

1. **Логирование операций импорта:**
   - Создание тестовых данных импорта
   - Проверка корректности записи в CustomerSyncLog
   - Проверка структуры данных в поле details
   - Проверка корреляционного ID

2. **Логирование идентификации клиентов (Story 3.3.1):**
   - Создание тестовых данных для поиска по onec_id, tax_id, email
   - Проверка логирования успешной идентификации
   - Проверка логирования неуспешной идентификации (status='skipped')
   - Проверка записи метода поиска и нормализованных значений

3. **Логирование разрешения конфликтов (Story 3.2.2):**
   - Создание тестовых данных для сценариев portal_registration и data_import
   - Проверка логирования стратегии onec_wins
   - Проверка записи conflicting_fields и changes_made
   - Проверка связи с SyncConflict через sync_conflict_id

4. **Логирование операций экспорта:**
   - Создание тестовых данных экспорта
   - Проверка корректности записи в CustomerSyncLog
   - Проверка обработки ошибок экспорта
   - Проверка длительности операции

5. **Фильтрация и поиск в Django Admin:**
   - Создание набора тестовых логов
   - Проверка фильтров по operation_type, status, created_at
   - Проверка поиска по customer_email, onec_id, correlation_id
   - Проверка экспорта в CSV

6. **Генерация отчетов:**
   - Создание тестовых данных за разные периоды
   - Проверка ежедневного сводного отчета
   - Проверка еженедельного анализа ошибок
   - Проверка отправки отчетов по email

7. **Ротация и очистка логов:**
   - Создание тестовых логов разной давности
   - Проверка команды cleanup_sync_logs
   - Проверка корректного удаления старых логов
   - Проверка сохранения свежих логов

8. **Метрики и мониторинг:**
   - Создание тестовых логов разных типов
   - Проверка сбора метрик Prometheus
   - Проверка алертов для критических ошибок
   - Проверка структурированного логирования

**Тестирование производительности:**

- Создание 100000+ записей в CustomerSyncLog
- Проверка времени выполнения запросов с фильтрами
- Проверка производительности экспорта в CSV
- Тестирование работы с большими объемами данных

**Тестовые данные:**

- Создание тестовых логов всех типов операций
- Подготовка данных для тестирования фильтров
- Создание данных для тестирования отчетов
- Подготовка данных для тестирования edge cases

**Критерии успеха тестирования:**

- Покрытие кода ≥90% для критических модулей
- Все edge cases обработаны корректно
- Время выполнения запросов к логам ≤1 секунды
- Корректная работа с объемами данных ≥100000 записей

**Особые соображения по тестированию:**

- Использование отдельной тестовой базы данных для логов
- Очистка тестовых данных после каждого теста
- Мокирование внешних систем для тестирования отчетов
- Тестирование работы с часовыми поясами в датах

## Story Points

**5** (Medium complexity - mostly configuration and reporting)

## Priority

**Medium** - Важно для операционной поддержки

## Labels

`epic-3` `logging` `audit-trail` `django-admin` `reporting` `compliance`

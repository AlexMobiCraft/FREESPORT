# Story 3.2.2: conflict-resolution

## Status

Ready for Development

## Story

**As a** системный администратор,
**I want** автоматически разрешать конфликты синхронизации с использованием 1C как единственного источника истины,
**so that** обеспечить целостность данных при синхронизации между порталом и 1С с полной прозрачностью всех изменений.

## Acceptance Criteria

1. Создан `CustomerConflictResolver` с детерминированной стратегией: 1C всегда имеет приоритет.
2. При регистрации на портале: если клиент найден по ИНН/email, присваивается verification_status='verified'.
3. При импорте из 1С: конфликтующие поля перезаписываются данными из 1С, профиль обогащается onec_id/onec_guid.
4. Каждый конфликт отправляет email уведомление администратору с деталями.
5. Каждый конфликт создает запись в SyncConflict с архивом старых и новых данных.
6. Все операции логируются в CustomerSyncLog с полной детализацией.
7. Созданы тесты для всех сценариев разрешения конфликтов.

### Детальные задачи

- [ ] **Создать `CustomerConflictResolver` (AC: 1)**
  - [ ] Расположить класс в `apps/users/services/conflict_resolution.py`
  - [ ] `CustomerDataProcessor` (из Story 3.2.1) вызывает `CustomerConflictResolver` при обнаружении существующего клиента
  - [ ] Единственная стратегия: `onec_wins` - данные из 1С всегда имеют приоритет
  - [ ] Метод `resolve_conflict(existing_customer, onec_data, conflict_source)` - главный метод разрешения

- [ ] **Реализовать логику регистрации на портале (AC: 2)**
  - [ ] При регистрации проверять наличие клиента по ИНН (B2B) или email (B2C)
  - [ ] Если найден клиент из 1С (created_in_1c=True): присвоить verification_status='verified'
  - [ ] НЕ изменять данные клиента из 1С, только добавить password для входа
  - [ ] Создать запись в SyncConflict: conflict_type='portal_registration_blocked'
  - [ ] Отправить email администратору о попытке регистрации существующего клиента

- [ ] **Реализовать логику импорта из 1С (AC: 3)**
  - [ ] При импорте использовать CustomerIdentityResolver для поиска существующего клиента
  - [ ] Если клиент найден:
    - [ ] Обогатить профиль: добавить/обновить onec_id, onec_guid
    - [ ] Сравнить все поля данных (email, phone, company_name, tax_id, etc.)
    - [ ] Перезаписать конфликтующие поля данными из 1С
    - [ ] Обновить last_sync_from_1c timestamp
  - [ ] Создать запись в SyncConflict с архивом: platform_data (старые) + onec_data (новые)
  - [ ] Отправить email администратору с детализацией изменений

- [ ] **Настроить email уведомления (AC: 4)**
  - [ ] Создать email template: `conflict_notification.html`
  - [ ] Метод `send_conflict_notification(conflict)` в ConflictResolver
  - [ ] В уведомлении указать:
    - [ ] Тип конфликта (portal_registration / data_import)
    - [ ] Клиента (имя, email, ИНН)
    - [ ] Список конфликтующих полей
    - [ ] Старые и новые значения
    - [ ] Timestamp разрешения конфликта
  - [ ] Email отправляется на адрес из settings.CONFLICT_NOTIFICATION_EMAIL

- [ ] **Создать записи в SyncConflict (AC: 5)**
  - [ ] Использовать модель SyncConflict (из docs/architecture/02-data-models.md)
  - [ ] Для каждого конфликта создавать запись с:
    - [ ] conflict_type: 'customer_data'
    - [ ] customer: ForeignKey на User
    - [ ] platform_data: JSON с текущими данными портала
    - [ ] onec_data: JSON с данными из 1С
    - [ ] conflicting_fields: список полей с различиями
    - [ ] resolution_strategy: 'onec_wins'
    - [ ] is_resolved: True (авто-разрешен)
    - [ ] resolution_details: детали примененных изменений

- [ ] **Настроить логирование в CustomerSyncLog (AC: 6)**
  - [ ] Для каждого конфликта создавать запись с:
    - [ ] operation_type: 'conflict_resolution'
    - [ ] status: 'success'
    - [ ] details: метод идентификации, тип конфликта
    - [ ] changes_made: список измененных полей с old→new значениями
    - [ ] conflict_resolution: стратегия 'onec_wins', timestamp

- [ ] **Создать тесты (AC: 7)**
  - [ ] Unit тесты для CustomerConflictResolver
  - [ ] Integration тесты для сценария регистрации на портале
  - [ ] Integration тесты для сценария импорта из 1С
  - [ ] Тесты проверки отправки email уведомлений
  - [ ] Тесты создания записей в SyncConflict и CustomerSyncLog

## Definition of Done

- [ ] 100% конфликтов разрешается автоматически по стратегии onec_wins
- [ ] Каждый конфликт отправляет email уведомление администратору
- [ ] Каждый конфликт создает запись в SyncConflict с полным архивом данных
- [ ] Все операции логируются в CustomerSyncLog
- [ ] Возможность отката изменений через архивные данные в SyncConflict
- [ ] Время обработки 1000 конфликтов <1 минуты

## Dev Notes

### Story Context

**Место в системе интеграции с 1С:**

Эта история реализует упрощенную стратегию разрешения конфликтов с 1С как единственным источником истины:

1. **Идентификация клиентов (Story 3.3.1)** - детерминированный поиск по ИНН/email
2. **Импорт клиентов (Story 3.2.1)** - загрузка существующих клиентов из 1С  
3. **Разрешение конфликтов (эта история)** - автоматическая перезапись данных из 1С

**Два сценария конфликтов:**

**1. Регистрация на портале (portal_registration):**

- Пользователь пытается зарегистрироваться на портале
- Система находит существующего клиента из 1С по ИНН (B2B) или email (B2C)
- Присваивается verification_status='verified', добавляется пароль для входа
- Данные клиента из 1С НЕ изменяются
- Email администратору + запись в SyncConflict

**2. Импорт из 1С (data_import):**

- Импортируется клиент из 1С
- Система находит существующего клиента на портале
- Профиль обогащается: onec_id, onec_guid
- Все конфликтующие поля перезаписываются данными из 1С
- Email администратору + запись в SyncConflict с архивом старых данных

### Технические требования

**Используемые технологии:**

- **Идентификация:** CustomerIdentityResolver (из Story 3.3.1) - детерминированный поиск
- **Обработка данных:** Django ORM с транзакциями для атомарности операций
- **Архивирование:** JSON-сериализация данных для хранения в SyncConflict.platform_data/onec_data
- **Уведомления:** Django email backend для отправки уведомлений администраторам
- **Логирование:** CustomerSyncLog для детального audit trail всех изменений

**Переменные окружения:**

- `CONFLICT_NOTIFICATION_EMAIL`: Email администратора для уведомлений о конфликтах (обязательно)
- `CONFLICT_AUTO_APPLY`: Автоматически применять стратегию onec_wins (default: True)

**Django Settings (settings.py):**

- `CONFLICT_NOTIFICATION_EMAIL`: Email администратора (из переменной окружения)
- `DEFAULT_FROM_EMAIL`: Email отправителя (стандартная настройка Django)

**Email Template Location:**

- Путь: `backend/templates/emails/conflict_notification.html`
- Шаблон содержит детали конфликта, старые и новые значения полей

**Важные замечания по модели User:**

⚠️ **КРИТИЧНО:** Поле `created_in_1c` должно быть добавлено в модель User (если еще не добавлено в Story 3.2.1). Это поле используется для идентификации клиентов, импортированных из 1С.

⚠️ **ЗАВИСИМОСТЬ:** Story 3.3.1 (CustomerIdentityResolver) должна быть реализована ПЕРЕД этой историей, так как CustomerConflictResolver использует CustomerIdentityResolver для поиска существующих клиентов.

### CustomerConflictResolver Architecture

**Принцип:** Единственная стратегия - `onec_wins`. Данные из 1С всегда имеют приоритет.

```python
class CustomerConflictResolver:
    """Упрощенная система разрешения конфликтов: 1C как источник истины"""
    
    CONFLICTING_FIELDS = [
        'first_name', 'last_name', 'email', 'phone',
        'company_name', 'tax_id', 'legal_address', 'contact_person'
    ]
    
    def resolve_conflict(self, existing_customer, onec_data, conflict_source):
        """
        Главный метод разрешения конфликта.
        
        Args:
            existing_customer (User): Существующий клиент в БД
            onec_data (dict): Данные клиента из 1С
            conflict_source (str): 'portal_registration' или 'data_import'
            
        Returns:
            dict: Результат разрешения конфликта
        """
        with transaction.atomic():
            # 1. Сохраняем текущее состояние для архива
            platform_data = self._serialize_customer(existing_customer)
            
            # 2. Определяем конфликтующие поля
            conflicting_fields = self._detect_conflicting_fields(
                existing_customer, onec_data
            )
            
            # 3. Применяем стратегию в зависимости от источника конфликта
            if conflict_source == 'portal_registration':
                result = self._handle_portal_registration(
                    existing_customer, onec_data
                )
            elif conflict_source == 'data_import':
                result = self._handle_data_import(
                    existing_customer, onec_data, conflicting_fields
                )
            
            # 4. Создаем запись в SyncConflict для аудита
            self._create_sync_conflict_record(
                existing_customer, platform_data, onec_data,
                conflicting_fields, conflict_source
            )
            
            # 5. Логируем операцию
            self._log_conflict_resolution(
                existing_customer, conflicting_fields, conflict_source
            )
            
            return result
        
        # 6. Отправляем email уведомление ВНЕ транзакции
        # Используем transaction.on_commit для отправки после успешного коммита
        transaction.on_commit(
            lambda: self._send_notification_safe(
                existing_customer, platform_data, onec_data,
                conflicting_fields, conflict_source
            )
        )
    
    def _handle_portal_registration(self, existing_customer, onec_data):
        """Обработка регистрации на портале существующего клиента из 1С"""
        # НЕ изменяем данные клиента из 1С
        # Только добавляем password и статус верификации
        existing_customer.verification_status = 'verified'
        existing_customer.save()
        
        return {
            'action': 'verified_client',
            'message': 'Client from 1C verified, no data modified'
        }
    
    def _handle_data_import(self, existing_customer, onec_data, conflicting_fields):
        """Обработка импорта данных из 1С: перезапись конфликтующих полей"""
        changes_made = {}
        
        # Обогащаем профиль 1С идентификаторами
        if onec_id := onec_data.get('onec_id'):
            existing_customer.onec_id = onec_id
            changes_made['onec_id'] = {'old': None, 'new': onec_id}
        
        if onec_guid := onec_data.get('onec_guid'):
            existing_customer.onec_guid = onec_guid
            changes_made['onec_guid'] = {'old': None, 'new': onec_guid}
        
        # Перезаписываем все конфликтующие поля данными из 1С
        for field in conflicting_fields:
            old_value = getattr(existing_customer, field, None)
            new_value = onec_data.get(field)
            
            if new_value is not None:
                setattr(existing_customer, field, new_value)
                changes_made[field] = {'old': old_value, 'new': new_value}
        
        # Обновляем timestamp синхронизации
        existing_customer.last_sync_from_1c = timezone.now()
        existing_customer.save()
        
        return {
            'action': 'data_updated',
            'changes_made': changes_made,
            'message': f'Updated {len(changes_made)} fields from 1C'
        }
```

### Email Notification System

**Важно:** Email отправляется ВНЕ основной транзакции с использованием `transaction.on_commit()` для предотвращения блокировки при ошибках SMTP.

```python
def _send_notification_safe(self, customer, platform_data, onec_data, conflicting_fields, source):
    """Безопасная отправка email уведомления вне транзакции"""
    try:
        self._send_notification(customer, platform_data, onec_data, conflicting_fields, source)
    except Exception as e:
        # Логируем ошибку, но не прерываем процесс
        logger.error(f"Failed to send conflict notification: {e}")
        self._log_notification_error(customer, str(e))

def _send_notification(self, customer, platform_data, onec_data, conflicting_fields, source):
    """Отправка email уведомления администратору о конфликте"""
    from django.core.mail import send_mail
    from django.conf import settings
    from django.template.loader import render_to_string
    
    # Проверяем наличие настройки email
    if not hasattr(settings, 'CONFLICT_NOTIFICATION_EMAIL') or not settings.CONFLICT_NOTIFICATION_EMAIL:
        logger.warning("CONFLICT_NOTIFICATION_EMAIL not configured, skipping notification")
        return
    
    context = {
        'customer': customer,
        'conflict_source': source,
        'conflicting_fields': conflicting_fields,
        'platform_data': platform_data,
        'onec_data': onec_data,
        'resolution': 'onec_wins',
        'timestamp': timezone.now(),
    }
    
    # Рендерим HTML template из backend/templates/emails/conflict_notification.html
    html_content = render_to_string(
        'emails/conflict_notification.html',
        context
    )
    
    # Определяем subject в зависимости от типа конфликта
    if source == 'portal_registration':
        subject = f'[1C Sync] Попытка регистрации существующего клиента: {customer.email}'
    else:
        subject = f'[1C Sync] Обновление данных клиента из 1C: {customer.email}'
    
    # Отправляем email
    send_mail(
        subject=subject,
        message='',  # Текстовая версия (опционально)
        html_message=html_content,
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[settings.CONFLICT_NOTIFICATION_EMAIL],
        fail_silently=False,
    )

def _log_notification_error(self, customer, error_message):
    """Логирование ошибки отправки уведомления"""
    from apps.common.models import CustomerSyncLog
    
    CustomerSyncLog.objects.create(
        operation_type='notification_failed',
        customer=customer,
        status='warning',
        details={'error': error_message},
        error_message=error_message,
        processed_by='CustomerConflictResolver'
    )
```

### SyncConflict Record Creation

```python
def _create_sync_conflict_record(self, customer, platform_data, onec_data, 
                                 conflicting_fields, source):
    """Создание записи в SyncConflict для аудита"""
    from apps.common.models import SyncConflict
    
    SyncConflict.objects.create(
        conflict_type='customer_data',
        customer=customer,
        platform_data=platform_data,  # Архив старых данных
        onec_data=onec_data,          # Новые данные из 1С
        conflicting_fields=conflicting_fields,
        resolution_strategy='onec_wins',
        is_resolved=True,  # Автоматически разрешен
        resolution_details={
            'source': source,
            'resolved_at': timezone.now().isoformat(),
            'fields_updated': len(conflicting_fields),
        },
        resolved_at=timezone.now(),
        resolved_by='CustomerConflictResolver'
    )
```

### CustomerSyncLog Integration

```python
def _log_conflict_resolution(self, customer, conflicting_fields, source):
    """Логирование операции разрешения конфликта"""
    from apps.common.models import CustomerSyncLog
    
    CustomerSyncLog.objects.create(
        operation_type='conflict_resolution',
        customer=customer,
        status='success',
        details={
            'conflict_source': source,
            'resolution_strategy': 'onec_wins',
            'conflicting_fields': conflicting_fields,
        },
        changes_made={
            field: 'updated from 1C'
            for field in conflicting_fields
        },
        conflict_resolution={
            'strategy': 'onec_wins',
            'timestamp': timezone.now().isoformat(),
        },
        processed_by='CustomerConflictResolver'
    )
```

### Dependencies

- **Зависит от:**
  - Story 3.2.1 (CustomerDataProcessor) - вызывает CustomerConflictResolver
  - Story 3.3.1 (CustomerIdentityResolver) - идентификация клиентов
- **Интегрируется с:**
  - Django email system для уведомлений
  - SyncConflict модель для архивирования
  - CustomerSyncLog для audit trail
- **Связанные модели:**
  - User (расширенная для 1С)
  - SyncConflict (из docs/architecture/02-data-models.md)
  - CustomerSyncLog (из docs/architecture/02-data-models.md)

### Информация из предыдущих историй

**Story 3.3.1 (CustomerIdentityResolver):**

- Детерминированная идентификация клиентов по onec_id/onec_guid/ИНН/email
- Приоритеты поиска: onec_id → onec_guid → tax_id (B2B) → email (B2C)
- Без fuzzy matching, только точные совпадения
- Логирование всех попыток идентификации

**Story 3.2.1 (CustomerDataProcessor):**

- Обработка импорта клиентов из 1С
- Использует CustomerIdentityResolver для поиска существующих клиентов
- При нахождении существующего клиента вызывает CustomerConflictResolver
- Логирует все операции в CustomerSyncLog

**Использование в этой истории:**

- CustomerConflictResolver вызывается из CustomerDataProcessor при конфликте
- Использует результаты CustomerIdentityResolver для определения конфликта
- Все операции логируются в CustomerSyncLog с полной детализацией
- Архивные данные сохраняются в SyncConflict для возможности отката

### Edge Cases и обработка ошибок

**1. Отсутствие email в настройках:**

- **Сценарий:** CONFLICT_NOTIFICATION_EMAIL не настроен
- **Решение:** Логирование ошибки, продолжение обработки без отправки email
- **Логирование:** WARNING в CustomerSyncLog с типом 'notification_failed'

**2. Ошибка при отправке email:**

- **Сценарий:** Сбой SMTP сервера или неверный email адрес
- **Решение:** Email отправляется ВНЕ основной транзакции через `transaction.on_commit()`. При ошибке логируется предупреждение, но конфликт уже разрешен успешно
- **Логирование:** WARNING в CustomerSyncLog с типом 'notification_failed', основная операция имеет status='success'

**3. Сбой транзакции при обновлении:**

- **Сценарий:** Ошибка БД при сохранении обновленных данных
- **Решение:** Полный откат транзакции, повторная попытка или логирование ошибки
- **Логирование:** Запись в CustomerSyncLog с типом 'transaction_error', status='error'

**4. Отсутствие конфликтующих полей:**

- **Сценарий:** Все данные идентичны, конфликта фактически нет
- **Решение:** Обогащение профиля onec_id/onec_guid, без изменения других полей
- **Логирование:** Запись в CustomerSyncLog с типом 'no_conflicts', но email все равно отправляется

**5. Частичные данные из 1С:**

- **Сценарий:** В данных из 1С отсутствуют некоторые поля
- **Решение:** Обновляются только присутствующие поля, None значения игнорируются
- **Логирование:** В CustomerSyncLog указываются только обновленные поля

### Тестирование

**Принципы тестирования (согласно [`docs/architecture/10-testing-strategy.md`](../../architecture/10-testing-strategy.md)):**

- **Пирамида тестирования:** Основание - быстрые unit-тесты, середина - интеграционные тесты, вершина - E2E тесты
- **Полная изоляция тестов:** Каждый тест выполняется в изолированной среде с автоматической очисткой
- **Генерация уникальных данных:** Использование комбинированного подхода для избежания конфликтов
- **Маркировка тестов:** Обязательное использование маркеров `@pytest.mark.unit` и `@pytest.mark.integration`

**Подход к тестированию:**

- **Unit-тесты:** Для изолированного тестирования CustomerConflictResolver
- **Интеграционные тесты:** Для проверки полных сценариев с реальными данными
- **Тесты email уведомлений:** Mock SMTP для проверки отправки уведомлений
- **Тесты логирования:** Проверка создания записей в SyncConflict и CustomerSyncLog

**Ключевые тестовые сценарии:**

**1. Сценарий portal_registration (B2B клиент):**

- Создать клиента из 1С с ИНН=1234567890, created_in_1c=True
- Попытка регистрации на портале с тем же ИНН
- Проверить: verification_status='verified' присвоен, данные НЕ изменены
- Проверить: создана запись в SyncConflict, отправлен email

**2. Сценарий portal_registration (B2C клиент):**

- Создать клиента из 1С с email=test@example.com, created_in_1c=True
- Попытка регистрации на портале с тем же email
- Проверить: verification_status='verified' присвоен, данные НЕ изменены
- Проверить: создана запись в SyncConflict, отправлен email

**3. Сценарий data_import (обновление данных):**

- Создать клиента на портале: email=old@example.com, phone=+79991234567
- Импорт из 1С с тем же email но новыми данными: phone=+79997654321
- Проверить: onec_id/onec_guid добавлены, конфликтующие поля обновлены
- Проверить: создана запись в SyncConflict с архивом, отправлен email

**4. Сценарий data_import (без конфликтов):**

- Создать клиента на портале с полностью идентичными данными из 1С
- Импорт из 1С
- Проверить: только onec_id/onec_guid добавлены, другие поля не изменены
- Проверить: email все равно отправлен

**5. Edge case: ошибка отправки email:**

- Mock SMTP для генерации ошибки
- Проверить: конфликт разрешается успешно, ошибка залогирована

**6. Performance тестирование:**

- Создание 1000 конфликтов типа data_import
- Проверка времени обработки (<1 минута)

**Критерии успеха тестирования:**

- Покрытие кода ≥90% для CustomerConflictResolver
- Все сценарии работают корректно
- 100% конфликтов разрешаются автоматически
- Все уведомления отправляются, все операции логируются

## Story Points

**8** (Medium-high complexity - deterministic strategy with notifications and audit)

## Priority

**High** - Критично для целостности данных при синхронизации с 1С

## Labels

`epic-3` `conflict-resolution` `data-sync` `1c-integration` `audit-trail` `email-notifications`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.1 | Исправлено: использование verification_status вместо is_confirmed_client, добавлена информация о created_in_1c, email отправка вне транзакции | PO Agent |
| - | 1.0 | Первоначальная версия истории | PO Agent |

## Dev Agent Record

### Agent Model Used

_Будет заполнено агентом разработки при выполнении истории_

### Debug Log References

_Будет заполнено агентом разработки при выполнении истории_

### Completion Notes

_Будет заполнено агентом разработки при выполнении истории_

### File List

_Будет заполнено агентом разработки при выполнении истории_

## QA Results

_Будет заполнено QA агентом после тестирования реализации_

# Story 3.2.1: import-existing-customers

## Status

Ready for Development

## Story

**As a** менеджер по работе с клиентами,
**I want** импортировать существующих B2B контрагентов из 1С,
**so that** они могут сразу работать с платформой со своими персональными ценами.

## Acceptance Criteria

1. Создана команда `import_customers_from_1c` с необходимой логикой и параметрами.
2. Логика импорта разделена на архитектуру Парсер/Процессор.
3. Модель `User` обновлена для интеграции с 1С.
4. Реализован маппинг ролей и типов клиентов (физ./юр. лица).
5. Созданы валидаторы данных и механизм поиска дубликатов.
6. Создана модель `CustomerSyncLog` и настроено двухуровневое логирование через `ImportSession`.

---

## Tasks / Subtasks

- [ ] **Создать команду `import_customers_from_1c` (AC: 1)**
  - [ ] Расположить в `apps/users/management/commands/import_customers_from_1c.py`
  - [ ] Реализовать параметры: `--file`, `--dry-run`, `--chunk-size`
  - [ ] Команда должна использовать `CustomerDataParser` и `CustomerDataProcessor`
  - [ ] Команда должна создавать и управлять `ImportSession` (тип `customers`)

- [ ] **Реализовать архитектуру Парсер/Процессор (AC: 2)**
  - [ ] Создать `CustomerDataParser` в `apps/users/services/`.
  - [ ] Создать `CustomerDataProcessor` в `apps/users/services/`.

- [ ] **Обновить модель User (AC: 3)**
  - [ ] Расположение: `backend/apps/users/models.py`
  - [ ] Обновить существующее поле: `email = EmailField(unique=True, blank=True)` - добавить blank=True
  - [ ] `onec_id = CharField(max_length=100, unique=True, null=True)`
  - [ ] `sync_status = CharField(choices=SYNC_STATUSES, default='pending')`
  - [ ] `created_in_1c = BooleanField(default=False)`
  - [ ] `needs_1c_export = BooleanField(default=False)`
  - [ ] `last_sync_at = DateTimeField(null=True, blank=True)`
  - [ ] `sync_error_message = TextField(blank=True)`
  - [ ] Создать миграцию с индексами для `onec_id` и изменением email

- [ ] **Реализовать маппинг ролей (AC: 4)**
  - [ ] Логика маппинга должна быть частью `CustomerDataProcessor`.
  - [ ] Маппинг типов клиентов 1С → роли платформы.
    - **Решение PO (22.09.2025):** Использовать следующий маппинг:
      - `"Опт 1"` -> `wholesale_level1`
      - `"Опт 2"` -> `wholesale_level2`
      - `"Опт 3"` -> `wholesale_level3`
      - `"Тренерская"` -> `trainer`
      - `"РРЦ"` -> `retail`
  - [ ] Fallback к роли `retail` для неопознанных типов.
    - **Решение PO (22.09.2025):** Утверждено.

- [ ] **Поддержать физ.лица и юр.лица (AC: 4)**
  - [ ] Логика должна быть в `CustomerDataProcessor`.
  - [ ] Определение типа клиента по наличию company_name.
  - [ ] Валидация обязательных полей для каждого типа.

- [ ] **Создать валидаторы данных (AC: 5)**
  - [ ] Логика валидации должна быть в `CustomerDataProcessor`.
  - [ ] Валидация email format (если email присутствует).
  - [ ] Email опционален для всех типов клиентов (blank=True).
  - [ ] Логирование warning при отсутствии email.

- [ ] **Создать модель `CustomerSyncLog` и настроить логирование (AC: 6)**
  - [ ] Создать модель `CustomerSyncLog` (в `apps/common/models.py`) для детального логирования операций с клиентами.
  - [ ] Добавить `ForeignKey` на `ImportSession` для связи лога с общей сессией.
  - [ ] В `CustomerDataProcessor` реализовать логику создания записей в `CustomerSyncLog` для каждого обработанного клиента (успех, ошибка, пропуск).

- [ ] **Реализовать поиск дубликатов (AC: 7)**
  - [ ] Логика поиска дубликатов должна быть в `CustomerDataProcessor`.
  - [ ] Поиск по onec_id (основной метод, get_or_create).
  - [ ] Поиск по email (вторичный метод).

---

## Dev Notes

- [ ] Импортированы тестовые клиенты всех типов
- [ ] Все клиенты получили корректные роли и цены
- [ ] Нет дубликатов в системе
- [ ] Логирование работает корректно через `CustomerSyncLog` и `ImportSession`
- [ ] Реальная интеграция с файлами от 1С
- [ ] Созданы тесты для всех сценариев

### Story Context

**Customer Integration Points:**

- Источник данных: 1С:Управление торговлей справочник клиентов
- Цель: Синхронизированная клиентская база с ролевыми ценами
- Критично: Правильный маппинг ролей для корректных цен

**Место в системе интеграции с 1С:**

Эта история является критическим компонентом интеграции с 1С:

1. **Импорт товаров** (Stories 3.1.x) - загрузка каталога и цен
2. **Импорт клиентов** (эта история) - загрузка существующей клиентской базы
3. **Идентификация клиентов** (Story 3.3.1) - детерминированный поиск по ИНН/email
4. **Разрешение конфликтов** (Story 3.2.2) - автоматическая стратегия `onec_wins`
5. **Синхронизация заказов** (будущие истории) - экспорт заказов из платформы в 1С

**Workflow импорта:**

- CustomerDataParser парсит XML → CustomerDataProcessor обрабатывает данные
- При обнаружении существующего клиента: CustomerIdentityResolver идентифицирует → CustomerConflictResolver разрешает конфликт
- Импорт клиентов должен происходить после импорта каталога, так как роли клиентов определяют типы цен

### Технические требования

**Используемые технологии:**

- **Парсинг XML:** Python xml.etree.ElementTree или lxml
- **Обработка данных:** Django ORM с оптимизацией bulk operations
- **Архитектура:** Парсер/Процессор для гибкости будущей интеграции через API
- **Логирование:** Django logging + кастомная модель CustomerSyncLog

**Переменные окружения:**

- `ONEC_DATA_PATH`: Путь к директории с файлами выгрузки из 1С
- `IMPORT_CHUNK_SIZE`: Размер пакета для обработки (по умолчанию: 100)
- `IMPORT_DRY_RUN`: Режим тестового запуска без сохранения данных (True/False)

**Ожидаемая производительность:**

Предварительные оценки времени выполнения команды `import_customers_from_1c`:

| Количество клиентов | Ожидаемое время | Примечания |
|---------------------|-----------------|------------|
| 100 клиентов | ~5-10 секунд | Базовый сценарий без дубликатов |
| 500 клиентов | ~30-45 секунд | Средний объем для тестирования |
| 1000 клиентов | ~1-2 минуты | Типичная выгрузка для среднего бизнеса |
| 5000 клиентов | ~5-10 минут | Крупная клиентская база |
| 10000 клиентов | ~10-20 минут | Максимальный объем для единовременной загрузки |

**Факторы, влияющие на производительность:**

- **Размер chunk_size:** Больший размер = меньше транзакций, но больше памяти
- **Количество дубликатов:** Каждый дубликат требует дополнительных запросов к БД
- **Сложность валидации:** Проверка email, поиск по onec_id и email
- **Логирование:** Создание записей CustomerSyncLog для каждого клиента
- **Тип БД:** PostgreSQL с индексами работает быстрее
- **Нагрузка на сервер:** Параллельные процессы могут замедлить выполнение

**Рекомендации по оптимизации:**

1. **Использовать bulk_create/bulk_update** для пакетной обработки
2. **Настроить chunk_size** в зависимости от доступной памяти (50-200)
3. **Создать индексы** на `onec_id` и `email` в User model
4. **Запускать в off-peak hours** для минимизации конфликтов
5. **Использовать connection pooling** для оптимизации БД соединений

**Concurrent Execution:**

⚠️ **ВАЖНО:** Команда включает проверку активных сессий импорта для предотвращения race conditions:

```python
# Проверка на активные сессии импорта (строки 336-346 в команде)
active_sessions = ImportSession.objects.filter(
    import_type=ImportSession.ImportType.CUSTOMERS,
    status=ImportSession.ImportStatus.STARTED
).exists()

if active_sessions:
    raise CommandError(
        "Импорт клиентов уже выполняется. "
        "Дождитесь завершения или отмените активную сессию."
    )
```

Это гарантирует, что только одна команда импорта клиентов может выполняться одновременно.

### Database Schema

#### Модель User (существующая, обновляется)

**Расположение:** `backend/apps/users/models.py`

```python
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    """Кастомная модель пользователя с ролевой системой"""
    
    # Существующие поля (из Story 2.2)
    ROLE_CHOICES = [
        ('retail', 'Розничный покупатель'),
        ('wholesale_level1', 'Оптовик уровень 1'),
        ('wholesale_level2', 'Оптовик уровень 2'),
        ('wholesale_level3', 'Оптовик уровень 3'),
        ('trainer', 'Тренер'),
        ('federation_rep', 'Представитель федерации'),
        ('admin', 'Администратор'),
    ]
    
    email = models.EmailField(unique=True, blank=True)  # blank=True для поддержки клиентов без email
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='retail')
    company_name = models.CharField(max_length=255, blank=True)
    tax_id = models.CharField(max_length=50, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    
    # НОВЫЕ поля для интеграции с 1С (добавляются в этой Story)
    onec_id = models.CharField(
        'ID в 1С',
        max_length=100,
        unique=True,
        null=True,
        blank=True,
        db_index=True
    )
    sync_status = models.CharField(
        max_length=20,
        choices=[
            ('pending', 'Ожидает синхронизации'),
            ('synced', 'Синхронизирован'),
            ('error', 'Ошибка синхронизации'),
        ],
        default='pending'
    )
    created_in_1c = models.BooleanField(
        'Создан в 1С',
        default=False,
        help_text='True если клиент импортирован из 1С'
    )
    needs_1c_export = models.BooleanField(
        'Требует экспорта в 1С',
        default=False,
        help_text='True если клиент создан на платформе и требует экспорта в 1С'
    )
    last_sync_at = models.DateTimeField(
        'Последняя синхронизация',
        null=True,
        blank=True
    )
    sync_error_message = models.TextField(
        'Сообщение об ошибке синхронизации',
        blank=True
    )
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
```

#### Модель CustomerSyncLog (новая)

**Расположение:** `backend/apps/common/models.py`

```python
from django.db import models

class CustomerSyncLog(models.Model):
    """Детальное логирование операций импорта клиентов"""
    
    class OperationType(models.TextChoices):
        CREATED = 'created', 'Создан'
        UPDATED = 'updated', 'Обновлен'
        SKIPPED = 'skipped', 'Пропущен'
        ERROR = 'error', 'Ошибка'
    
    class StatusType(models.TextChoices):
        SUCCESS = 'success', 'Успешно'
        FAILED = 'failed', 'Ошибка'
        WARNING = 'warning', 'Предупреждение'
    
    session = models.ForeignKey(
        'ImportSession',
        on_delete=models.CASCADE,
        related_name='customer_logs',
        verbose_name='Сессия импорта'
    )
    user = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        verbose_name='Пользователь'
    )
    onec_id = models.CharField(
        'ID в 1С',
        max_length=100
    )
    operation_type = models.CharField(
        'Тип операции',
        max_length=20,
        choices=OperationType.choices
    )
    status = models.CharField(
        'Статус',
        max_length=20,
        choices=StatusType.choices
    )
    error_message = models.TextField(
        'Сообщение об ошибке',
        blank=True
    )
    details = models.JSONField(
        'Детали операции',
        default=dict,
        blank=True,
        help_text='Дополнительная информация: старые/новые значения, причина пропуска и т.д.'
    )
    created_at = models.DateTimeField(
        'Дата создания',
        auto_now_add=True
    )
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['session', 'operation_type']),
            models.Index(fields=['onec_id']),
            models.Index(fields=['status']),
        ]
        verbose_name = 'Лог синхронизации клиента'
        verbose_name_plural = 'Логи синхронизации клиентов'
    
    def __str__(self):
        return f"{self.operation_type} - {self.onec_id} ({self.status})"
```

### CustomerDataParser Structure

**Расположение:** `backend/apps/users/services/parser.py`

```python
import xml.etree.ElementTree as ET
from typing import List, Dict, Optional
from django.core.exceptions import ValidationError


class CustomerDataParser:
    """Парсер данных клиентов из XML файлов 1С (CommerceML 3.1)"""
    
    def parse(self, file_path: str) -> List[Dict]:
        """
        Парсит XML файл contragents.xml и возвращает список клиентов.
        
        Args:
            file_path: Путь к файлу contragents.xml
            
        Returns:
            List[Dict]: Список словарей с данными клиентов
            
        Raises:
            FileNotFoundError: Если файл не найден
            ValidationError: Если структура XML некорректна
        """
        pass
    
    def _parse_customer_node(self, customer_node: ET.Element) -> Dict:
        """
        Парсит узел <Контрагент> и извлекает данные клиента.
        
        Args:
            customer_node: XML элемент <Контрагент>
            
        Returns:
            Dict: Словарь с данными клиента
        """
        pass
    
    def _extract_contact_info(self, customer_node: ET.Element) -> Dict:
        """
        Извлекает контактную информацию из узла <Контакты>.
        
        Args:
            customer_node: XML элемент <Контрагент>
            
        Returns:
            Dict: Словарь с email, phone и другими контактами
        """
        pass
    
    def _determine_customer_type(self, customer_data: Dict) -> str:
        """
        Определяет тип клиента (legal_entity, individual_entrepreneur, individual).
        
        Args:
            customer_data: Словарь с данными клиента
            
        Returns:
            str: Тип клиента
        """
        pass
    
    def _validate_customer_data(self, customer_data: Dict) -> bool:
        """
        Валидирует данные клиента перед обработкой.
        
        Args:
            customer_data: Словарь с данными клиента
            
        Returns:
            bool: True если данные валидны
            
        Raises:
            ValidationError: Если данные не проходят валидацию
        """
        pass
```

### Role Mapping Logic

**Расположение:** `backend/apps/users/services/processor.py`

```python
from typing import Dict, Optional
from django.contrib.auth import get_user_model
from apps.common.models import CustomerSyncLog, ImportSession

User = get_user_model()


class CustomerDataProcessor:
    """Процессор данных клиентов для импорта в систему"""
    
    ROLE_MAPPING = {
        'Опт 1': 'wholesale_level1',
        'Опт 2': 'wholesale_level2',
        'Опт 3': 'wholesale_level3',
        'Тренерская': 'trainer',
        'РРЦ': 'retail',
    }
    
    def __init__(self, session_id: int):
        """
        Инициализирует процессор с ID сессии импорта.
        
        Args:
            session_id: ID объекта ImportSession
        """
        self.session = ImportSession.objects.get(pk=session_id)
    
    def map_role(self, onec_role: str) -> str:
        """
        Маппинг роли из 1С на роль платформы.
        
        Args:
            onec_role: Тип клиента из 1С
            
        Returns:
            str: Роль в системе платформы
        """
        return self.ROLE_MAPPING.get(onec_role, 'retail')  # fallback к retail
    
    def process_customer(self, customer_data: Dict) -> Optional[User]:
        """
        Обрабатывает данные одного клиента: создает или обновляет.
        
        Args:
            customer_data: Словарь с данными клиента из парсера
            
        Returns:
            Optional[User]: Созданный/обновленный пользователь или None при ошибке
        """
        pass
    
    def process_customers(self, customers_data: List[Dict], chunk_size: int = 100) -> Dict:
        """
        Обрабатывает список клиентов пакетами.
        
        Args:
            customers_data: Список словарей с данными клиентов
            chunk_size: Размер пакета для обработки
            
        Returns:
            Dict: Статистика обработки (total, created, updated, skipped, errors)
        """
        pass
    
    def _find_duplicate(self, customer_data: Dict) -> Optional[User]:
        """
        Ищет дубликаты клиента по onec_id и email.
        
        Args:
            customer_data: Словарь с данными клиента
            
        Returns:
            Optional[User]: Найденный пользователь или None
        """
        pass
    
    def _validate_email(self, email: str) -> bool:
        """
        Валидирует формат email.
        
        Args:
            email: Email для проверки
            
        Returns:
            bool: True если email валиден
        """
        pass
    
    def _log_operation(self, user: Optional[User], onec_id: str, 
                      operation_type: str, status: str, 
                      error_message: str = '', details: Dict = None):
        """
        Создает запись в CustomerSyncLog.
        
        Args:
            user: Пользователь (может быть None при ошибке)
            onec_id: ID клиента в 1С
            operation_type: Тип операции (created/updated/skipped/error)
            status: Статус (success/failed/warning)
            error_message: Сообщение об ошибке
            details: Дополнительные детали операции
        """
        pass
```

### Примерная структура команды import_customers_from_1c

**Расположение:** `backend/apps/users/management/commands/import_customers_from_1c.py`

```python
import os
from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.utils import timezone
from apps.users.models import User
from apps.common.models import ImportSession, CustomerSyncLog
from apps.users.services.parser import CustomerDataParser
from apps.users.services.processor import CustomerDataProcessor


class Command(BaseCommand):
    help = "Импортирует клиентов из файла 1С (contragents.xml)."

    def add_arguments(self, parser):
        parser.add_argument(
            '--file',
            type=str,
            required=True,
            help='Путь к файлу contragents.xml.'
        )
        parser.add_argument(
            '--chunk-size',
            type=int,
            default=100,
            help='Размер пакета для обработки (по умолчанию: 100).'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Тестовый запуск без сохранения данных.'
        )

    def handle(self, *args, **options):
        file_path = options['file']
        chunk_size = options['chunk_size']
        dry_run = options['dry_run']

        # Валидация входных данных
        if not os.path.exists(file_path):
            raise CommandError(f"Файл не найден: {file_path}")
        
        if chunk_size <= 0:
            raise CommandError("chunk-size должен быть положительным числом.")

        # Проверка на активные сессии импорта
        active_sessions = ImportSession.objects.filter(
            import_type=ImportSession.ImportType.CUSTOMERS,
            status=ImportSession.ImportStatus.STARTED
        ).exists()
        
        if active_sessions:
            raise CommandError(
                "Импорт клиентов уже выполняется. "
                "Дождитесь завершения или отмените активную сессию."
            )

        # Создание сессии импорта
        session = ImportSession.objects.create(
            import_type=ImportSession.ImportType.CUSTOMERS,
            status=ImportSession.ImportStatus.STARTED
        )

        self.stdout.write(
            self.style.SUCCESS(f"Начата сессия импорта #{session.pk}")
        )

        try:
            with transaction.atomic():
                # Парсинг данных из XML
                self.stdout.write("Парсинг файла...")
                parser = CustomerDataParser()
                customer_data = parser.parse(file_path)
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Распознано {len(customer_data)} клиентов"
                    )
                )

                # Обработка данных
                self.stdout.write("Обработка клиентов...")
                processor = CustomerDataProcessor(session_id=session.pk)
                result = processor.process_customers(
                    customer_data,
                    chunk_size=chunk_size
                )

                # Вывод статистики
                self.stdout.write(
                    self.style.SUCCESS(
                        f"\nСтатистика обработки:\n"
                        f"  Всего: {result['total']}\n"
                        f"  Создано: {result['created']}\n"
                        f"  Обновлено: {result['updated']}\n"
                        f"  Пропущено: {result['skipped']}\n"
                        f"  Ошибок: {result['errors']}"
                    )
                )

                # Dry-run режим
                if dry_run:
                    self.stdout.write(
                        self.style.WARNING(
                            "\n⚠️  DRY-RUN режим: изменения не сохранены"
                        )
                    )
                    transaction.set_rollback(True)
                    session.delete()  # Удаляем тестовую сессию
                else:
                    # Обновление сессии
                    session.status = ImportSession.ImportStatus.COMPLETED
                    session.details = result
                    session.finished_at = timezone.now()
                    session.save()

                    self.stdout.write(
                        self.style.SUCCESS(
                            f"\n✅ Импорт завершен успешно. Сессия #{session.pk}"
                        )
                    )

        except Exception as e:
            # Обработка ошибок
            session.status = ImportSession.ImportStatus.FAILED
            session.error_message = str(e)
            session.finished_at = timezone.now()
            session.save()
            
            self.stdout.write(
                self.style.ERROR(
                    f"\n❌ Ошибка импорта: {str(e)}\n"
                    f"Сессия #{session.pk} завершена с ошибкой"
                )
            )
            raise
```

**Примеры использования:**

```bash
# Базовое использование
python manage.py import_customers_from_1c --file=/path/to/contragents.xml

# Тестовый запуск
python manage.py import_customers_from_1c --file=/path/to/contragents.xml --dry-run

# С настройкой размера пакета
python manage.py import_customers_from_1c --file=/path/to/contragents.xml --chunk-size=50

# PowerShell (Windows)
python manage.py import_customers_from_1c --file=C:\data\1c\contragents.xml
```

### Sample Import Data (Реальная структура CommerceML 3.1)

**Источник данных:** `backend/tests/fixtures/1c-data/contragents/contragents.xml`

**Формат:**

- **Файл:** `contragents.xml` (CommerceML 3.1)
- **Кодировка:** UTF-8
- **Структура:** `<КоммерческаяИнформация>` → `<Контрагенты>` → `<Контрагент>`

**Реальная структура данных:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<КоммерческаяИнформация xmlns="urn:1C.ru:commerceml_3" ВерсияСхемы="3.1" ДатаФормирования="2025-09-12T21:35:16">
  <Контрагенты СодержитТолькоИзменения="false">
    <!-- Пример 1: ИП (Индивидуальный предприниматель) -->
    <Контрагент>
      <Ид>c0dd88e1-3896-11e6-811f-00155d87f90d</Ид>
      <Наименование>Мирошниченко Марина Викторовна</Наименование>
      <ПолноеНаименование>ИП Мирошниченко Марина Викторовна</ПолноеНаименование>
      <Роль>Покупатель</Роль>
      <ИНН>261601301216</ИНН>
      <КПП/>
      <РасчетныеСчета>
        <РасчетныйСчет>
          <НомерСчета>40802810500060000645</НомерСчета>
          <Банк>
            <БИК>048327780</БИК>
            <Наименование>Ф-Л СЕВЕРО-КАВКАЗСКИЙ ПАО БАНК "ФК ОТКРЫТИЕ"</Наименование>
          </Банк>
        </РасчетныйСчет>
      </РасчетныеСчета>
      <Представители>
        <Представитель>
          <Отношение>Контактное лицо</Отношение>
          <Ид>e443ef46-5bd9-11eb-81d4-00155d3cae02</Ид>
          <Наименование>Мирошниченко Марина Викторовна</Наименование>
        </Представитель>
      </Представители>
      <АдресРегистрации>
        <Представление>Ставропольский край, Шпаковский, Михайловск, Октябрьская, дом № 368</Представление>
      </АдресРегистрации>
      <Контакты/>
    </Контрагент>
    
    <!-- Пример 2: ООО (Юридическое лицо) -->
    <Контрагент>
      <Ид>c9b1ff01-a710-11e6-812a-00155d87f90d</Ид>
      <Наименование>КСТ-СПОРТ ООО</Наименование>
      <ОфициальноеНаименование>ООО "КСТ-СПОРТ"</ОфициальноеНаименование>
      <Роль>Покупатель</Роль>
      <ИНН>2312089985</ИНН>
      <КПП>231201001</КПП>
      <РасчетныеСчета>
        <РасчетныйСчет>
          <НомерСчета>40702810530000037899</НомерСчета>
          <Банк>
            <БИК>040349602</БИК>
            <Наименование>КРАСНОДАРСКОЕ ОТДЕЛЕНИЕ N8619 ПАО СБЕРБАНК</Наименование>
          </Банк>
        </РасчетныйСчет>
      </РасчетныеСчета>
      <Представители>
        <Представитель>
          <Отношение>Контактное лицо</Отношение>
          <Ид>f139b416-2a95-11ec-81f7-00155d3cae02</Ид>
          <Наименование>Ткачева Галина Николаевна</Наименование>
        </Представитель>
      </Представители>
      <АдресРегистрации>
        <Представление>350059, Краснодарский край, Краснодар г, Уральская ул, дом 73</Представление>
      </АдресРегистрации>
      <Контакты/>
    </Контрагент>
    
    <!-- Пример 3: Физическое лицо без ИНН -->
    <Контрагент>
      <Ид>edbedc91-b624-11e6-812b-00155d87f90d</Ид>
      <Наименование>Хож Ахмед - г.Грозный</Наименование>
      <ПолноеНаименование>Хож Ахмед - г.Грозный, ул. Хамзата Орзамиева, д.2   тел : 8-928-787-21-65</ПолноеНаименование>
      <Роль>Покупатель</Роль>
      <ИНН/>
      <Представители>
        <Представитель>
          <Отношение>Контактное лицо</Отношение>
          <Ид>a8bf73f7-3f23-11ed-a303-04421a23d8e8</Ид>
          <Наименование>Хож Ахмед</Наименование>
        </Представитель>
      </Представители>
      <АдресРегистрации>
        <Представление>Грозный</Представление>
      </АдресРегистрации>
      <Контакты/>
    </Контрагент>
  </Контрагенты>
</КоммерческаяИнформация>
```

**Ключевые поля узла `<Контрагент>`:**

- `<Ид>`: UUID контрагента в 1С (используется как `onec_id`)
- `<Наименование>`: Краткое наименование
- `<ПолноеНаименование>` или `<ОфициальноеНаименование>`: Полное наименование
- `<Роль>`: Всегда "Покупатель"
- `<ИНН>`: ИНН (может быть пустым)
- `<КПП>`: КПП для юр.лиц (пустой для ИП и физ.лиц)
- `<Представители>`: Контактные лица
- `<АдресРегистрации>`: Адрес регистрации
- `<Контакты>`: Телефоны и другие контакты

**Определение типа клиента:**

- **Юр.лицо (legal_entity):** Наличие `<КПП>` и `<ОфициальноеНаименование>`
- **ИП (individual_entrepreneur):** Наличие `<ИНН>` и `<ПолноеНаименование>` с префиксом "ИП"
- **Физ.лицо (individual):** Отсутствие `<КПП>`, может не быть `<ИНН>`

**Ссылка на анализ данных:**

- Детальный анализ: `docs/epics/epic-3/data-analysis.md` (строка 129)
- Тестовые данные: `backend/tests/fixtures/1c-data/contragents/contragents.xml`

### Dependencies

- **Depends on:**
  - Story 3.1.1 (модель `ImportSession`)
  - Story 2.2 (User model с ролевой системой) - роли уже определены: `retail`, `wholesale_level1`, `wholesale_level2`, `wholesale_level3`, `trainer`, `federation_rep`
  - User model существует в `backend/apps/users/models.py`, требуется только добавление полей для интеграции с 1С
- **Blocks:** Story 3.2.2 (conflict resolution) и Story 3.3.1 (customer identity algorithms)
- **Related:** Authentication system, pricing logic
- **Note:** Story 3.2.1 фокусируется на импорте, Stories 3.2.2 и 3.3.1 обрабатывают конфликты при обнаружении существующих клиентов

### Информация из Story 3.1.1 (ImportSession model)

**Модель ImportSession** (из Story 3.1.1):

- Поля: `import_type`, `status`, `started_at`, `finished_at`, `report_details` (JSONField), `error_message`
- Типы импорта: `CATALOG`, `STOCKS`, `PRICES`, `CUSTOMERS`
- Статусы: `STARTED`, `COMPLETED`, `FAILED`
- Используется для отслеживания сессий импорта и атомарности операций

**Использование в этой истории:**

- Команда `import_customers_from_1c` должна создавать сессию с типом `CUSTOMERS`
- Все ошибки и статистика должны логироваться в `report_details`
- В конце работы статус должен обновляться на `COMPLETED` или `FAILED`

### Edge Cases и обработка ошибок

**1. Обработка дубликатов клиентов:**

- **Сценарий:** Клиент существует в 1С и на платформе (разные ID)
- **Решение:** Поиск по onec_id (основной) и email (вторичный), слияние записей
- **Логирование:** Запись в CustomerSyncLog с типом 'duplicate_customer'

**2. Некорректные данные из 1С:**

- **Сценарий:** Отсутствует email или невалидный формат
- **Решение:**
  - **Для всех типов клиентов (юр.лица, ИП, физ.лица):** Email опционален - создание пользователя с пустым email (blank=True)
  - При отсутствии email создается пользователь с пустым полем email
  - Продолжение импорта в любом случае
- **Логирование:** Запись в CustomerSyncLog с типом 'warning' и статусом 'success' для клиентов без email
- **Техническая реализация:** User.email должен иметь `blank=True` для поддержки всех типов клиентов без email

**3. Несопоставимые типы клиентов:**

- **Сценарий:** Тип клиента в 1С не соответствует маппингу ролей
- **Решение:** Fallback к роли 'retail' с логированием предупреждения
- **Логирование:** Запись в CustomerSyncLog с типом 'role_mapping_warning'

**4. Прерывание импорта:**

- **Сценарий:** Сбой системы или ошибка в файле данных
- **Решение:** Откат транзакции через ImportSession, сохранение прогресса
- **Логирование:** Обновление статуса ImportSession на 'failed' с деталями ошибки

**5. Конфликты данных:**

- **Сценарий:** Данные клиента в 1С и на платформе различаются
- **Решение:** Делегирование в CustomerConflictResolver (Story 3.2.2) - стратегия `onec_wins`
- **Логирование:** CustomerConflictResolver создает записи в SyncConflict и CustomerSyncLog
- **Note:** CustomerDataProcessor обнаруживает конфликт и вызывает CustomerConflictResolver для разрешения

### Тестирование

**Принципы тестирования (согласно [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md)):**

- **Пирамида тестирования:** Основание - быстрые unit-тесты, середина - интеграционные тесты, вершина - E2E тесты
- **Полная изоляция тестов:** Каждый тест выполняется в изолированной среде с автоматической очисткой
- **Генерация уникальных данных:** Использование комбинированного подхода для избежания конфликтов
- **Маркировка тестов:** Обязательное использование маркеров `@pytest.mark.unit` и `@pytest.mark.integration`

**Подход к тестированию:**

- **Unit-тесты:** Для изолированного тестирования CustomerDataParser и CustomerDataProcessor
- **Интеграционные тесты:** Для проверки полной команды load_customers с реальными XML-данными
- **Тесты edge cases:** Для проверки обработки ошибок и особых сценариев
- **Performance тесты:** Для проверки производительности при импорте больших объемов данных

**Требования к покрытию:**

- **Общее покрытие:** ≥70%
- **Критические модули:** ≥90% (CustomerDataProcessor, CustomerDataParser, CustomerSyncLog)

**Ключевые тестовые сценарии:**

1. **Успешный импорт нового клиента:**
   - Создание клиента с корректными данными
   - Проверка маппинга роли
   - Проверка создания записей в CustomerSyncLog

2. **Обновление существующего клиента:**
   - Импорт клиента с существующим onec_id
   - Проверка обновления данных
   - Проверка статуса синхронизации

3. **Обработка дубликатов:**
   - Импорт клиента с существующим email
   - Проверка логики слияния записей
   - Проверка логирования дубликатов

4. **Валидация данных:**
   - **Клиент без email:** Создание с пустым email, логирование warning
   - **Невалидный формат email:** Пропуск записи с логированием ошибки
   - Проверка продолжения импорта после ошибки

5. **Маппинг ролей:**
   - Импорт клиентов с различными типами из 1С
   - Проверка корректного маппинга на роли платформы
   - Проверка fallback-логики для неизвестных типов

6. **Обработка ошибок импорта:**
   - Имитация сбоя в середине процесса
   - Проверка отката через ImportSession
   - Проверка сохранения прогресса

#### Примеры тестового кода

**Unit-тесты для CustomerDataParser:**

**Расположение:** `backend/tests/unit/test_services/test_customer_parser.py`

```python
import pytest
from pathlib import Path
from apps.users.services.parser import CustomerDataParser


@pytest.mark.unit
class TestCustomerDataParser:
    """Unit-тесты для парсера клиентов"""
    
    def test_parse_valid_xml(self, tmp_path):
        """Проверка парсинга корректного XML"""
        xml_content = """<?xml version="1.0" encoding="UTF-8"?>
        <customers>
          <customer>
            <id>1C-001</id>
            <email>test@example.com</email>
            <first_name>Иван</first_name>
            <last_name>Петров</last_name>
            <customer_type>Опт 1</customer_type>
            <company_name>ООО Тест</company_name>
            <tax_id>1234567890</tax_id>
          </customer>
        </customers>
        """
        xml_file = tmp_path / "test.xml"
        xml_file.write_text(xml_content, encoding='utf-8')
        
        parser = CustomerDataParser()
        result = parser.parse(str(xml_file))
        
        assert len(result) == 1
        assert result[0]['onec_id'] == '1C-001'
        assert result[0]['email'] == 'test@example.com'
        assert result[0]['customer_type'] == 'Опт 1'
        assert result[0]['company_name'] == 'ООО Тест'
    
    def test_parse_empty_file(self, tmp_path):
        """Проверка обработки пустого файла"""
        xml_file = tmp_path / "empty.xml"
        xml_file.write_text("<?xml version='1.0'?><customers></customers>")
        
        parser = CustomerDataParser()
        result = parser.parse(str(xml_file))
        
        assert result == []
    
    def test_parse_malformed_xml(self, tmp_path):
        """Проверка обработки некорректного XML"""
        xml_file = tmp_path / "malformed.xml"
        xml_file.write_text("<customers><customer>")
        
        parser = CustomerDataParser()
        
        with pytest.raises(Exception):
            parser.parse(str(xml_file))
```

**Unit-тесты для CustomerDataProcessor:**

**Расположение:** `backend/tests/unit/test_services/test_customer_processor.py`

```python
import pytest
from django.contrib.auth import get_user_model
from apps.users.services.processor import CustomerDataProcessor
from apps.common.models import ImportSession, CustomerSyncLog

User = get_user_model()


@pytest.mark.unit
@pytest.mark.django_db
class TestCustomerDataProcessor:
    """Unit-тесты для процессора клиентов"""
    
    @pytest.fixture
    def session(self):
        """Фикстура для создания сессии импорта"""
        return ImportSession.objects.create(
            import_type=ImportSession.ImportType.CUSTOMERS,
            status=ImportSession.ImportStatus.STARTED
        )
    
    @pytest.fixture
    def processor(self, session):
        """Фикстура для создания процессора"""
        return CustomerDataProcessor(session_id=session.pk)
    
    def test_role_mapping(self, processor):
        """Проверка маппинга ролей"""
        assert processor.map_role('Опт 1') == 'wholesale_level1'
        assert processor.map_role('Опт 2') == 'wholesale_level2'
        assert processor.map_role('Тренерская') == 'trainer'
        assert processor.map_role('Неизвестная') == 'retail'  # fallback
    
    def test_create_new_customer(self, processor):
        """Проверка создания нового клиента"""
        customer_data = {
            'onec_id': '1C-NEW-001',
            'email': 'newcustomer@example.com',
            'first_name': 'Иван',
            'last_name': 'Петров',
            'customer_type': 'Опт 1',
        }
        
        user = processor.process_customer(customer_data)
        
        assert user is not None
        assert user.onec_id == '1C-NEW-001'
        assert user.email == 'newcustomer@example.com'
        assert user.role == 'wholesale_level1'
        assert user.created_in_1c is True
        
        # Проверка логирования
        log = CustomerSyncLog.objects.filter(onec_id='1C-NEW-001').first()
        assert log is not None
        assert log.operation_type == CustomerSyncLog.OperationType.CREATED
        assert log.status == CustomerSyncLog.StatusType.SUCCESS
    
    def test_update_existing_customer(self, processor):
        """Проверка обновления существующего клиента"""
        # Создать существующего клиента
        existing_user = User.objects.create_user(
            email='existing@example.com',
            password='testpass123',
            onec_id='1C-EXISTING-001',
            first_name='Старое',
            last_name='Имя'
        )
        
        customer_data = {
            'onec_id': '1C-EXISTING-001',
            'email': 'existing@example.com',
            'first_name': 'Новое',
            'last_name': 'Имя',
            'customer_type': 'Опт 2',
        }
        
        user = processor.process_customer(customer_data)
        
        assert user.pk == existing_user.pk
        assert user.first_name == 'Новое'
        assert user.last_name == 'Имя'
        assert user.role == 'wholesale_level2'
        
        # Проверка логирования
        log = CustomerSyncLog.objects.filter(onec_id='1C-EXISTING-001').first()
        assert log.operation_type == CustomerSyncLog.OperationType.UPDATED
    
    def test_create_customer_without_email(self, processor):
        """Проверка создания клиента без email"""
        customer_data = {
            'onec_id': '1C-NO-EMAIL-001',
            'email': '',  # Пустой email
            'first_name': 'Иван',
            'last_name': 'Без Email',
            'customer_type': 'Опт 1',
        }
        
        user = processor.process_customer(customer_data)
        
        # Клиент должен быть создан с пустым email
        assert user is not None
        assert user.onec_id == '1C-NO-EMAIL-001'
        assert user.email == ''
        assert user.role == 'wholesale_level1'
        
        # Проверка логирования warning
        log = CustomerSyncLog.objects.filter(onec_id='1C-NO-EMAIL-001').first()
        assert log.operation_type == CustomerSyncLog.OperationType.CREATED
        assert log.status == CustomerSyncLog.StatusType.SUCCESS
        assert 'warning' in log.details.get('notes', '').lower()
    
    def test_skip_invalid_email_format(self, processor):
        """Проверка пропуска клиента с невалидным форматом email"""
        customer_data = {
            'onec_id': '1C-INVALID-001',
            'email': 'invalid-email-format',  # Невалидный формат
            'first_name': 'Тест',
            'last_name': 'Тестов',
        }
        
        user = processor.process_customer(customer_data)
        
        assert user is None
        
        # Проверка логирования ошибки
        log = CustomerSyncLog.objects.filter(onec_id='1C-INVALID-001').first()
        assert log.operation_type == CustomerSyncLog.OperationType.ERROR
        assert log.status == CustomerSyncLog.StatusType.FAILED
        assert 'email' in log.error_message.lower()
```

**Integration-тесты для команды:**

**Расположение:** `backend/tests/integration/test_management_commands/test_import_customers.py`

```python
import pytest
from django.core.management import call_command
from django.contrib.auth import get_user_model
from apps.common.models import ImportSession, CustomerSyncLog

User = get_user_model()


@pytest.mark.django_db
@pytest.mark.integration
class TestImportCustomersCommand:
    """Integration-тесты для команды import_customers_from_1c"""
    
    def test_command_imports_customers(self, tmp_path):
        """Проверка успешного импорта клиентов"""
        # Создать тестовый XML
        xml_file = tmp_path / "customers.xml"
        xml_file.write_text("""<?xml version="1.0" encoding="UTF-8"?>
        <customers>
          <customer>
            <id>1C-001</id>
            <email>customer1@example.com</email>
            <first_name>Иван</first_name>
            <last_name>Петров</last_name>
            <customer_type>Опт 1</customer_type>
          </customer>
          <customer>
            <id>1C-002</id>
            <email>customer2@example.com</email>
            <first_name>Петр</first_name>
            <last_name>Иванов</last_name>
            <customer_type>Тренерская</customer_type>
          </customer>
        </customers>
        """, encoding='utf-8')
        
        # Запустить команду
        call_command('import_customers_from_1c', file=str(xml_file))
        
        # Проверить результат
        assert User.objects.filter(onec_id='1C-001').exists()
        assert User.objects.filter(onec_id='1C-002').exists()
        
        user1 = User.objects.get(onec_id='1C-001')
        assert user1.email == 'customer1@example.com'
        assert user1.role == 'wholesale_level1'
        
        user2 = User.objects.get(onec_id='1C-002')
        assert user2.role == 'trainer'
        
        # Проверить сессию
        session = ImportSession.objects.latest('started_at')
        assert session.status == ImportSession.ImportStatus.COMPLETED
        assert session.import_type == ImportSession.ImportType.CUSTOMERS
        assert session.details['total'] == 2
        assert session.details['created'] == 2
    
    def test_command_dry_run(self, tmp_path):
        """Проверка dry-run режима"""
        xml_file = tmp_path / "customers.xml"
        xml_file.write_text("""<?xml version="1.0" encoding="UTF-8"?>
        <customers>
          <customer>
            <id>1C-DRY-001</id>
            <email>dryrun@example.com</email>
            <first_name>Тест</first_name>
            <last_name>Драйран</last_name>
            <customer_type>РРЦ</customer_type>
          </customer>
        </customers>
        """, encoding='utf-8')
        
        # Запустить команду в dry-run режиме
        call_command('import_customers_from_1c', file=str(xml_file), dry_run=True)
        
        # Проверить, что данные НЕ сохранены
        assert not User.objects.filter(onec_id='1C-DRY-001').exists()
        assert not ImportSession.objects.filter(
            import_type=ImportSession.ImportType.CUSTOMERS
        ).exists()
    
    def test_command_handles_errors(self, tmp_path):
        """Проверка обработки ошибок"""
        xml_file = tmp_path / "invalid.xml"
        xml_file.write_text("<invalid>")
        
        with pytest.raises(Exception):
            call_command('import_customers_from_1c', file=str(xml_file))
        
        # Проверить, что сессия помечена как failed
        session = ImportSession.objects.latest('started_at')
        assert session.status == ImportSession.ImportStatus.FAILED
        assert session.error_message != ''
```

**Тестовые данные:**

- Создать тестовые XML-файлы с различными сценариями
- Включить клиентов всех типов (физ.лица, юр.лица)
- Включить пограничные случаи (пустые поля, невалидные данные)
- Расположение: `backend/tests/fixtures/1c-data/customers/`

**Критерии успеха тестирования:**

- Покрытие кода ≥90% для критических модулей
- Все edge cases обработаны корректно
- Performance тесты подтверждают обработку ≥1000 клиентов за приемлемое время
- Интеграционные тесты проходят с реальными данными из 1С

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.0 | Initial draft | Product Owner |
| 2025-10-11 | 1.1 | Приведено к формату story-tmpl.yaml, исправлено название команды на import_customers_from_1c | Product Owner |
| 2025-10-11 | 1.2 | Фаза 1 исправлений: уточнены зависимости, добавлены полные структуры User и CustomerSyncLog | Product Owner |
| 2025-10-11 | 1.3 | Фаза 2 исправлений: добавлена структура команды, примеры тестов, обновлен формат данных на реальную структуру CommerceML 3.1 | Product Owner |
| 2025-10-11 | 1.4 | Фаза 3 завершена: добавлены метрики производительности, рекомендации по оптимизации, информация о concurrent execution | Product Owner |
| 2025-10-11 | 1.5 | Post-validation improvements: добавлена структура CustomerDataParser с сигнатурами методов, уточнена обработка email для физ.лиц (опционален), расширена структура CustomerDataProcessor | Product Owner |
| 2025-10-11 | 1.6 | Email опционален для ВСЕХ типов клиентов: обновлена логика валидации, User.email с blank=True, добавлен тест для клиентов без email, обновлены Edge Cases | Product Owner |

---

## Dev Agent Record

### Agent Model Used

Будет заполнено агентом разработки при реализации

### Debug Log References

Будет заполнено агентом разработки при реализации

### Completion Notes

Будет заполнено агентом разработки при реализации

### File List

Будет заполнено агентом разработки при реализации

---

## QA Results

Будет заполнено QA агентом после завершения реализации

---

## Definition of Done

- [ ] Импортированы тестовые клиенты всех типов
- [ ] Все клиенты получили корректные роли и цены
- [ ] Нет дубликатов в системе
- [ ] Логирование работает корректно через `CustomerSyncLog` и `ImportSession`
- [ ] Реальная интеграция с файлами от 1С
- [ ] Созданы тесты для всех сценариев

---

## Story Points

**13** (High complexity due to new architecture, role mapping and validation)

## Priority

**High** - Критично для B2B функциональности

## Labels

`epic-3` `1c-integration` `customer-sync` `role-mapping` `b2b` `refactoring

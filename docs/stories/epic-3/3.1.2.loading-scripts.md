# Story 3.1.2: loading-scripts

## Status

Ready for Development

## Story

**As a** системный администратор,
**I want** иметь простые команды для загрузки данных,
**so that** я могу управлять процессом импорта из 1С.

## Acceptance Criteria

1. Созданы management-команды `load_test_catalog` и `load_catalog` с параметрами управления.
2. Поддержана загрузка категорий с иерархией.
3. Созданы связи между товарами, категориями и брендами.
4. Реализована обработка дубликатов товаров.
5. Добавлен прогресс-бар для долгих операций.
6. Создан скрипт резервного копирования `backup_db`.

### Детальные задачи

- [x] **Создать команду-заглушку `load_test_catalog` (AC: 1)**
  - [ ] Создать каркас команды с базовыми help-параметрами.
  - [ ] **Для генерации тестовых данных (AC: 1):**
    - [ ] Реализовать параметр `--count` для указания количества товаров.
    - [ ] Реализовать флаг `--with-brands` для создания тестовых брендов.
    - [ ] Реализовать флаг `--with-categories` для создания тестовых категорий.
    - [ ] Реализовать флаг `--clear-existing` для очистки старых тестовых данных.
    - [ ] Реализовать флаг `--dry-run` для тестового запуска без записи в БД.

- [ ] **Создать/дополнить команду `load_catalog` для импорта реальных данных из XML (AC: 1)**
  - [ ] Реализовать параметр `--file` для указания пути к файлу (`goods.xml`, `offers.xml` и т.д.).
  - [ ] Реализовать параметр `--chunk-size` для управления размером пакетов при импорте.
  - [ ] Реализовать флаг `--skip-validation` для ускорения импорта.
  - [ ] **Интегрировать сервисы `XMLDataParser` и `ProductDataProcessor`** для основной логики.
  - [ ] Реализовать создание `ImportSession` в начале и ее закрытие в конце импорта.

- [ ] **Реализовать загрузку категорий с иерархией (AC: 2) - для реальных данных**
  - [ ] Создать парсер для иерархии из `groups.xml`.
  - [ ] Обеспечить поддержку многоуровневой вложенности.
  - [x] ~~Создать/обновить модель `Category`~~ (Выполнено в рамках Task 3.1.1-A).
  - [ ] Реализовать валидацию циклических ссылок в категориях.

- [ ] **Настроить связи между сущностями (AC: 3) - для реальных данных**
  - [x] ~~Product ↔ Category/Brand связи (foreign key)~~ (Выполнено в рамках Task 3.1.1-A).
  - [ ] Реализовать логику автоматического создания `Brand` из файла свойств.
  - [ ] Реализовать логику обработки отсутствующих связанных объектов (например, логгирование).

- [ ] **Обработать дубликаты товаров (AC: 4) - для реальных данных**
  - [ ] Реализовать поиск дубликатов по `onec_id` (`get_or_create` или `update_or_create`).
  - [ ] Определить и реализовать стратегию `merge vs replace` для дубликатов.
    - **Решение Architect (22.09.2025):** Использовать стратегию `merge` (обновление по `onec_id`).
  - [ ] Обеспечить валидацию целостности после обработки дубликатов.

- [ ] **Добавить прогресс-бар (AC: 5)**
  - [ ] Использовать `tqdm` для визуального прогресса в обеих командах.
  - [ ] Логировать ключевые этапы обработки (начало/конец парсинга, записи в БД).
  - [ ] Показывать базовую статистику обработки (создано/обновлено/пропущено).

- [ ] **Создать backup скрипт (AC: 6)**
  - [ ] Создать команду `backup_db`.
    - **Решение Architect (22.09.2025):** Бэкапы сохраняются в `backend/backup_db/`. Директория добавлена в `.gitignore`.
  - [ ] Реализовать автоматический вызов бэкапа перед каждым полным импортом.
  - [ ] Настроить ротацию backup-файлов.
    - **Решение Architect (22.09.2025):** Хранить последние 3 копии.

## Definition of Done

- [ ] Команды работают без ошибок на тестовых данных
- [ ] Импорт 1000+ товаров завершается за <5 минут
- [ ] Сохраняется резервная копия перед каждым импортом
- [ ] Все edge cases обработаны корректно
- [ ] Создана документация по использованию команд

## Dev Notes

### Story Context

**Existing System Integration:**

- Интегрируется с: [`docs/stories/epic-3/3.1.1.import-products-structure.md`](docs/stories/epic-3/3.1.1.import-products-structure.md)
- Технология: Django Management Commands + bulk operations
- Следует паттерну: FREESPORT data management
- Точки касания: Product, Category, Brand models

### Environment Variables

Для работы команд импорта потребуются следующие переменные окружения:

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3

# Настройки бэкапов
BACKUP_RETENTION_DAYS=30
BACKUP_COMPRESSION=true

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

Эти переменные должны быть добавлены в [`backend/.env.example`](backend/.env.example) для удобства настройки окружения.

### Performance Requirements

```python
# Bulk operations для производительности
Product.objects.bulk_create(products_batch, batch_size=100)
Product.objects.bulk_update(products_batch, fields=['name', 'price'])

# Progress tracking
from tqdm import tqdm
for batch in tqdm(product_batches, desc="Loading products"):
    process_batch(batch)
```

### Implementation Examples

#### Структура команды `load_test_catalog`

```python
# backend/apps/products/management/commands/load_test_catalog.py
import random
from django.core.management.base import BaseCommand
from django.db import transaction
from tqdm import tqdm
from apps.products.factories import ProductFactory, CategoryFactory, BrandFactory
from apps.products.models import Product, Category, Brand

class Command(BaseCommand):
    help = 'Генерирует тестовые данные для каталога товаров'
    
    def add_arguments(self, parser):
        parser.add_argument('--count', type=int, default=100,
                          help='Количество товаров для генерации')
        parser.add_argument('--with-brands', action='store_true',
                          help='Создавать тестовые бренды')
        parser.add_argument('--with-categories', action='store_true',
                          help='Создавать тестовые категории')
        parser.add_argument('--clear-existing', action='store_true',
                          help='Очистить существующие тестовые данные')
        parser.add_argument('--dry-run', action='store_true',
                          help='Показать что будет создано без реального создания')
    
    def handle(self, *args, **options):
        count = options['count']
        with_brands = options['with_brands']
        with_categories = options['with_categories']
        clear_existing = options['clear_existing']
        dry_run = options['dry_run']
        
        if dry_run:
            self.stdout.write(f'DRY RUN: Would create {count} test products')
            if with_brands:
                self.stdout.write('DRY RUN: Would create test brands')
            if with_categories:
                self.stdout.write('DRY RUN: Would create test categories')
            return
        
        if clear_existing:
            self.stdout.write('Clearing existing test data...')
            Product.objects.all().delete()
            if with_brands:
                Brand.objects.all().delete()
            if with_categories:
                Category.objects.all().delete()
        
        # Создаем категории если нужно
        categories = []
        if with_categories:
            self.stdout.write('Creating test categories...')
            for i in tqdm(range(10), desc="Creating categories"):
                categories.append(CategoryFactory())
        
        # Создаем бренды если нужно
        brands = []
        if with_brands:
            self.stdout.write('Creating test brands...')
            for i in tqdm(range(20), desc="Creating brands"):
                brands.append(BrandFactory())
        
        # Создаем товары
        self.stdout.write(f'Creating {count} test products...')
        for i in tqdm(range(count), desc="Creating products"):
            kwargs = {}
            if with_brands and brands:
                kwargs['brand'] = random.choice(brands)
            if with_categories and categories:
                kwargs['category'] = random.choice(categories)
            
            ProductFactory(**kwargs)
        
        self.stdout.write(self.style.SUCCESS(f'Successfully created {count} test products'))
```

#### Структура команды `load_catalog`

```python
# backend/apps/products/management/commands/load_catalog.py
import os
import time
from datetime import datetime
from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from tqdm import tqdm
from apps.products.services.parser import XMLDataParser
from apps.products.services.processor import ProductDataProcessor
from apps.products.models import ImportSession

class Command(BaseCommand):
    help = 'Импортирует данные каталога из XML файлов 1С'
    
    def add_arguments(self, parser):
        parser.add_argument('--file', type=str, required=True,
                          help='Путь к XML файлу для импорта')
        parser.add_argument('--chunk-size', type=int, default=1000,
                          help='Размер пакета для обработки')
        parser.add_argument('--skip-validation', action='store_true',
                          help='Пропустить валидацию данных для ускорения')
        parser.add_argument('--dry-run', action='store_true',
                          help='Тестовый запуск без записи в БД')
    
    def handle(self, *args, **options):
        file_path = options['file']
        chunk_size = options['chunk_size']
        skip_validation = options['skip_validation']
        dry_run = options['dry_run']
        
        if not os.path.exists(file_path):
            raise CommandError(f'File not found: {file_path}')
        
        # Создаем сессию импорта
        session = ImportSession.objects.create(
            import_type=ImportSession.ImportType.CATALOG,
            status=ImportSession.ImportStatus.STARTED,
            started_at=datetime.now()
        )
        
        try:
            self.stdout.write(f'Processing file: {file_path}')
            
            # Парсим XML файл
            parser = XMLDataParser()
            start_time = time.time()
            self.stdout.write('Parsing XML file...')
            
            with open(file_path, 'r', encoding='utf-8') as f:
                raw_data = parser.parse(f)
            
            parse_time = time.time() - start_time
            self.stdout.write(f'Parsed {len(raw_data)} items in {parse_time:.2f} seconds')
            
            if dry_run:
                self.stdout.write(f'DRY RUN: Would process {len(raw_data)} items')
                for item in raw_data[:5]:  # Показываем первые 5 элементов
                    self.stdout.write(f'  - {item}')
                return
            
            # Обрабатываем данные
            processor = ProductDataProcessor(
                session_id=session.id,
                skip_validation=skip_validation,
                chunk_size=chunk_size
            )
            
            start_time = time.time()
            self.stdout.write('Processing data...')
            
            results = processor.process_data(raw_data)
            
            process_time = time.time() - start_time
            self.stdout.write(f'Processed data in {process_time:.2f} seconds')
            
            # Обновляем сессию импорта
            session.status = ImportSession.ImportStatus.COMPLETED
            session.finished_at = datetime.now()
            session.report_details = {
                'total_items': len(raw_data),
                'created': results.get('created', 0),
                'updated': results.get('updated', 0),
                'skipped': results.get('skipped', 0),
                'errors': results.get('errors', 0),
                'parse_time': parse_time,
                'process_time': process_time
            }
            session.save()
            
            self.stdout.write(self.style.SUCCESS(
                f'Import completed: {results.get("created", 0)} created, '
                f'{results.get("updated", 0)} updated, '
                f'{results.get("skipped", 0)} skipped'
            ))
            
        except Exception as e:
            session.status = ImportSession.ImportStatus.FAILED
            session.finished_at = datetime.now()
            session.error_message = str(e)
            session.save()
            
            self.stdout.write(self.style.ERROR(f'Import failed: {e}'))
            raise
```

#### Структура команды `backup_db`

```python
# backend/apps/products/management/commands/backup_db.py
import os
import subprocess
import glob
from datetime import datetime
from django.core.management.base import BaseCommand
from django.conf import settings

class Command(BaseCommand):
    help = 'Создает резервную копию базы данных'
    
    def handle(self, *args, **options):
        # Определяем директорию для бэкапов
        backup_dir = getattr(settings, 'BACKUP_DIR', 'backend/backup_db')
        os.makedirs(backup_dir, exist_ok=True)
        
        # Создаем имя файла бэкапа
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = os.path.join(backup_dir, f'backup_{timestamp}.sql')
        
        # Получаем настройки базы данных
        db_settings = settings.DATABASES['default']
        
        # Формируем команду для создания бэкапа
        if db_settings['ENGINE'] == 'django.db.backends.postgresql':
            cmd = [
                'pg_dump',
                '--host', db_settings['HOST'],
                '--port', str(db_settings['PORT']),
                '--username', db_settings['USER'],
                '--dbname', db_settings['NAME'],
                '--no-password',
                '--file', backup_file
            ]
            
            # Устанавливаем переменную окружения для пароля
            env = os.environ.copy()
            env['PGPASSWORD'] = db_settings['PASSWORD']
        else:
            raise Exception(f'Unsupported database engine: {db_settings["ENGINE"]}')
        
        try:
            self.stdout.write(f'Creating backup: {backup_file}')
            
            # Выполняем команду
            subprocess.run(cmd, env=env, check=True)
            
            self.stdout.write(self.style.SUCCESS(f'Backup created: {backup_file}'))
            
            # Ротация бэкапов (хранение последних 3)
            self._rotate_backups(backup_dir)
            
        except subprocess.CalledProcessError as e:
            self.stdout.write(self.style.ERROR(f'Backup failed: {e}'))
            raise
    
    def _rotate_backups(self, backup_dir):
        """Хранит только последние 3 бэкапа"""
        backup_files = glob.glob(os.path.join(backup_dir, 'backup_*.sql'))
        backup_files.sort(reverse=True)  # Сортируем по убыванию (новые первые)
        
        # Удаляем старые бэкапы, оставляя только 3 последних
        for backup_file in backup_files[3:]:
            os.remove(backup_file)
            self.stdout.write(f'Removed old backup: {backup_file}')
```

### Command Usage Examples

```bash
# Генерация тестовых данных
python manage.py load_test_catalog --count=1000 --with-brands --with-categories --clear-existing

# Загрузка основного каталога товаров из реального файла
python manage.py load_catalog --file="backend/tests/legacy/Обмен с сайтом/goods/goods.xml"

# Загрузка торговых предложений (остатки, цены)
python manage.py load_catalog --file="backend/tests/legacy/Обмен с сайтом/offers/offers.xml" --chunk-size=500

# Тестовый запуск импорта без записи в БД
python manage.py load_catalog --file="backend/tests/legacy/Обмен с сайтом/goods/goods.xml" --dry-run

# Создание резервной копии базы данных
python manage.py backup_db
```

### Key Test Scenarios

Для обеспечения качества реализации команд импорта необходимо покрыть следующие тестовые сценарии:

#### Unit-тесты для `load_test_catalog`

```python
# tests/unit/test_management_commands/test_load_test_catalog.py
import pytest
from io import StringIO
from django.core.management import call_command
from django.core.management.base import CommandError
from apps.products.factories import ProductFactory, CategoryFactory, BrandFactory

@pytest.mark.unit
class TestLoadTestCatalogCommand:
    def test_command_with_count_parameter(self):
        """Тест параметра --count для указания количества товаров"""
        out = StringIO()
        call_command('load_test_catalog', '--count=5', stdout=out)
        assert 'Created 5 test products' in out.getvalue()
        assert Product.objects.count() == 5
    
    def test_command_with_brands_flag(self):
        """Тест флага --with-brands для создания тестовых брендов"""
        out = StringIO()
        call_command('load_test_catalog', '--count=1', '--with-brands', stdout=out)
        assert Brand.objects.exists()
    
    def test_command_with_categories_flag(self):
        """Тест флага --with-categories для создания тестовых категорий"""
        out = StringIO()
        call_command('load_test_catalog', '--count=1', '--with-categories', stdout=out)
        assert Category.objects.exists()
    
    def test_command_with_clear_existing_flag(self):
        """Тест флага --clear-existing для очистки старых тестовых данных"""
        # Создаем существующие данные
        ProductFactory.create_batch(3)
        assert Product.objects.count() == 3
        
        # Запускаем команду с флагом очистки
        out = StringIO()
        call_command('load_test_catalog', '--count=2', '--clear-existing', stdout=out)
        assert Product.objects.count() == 2
    
    def test_command_with_dry_run_flag(self):
        """Тест флага --dry-run для тестового запуска без записи в БД"""
        initial_count = Product.objects.count()
        out = StringIO()
        call_command('load_test_catalog', '--count=5', '--dry-run', stdout=out)
        assert 'Would create 5 test products' in out.getvalue()
        assert Product.objects.count() == initial_count
```

#### Unit-тесты для `load_catalog`

```python
# tests/unit/test_management_commands/test_load_catalog.py
import pytest
import tempfile
import os
from io import StringIO
from django.core.management import call_command, CommandError
from unittest.mock import patch, Mock

@pytest.mark.unit
class TestLoadCatalogCommand:
    def test_command_with_file_parameter(self):
        """Тест параметра --file для указания пути к файлу"""
        # Создаем временный XML файл
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(b'<test><products></products></test>')
            tmp_file_path = tmp_file.name
        
        try:
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', stdout=out)
            assert 'Processing file' in out.getvalue()
        finally:
            os.unlink(tmp_file_path)
    
    def test_command_with_chunk_size_parameter(self):
        """Тест параметра --chunk-size для управления размером пакетов"""
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(b'<test><products></products></test>')
            tmp_file_path = tmp_file.name
        
        try:
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', '--chunk-size=100', stdout=out)
            assert 'Using chunk size: 100' in out.getvalue()
        finally:
            os.unlink(tmp_file_path)
    
    def test_command_with_skip_validation_flag(self):
        """Тест флага --skip-validation для ускорения импорта"""
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(b'<test><products></products></test>')
            tmp_file_path = tmp_file.name
        
        try:
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', '--skip-validation', stdout=out)
            assert 'Skipping validation' in out.getvalue()
        finally:
            os.unlink(tmp_file_path)
    
    def test_command_creates_import_session(self):
        """Тест создания ImportSession в начале импорта"""
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(b'<test><products></products></test>')
            tmp_file_path = tmp_file.name
        
        try:
            from apps.products.models import ImportSession
            initial_count = ImportSession.objects.count()
            
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', stdout=out)
            
            assert ImportSession.objects.count() == initial_count + 1
            session = ImportSession.objects.latest('started_at')
            assert session.import_type == 'catalog'
        finally:
            os.unlink(tmp_file_path)
    
    def test_command_handles_invalid_file(self):
        """Тест обработки некорректного файла"""
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(b'invalid xml content')
            tmp_file_path = tmp_file.name
        
        try:
            with pytest.raises(CommandError):
                call_command('load_catalog', f'--file={tmp_file_path}')
        finally:
            os.unlink(tmp_file_path)
```

#### Интеграционные тесты для команд управления

```python
# tests/integration/test_management_commands/test_load_catalog.py
import pytest
import tempfile
import os
from io import StringIO
from django.core.management import call_command
from apps.products.factories import ProductFactory, CategoryFactory, BrandFactory
from apps.products.models import ImportSession

@pytest.mark.django_db
@pytest.mark.integration
class TestLoadCatalogCommandIntegration:
    def test_full_import_workflow(self):
        """Тест полного цикла импорта товаров из XML"""
        # Создаем временный XML файл с тестовыми данными
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(generate_test_xml(10))
            tmp_file_path = tmp_file.name
        
        try:
            initial_count = Product.objects.count()
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', stdout=out)
            
            # Проверяем что товары были созданы
            assert Product.objects.count() == initial_count + 10
            
            # Проверяем что сессия импорта была создана и завершена
            session = ImportSession.objects.latest('started_at')
            assert session.status == ImportSession.ImportStatus.COMPLETED
            assert session.report_details['created'] == 10
        finally:
            os.unlink(tmp_file_path)
    
    def test_import_with_existing_products_updates_them(self):
        """Тест импорта с обновлением существующих товаров"""
        # Создаем существующий товар
        existing_product = ProductFactory(onec_id='TEST_001', name='Old Name')
        
        # Создаем XML с тем же onec_id но другими данными
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            tmp_file.write(generate_test_xml_with_existing_id('TEST_001', 'New Name'))
            tmp_file_path = tmp_file.name
        
        try:
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', stdout=out)
            
            # Проверяем что товар был обновлен
            existing_product.refresh_from_db()
            assert existing_product.name == 'New Name'
            
            # Проверяем статистику в сессии импорта
            session = ImportSession.objects.latest('started_at')
            assert session.report_details['updated'] >= 1
        finally:
            os.unlink(tmp_file_path)
```

#### Тесты изоляции и генерации уникальных данных

```python
# tests/unit/test_management_commands/test_isolation.py
import pytest
from io import StringIO
from django.core.management import call_command
from apps.products.factories import ProductFactory

@pytest.mark.unit
class TestCommandIsolation:
    def test_commands_use_unique_data_generation(self):
        """Тест что команды используют уникальную генерацию данных"""
        # Запускаем команду дважды с одинаковыми параметрами
        out1 = StringIO()
        call_command('load_test_catalog', '--count=5', '--with-brands', stdout=out1)
        
        out2 = StringIO()
        call_command('load_test_catalog', '--count=5', '--with-brands', stdout=out2)
        
        # Проверяем что общее количество товаров удвоилось
        assert Product.objects.count() == 10
```

#### Тесты для backup команды

```python
# tests/unit/test_management_commands/test_backup_db.py
import pytest
import os
import tempfile
from io import StringIO
from django.core.management import call_command
from django.test import override_settings

@pytest.mark.unit
class TestBackupDbCommand:
    @override_settings(BACKUP_DIR=tempfile.gettempdir())
    def test_backup_creates_file(self):
        """Тест создания файла бэкапа"""
        out = StringIO()
        call_command('backup_db', stdout=out)
        
        assert 'Backup created successfully' in out.getvalue()
        # Проверяем что файл бэкапа существует
        assert len(os.listdir(tempfile.gettempdir())) > 0
    
    @override_settings(BACKUP_DIR=tempfile.gettempdir())
    def test_backup_rotation(self):
        """Тест ротации бэкапов (хранение последних 3 копий)"""
        # Создаем 4 файла бэкапа
        for i in range(4):
            out = StringIO()
            call_command('backup_db', stdout=out)
        
        # Проверяем что хранится только 3 последних файла
        backup_files = [f for f in os.listdir(tempfile.gettempdir()) if f.startswith('backup_')]
        assert len(backup_files) == 3
```

#### Performance тесты

```python
# tests/performance/test_import_performance.py
import pytest
import time
from io import StringIO
from django.core.management import call_command
from django.test import override_settings

@pytest.mark.slow
class TestImportPerformance:
    @override_settings(BACKUP_DIR=tempfile.gettempdir())
    def test_import_1000_products_within_timeout(self):
        """Тест импорта 1000 товаров в допустимое время (<5 минут)"""
        # Создаем временный XML файл с тестовыми данными
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as tmp_file:
            # Генерируем XML с 1000 товарами
            tmp_file.write(generate_test_xml(1000))
            tmp_file_path = tmp_file.name
        
        try:
            start_time = time.time()
            out = StringIO()
            call_command('load_catalog', f'--file={tmp_file_path}', stdout=out)
            end_time = time.time()
            
            # Проверяем что импорт завершился менее чем за 5 минут
            assert end_time - start_time < 300, f"Import took {end_time - start_time} seconds, expected < 300"
            assert 'Import completed successfully' in out.getvalue()
        finally:
            os.unlink(tmp_file_path)
```

### Dependencies

- **Depends on:** [`docs/stories/epic-3/3.1.1.import-products-structure.md`](docs/stories/epic-3/3.1.1.import-products-structure.md)
- **Blocks:** [`docs/stories/epic-3/3.1.3.test-catalog-loading.md`](docs/stories/epic-3/3.1.3.test-catalog-loading.md)
- **Related:** [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md)

## Story Points

**5** (Medium complexity, mostly configuration)

## Priority

**High** - Необходимо для тестовой загрузки данных

## Labels

`epic-3` `data-management` `django-commands` `performance`

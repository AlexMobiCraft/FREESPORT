# История 3.1.5: Команда для обновления остатков товаров

**Эпик:** 3. Интеграция с 1С
**Приоритет:** Высокий

## 1. Описание

Как системный администратор, я хочу иметь возможность запускать легковесную и быструю команду `load_product_stocks` для обновления только остатков товаров. Это позволит поддерживать информацию о наличии на сайте максимально актуальной. Каждая такая операция должна быть атомарной и логироваться в отдельной сессии `ImportSession` для последующего анализа.

## 2. Критерии приемки (Acceptance Criteria)

1. Создана management-команда `load_product_stocks` с необходимыми параметрами.
2. Команда использует `XMLDataParser` для чтения данных из файла `rests.xml`.
3. Обновление остатков происходит в рамках атомарной транзакции и использует `bulk_update` для производительности.
4. Команда корректно создает и обновляет `ImportSession` для логирования операции.

## 3. Техническое задание для разработки

- [ ] **Создать команду `load_product_stocks` (AC: 1, 2, 3, 4)**
  - **Расположение:** `backend/apps/products/management/commands/load_product_stocks.py`
  - **Аргументы:** Команда должна принимать обязательный аргумент `--file` (путь к файлу `rests.xml`).
  - **Логика работы:**
    1. В начале выполнения создать экземпляр `ImportSession` с `import_type='stocks'` и `status='started'`. (AC: 4)
    2. Вся логика обновления должна быть обернута в `with transaction.atomic():`. (AC: 3)
    3. Использовать `XMLDataParser` (созданный в Story 3.1.1) для чтения `rests.xml` и получения данных. (AC: 2)
       - **Расположение парсера:** `backend/apps/products/services/parser.py`
       - **Структура rests.xml:** [docs/architecture/20-1c-integration.md](docs/architecture/20-1c-integration.md) (Приложение А, раздел А.2.5)
    4. Для каждой записи найти товар `Product` по `sku` (или `onec_id`).
       - **Варианты обработки, если товар не найден:**
         - **Вариант 1 (рекомендуемый):** Пропускать с логированием предупреждения в `ImportSession.details`
         - **Вариант 2:** Создавать новый товар с базовыми данными (только если бизнес-требования это допускают)
         - **Вариант 3:** Собирать отдельный отчет для последующего анализа и добавлять в `ImportSession.details`
    5. Массово обновить поле `stock_quantity` найденных товаров, используя `Product.objects.bulk_update()` для производительности. (AC: 3)
    6. В случае ошибки, перехватить исключение, обновить сессию (`status='failed'`, `error_message`) и завершить работу.
    7. В случае успеха, обновить сессию (`status='completed'`, `details` со статистикой) и завершить работу.

**Примерная структура команды:**

```python
# backend/apps/products/management/commands/load_product_stocks.py

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from apps.products.models import Product
from apps.common.models import ImportSession # Модель уже существует
# Предполагается, что парсер тоже существует
from apps.products.services.parser import XMLDataParser

class Command(BaseCommand):
    help = "Обновляет остатки товаров из файла rests.xml."

    def add_arguments(self, parser):
        parser.add_argument('--file', type=str, required=True, help='Путь к файлу rests.xml.')

    def handle(self, *args, **options):
        file_path = options['file']
        
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.STOCKS)
        self.stdout.write(f"Начата сессия обновления остатков #{session.pk}...")

        updated_count = 0
        not_found_count = 0
        not_found_skus = []  # Список SKU, которые не найдены
        
        try:
            parser = XMLDataParser()
            stock_data = parser.parse(file_path)
            
            with transaction.atomic():
                # Подготовка списка для обновления
                products_to_update = []
                
                for item in stock_data:
                    # Поиск товара по SKU или onec_id
                    product = None
                    sku = item.get('sku')
                    onec_id = item.get('onec_id')
                    
                    if sku:
                        product = Product.objects.filter(sku=sku).first()
                    if not product and onec_id:
                        product = Product.objects.filter(onec_id=onec_id).first()
                    
                    if product:
                        product.stock_quantity = item.get('quantity', 0)
                        products_to_update.append(product)
                        updated_count += 1
                    else:
                        not_found_count += 1
                        not_found_skus.append(sku or onec_id)
                        # Вариант 1: Пропускаем с логированием (рекомендуемый)
                        self.stdout.write(self.style.WARNING(f"Товар не найден: {sku or onec_id}"))
                        # Вариант 2: Создание нового товара (требует дополнительной логики)
                        # Вариант 3: Добавление в отчет для последующего анализа
                
                # Массовое обновление найденных товаров
                if products_to_update:
                    Product.objects.bulk_update(products_to_update, ['stock_quantity'])

            session.status = ImportSession.ImportStatus.COMPLETED
            session.details = {
                'updated_count': updated_count,
                'not_found_count': not_found_count,
                'not_found_skus': not_found_skus,  # Для последующего анализа
            }
            self.stdout.write(self.style.SUCCESS("Обновление остатков успешно завершено."))

        except Exception as e:
            session.status = ImportSession.ImportStatus.FAILED
            session.error_message = str(e)
            self.stderr.write(self.style.ERROR(f"Ошибка во время обновления: {e}"))
        
        finally:
            session.finished_at = timezone.now()
            session.save()
            self.stdout.write(f"Сессия #{session.pk} завершена со статусом '{session.status}'.")
```

## 4. Примечания по реализации

- **Рекомендуемый подход к обработке отсутствующих товаров:** Вариант 1 (пропуск с логированием) является предпочтительным для первоначальной реализации, так как он обеспечивает максимальную стабильность процесса импорта и позволяет быстро обнаруживать проблемы с данными в 1С.
- **Расширение функционала в будущем:** Варианты 2 и 3 могут быть реализованы как дополнительные параметры команды (например, `--create-missing` или `--generate-report`) по мере развития бизнес-требований.
- **Производительность:** Использование `bulk_update` с пакетной обработкой (например, по 1000 записей за раз) рекомендуется для больших файлов остатков.

## 5. Dependencies

- **Depends on:** Story 3.1.1 (модель `ImportSession`, `XMLDataParser`)
- **Blocks:** -
- **Related:** Отображение остатков в API продукта

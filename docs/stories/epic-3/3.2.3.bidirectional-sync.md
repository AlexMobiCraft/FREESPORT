# Story 3.2.3: bidirectional-sync

## Status

Blocked

## Story

> **Примечание Architect (22.09.2025):** Реализация заблокирована до получения спецификации API для экспорта данных в 1С. Начать работу после предоставления спецификации.

**As a** новый клиент,
**I want** чтобы моя регистрация на сайте автоматически попадала в 1С,
**so that** я получаю персональные условия и специальные цены.

## Acceptance Criteria

1. Создана команда `sync_customers` для полной двусторонней синхронизации.
2. Новые регистрации и изменения профиля автоматически отправляются на экспорт в 1С.
3. Реализован сервис `export_customer_to_1c`, который обрабатывает ответ от 1С и обновляет данные клиента.
4. Создан `CustomerDataMapper` для преобразования данных между платформой и 1С.
5. Настроена обработка ошибок экспорта с механизмом повторных попыток (retry).

### Детальные задачи

- [ ] **Создать команду полной синхронизации `sync_customers` (AC: 1)**
  - [ ] Расположить в `apps/users/management/commands/`.
  - [ ] Реализовать параметры: `--direction` (import/export/both), `--chunk-size`.
  - [ ] Команда должна оркестрировать вызов `CustomerDataProcessor` для импорта и экспорта.
  - [ ] Интегрировать с Celery для выполнения тяжелых операций в фоне.

- [ ] **Настроить флаг экспорта при регистрации (AC: 2)**
  - [ ] Использовать сигнал `post_save` для модели `User`.
  - [ ] При создании нового пользователя (если `created=True` и `created_in_1c=False`) устанавливать флаг `needs_1c_export=True`.
  - [ ] Сигнал должен ставить асинхронную задачу в Celery для экспорта, а не выполнять его напрямую.

- [ ] **Реализовать логику экспорта в `CustomerDataProcessor` (AC: 3)**
  - [ ] Добавить метод `export_customer(customer)` в `CustomerDataProcessor`.
  - [ ] Этот метод должен использовать `CustomerDataMapper` для преобразования данных.
  - [ ] Реализовать отправку данных во внешнюю систему (1С).
  - [ ] Проводить валидацию данных перед экспортом.

- [ ] **Обработать ответ от 1С (AC: 3)**
  - [ ] Парсинг ответа с `onec_id`
  - [ ] Обновление статуса `sync_status = 'synced'`
  - [ ] Сброс флага `needs_1c_export = False`
  - [ ] Установка `last_sync_at = timezone.now()`

- [ ] **Синхронизировать изменения профиля (AC: 2)**
  - [ ] Signal `post_save` для отслеживания изменений
  - [ ] Определение значимых полей для синхронизации
  - [ ] Batch обновления для производительности
  - [ ] Деactivация экспорта для незначительных изменений

- [ ] **Создать `CustomerDataMapper` (AC: 4)**
  - [ ] Расположить класс в `apps/users/services/`.
  - [ ] Реализовать метод `map_platform_to_1c(customer)`.
  - [ ] Реализовать метод `map_1c_to_platform(customer_data)`.
  - [ ] Добавить логику нормализации данных (например, форматы дат и телефонов).

- [ ] **Настроить retry и error handling (AC: 5)**
  - [ ] Exponential backoff для retry попыток
  - [ ] Максимальное количество попыток (3-5)
  - [ ] Сохранение ошибок в `sync_error_message`

## Definition of Done

- [ ] Новые регистрации попадают в 1С в течение 15 минут
- [ ] Изменения профиля синхронизируются автоматически
- [ ] Ошибки экспорта не блокируют работу платформы
- [ ] Success rate синхронизации >95%
- [ ] Созданы monitoring dashboards

## Dev Notes

### Story Context

**Место в системе интеграции с 1С:**

Эта история является завершающим компонентом процесса синхронизации клиентов между 1С и платформой:

1. **Импорт клиентов (Story 3.2.1)** - загрузка существующих клиентов из 1С
2. **Разрешение конфликтов (Story 3.2.2)** - обработка дубликатов и несоответствий данных
3. **Двусторонняя синхронизация (эта история)** - автоматическая отправка новых регистраций и изменений в 1С

**Процесс двусторонней синхронизации:**

- Новые регистрации на платформе автоматически экспортируются в 1С
- Изменения профилей на платформе отправляются в 1С
- Обновления статуса клиента и ролей из 1С импортируются на платформу
- Конфликты данных разрешаются автоматически или через админ-панель

**Bidirectional Sync Flow:**

1. **Platform → 1C:** Новые регистрации и изменения профилей
2. **1C → Platform:** Обновления статуса клиента, изменения ролей
3. **Conflict Resolution:** Автоматическое разрешение конфликтов данных

### Технические требования

**Используемые технологии:**

- **Асинхронные задачи:** Celery с Redis брокером для фонового выполнения экспорта
- **HTTP-клиент:** requests для взаимодействия с API 1С
- **Сигналы:** Django signals для отслеживания изменений моделей
- **Маппинг данных:** pydantic для валидации и преобразования данных
- **Мониторинг:** Prometheus + Grafana для метрик синхронизации
- **Логирование:** structlog для структурированного логирования операций

**Переменные окружения:**

- `ONEC_API_URL`: URL эндпоинта API 1С для экспорта клиентов
- `ONEC_API_KEY`: API ключ для аутентификации в 1С
- `ONEC_API_TIMEOUT`: Таймаут запросов к API 1С (по умолчанию: 30 секунд)
- `CELERY_BROKER_URL`: URL брокера сообщений Redis
- `SYNC_RETRY_DELAY`: Задержка между повторными попытками экспорта (по умолчанию: 60 секунд)
- `SYNC_MAX_RETRIES`: Максимальное количество повторных попыток (по умолчанию: 3)
- `SYNC_BATCH_SIZE`: Размер пакета для пакетной обработки (по умолчанию: 100)

**Схемы моделей:**

```python
# Расширение модели User для поддержки двусторонней синхронизации
class User(AbstractUser):
    # ... существующие поля
    
    # Поля для синхронизации с 1С
    onec_id = models.CharField('ID в 1С', max_length=100, blank=True, null=True, unique=True)
    sync_status = models.CharField(
        'Статус синхронизации',
        max_length=20,
        choices=[
            ('pending', 'Ожидает синхронизации'),
            ('synced', 'Синхронизирован'),
            ('error', 'Ошибка синхронизации'),
        ],
        default='pending'
    )
    needs_1c_export = models.BooleanField('Требуется экспорт в 1С', default=False)
    last_sync_at = models.DateTimeField('Последняя синхронизация', null=True, blank=True)
    sync_error_message = models.TextField('Ошибка синхронизации', blank=True)
    created_in_1c = models.BooleanField('Создан в 1С', default=False)
```

### CustomerExportService Architecture

```python
class CustomerExportService:
    """Сервис экспорта клиентов в 1С"""
    
    def export_customer_to_1c(self, customer):
        """Экспорт клиента с платформы в 1С"""
        try:
            # Подготовка данных для экспорта
            export_data = self.prepare_export_data(customer)
            
            # Отправка в 1С
            response = self.send_to_1c(export_data)
            
            # Обработка ответа
            if response.success:
                self.handle_successful_export(customer, response)
            else:
                self.handle_export_error(customer, response)
                
        except Exception as e:
            self.handle_export_exception(customer, e)
    
    def prepare_export_data(self, customer):
        """Подготовка данных клиента для экспорта"""
        mapper = CustomerDataMapper()
        return mapper.map_platform_to_1c(customer)
    
    def handle_successful_export(self, customer, response):
        """Обработка успешного экспорта"""
        customer.onec_id = response.onec_id
        customer.sync_status = 'synced'
        customer.needs_1c_export = False
        customer.last_sync_at = timezone.now()
        customer.sync_error_message = ''
        customer.save()
        
        # Логирование успеха
        CustomerSyncLog.objects.create(
            operation_type='export_to_1c',
            customer=customer,
            status='success',
            details={'onec_id': response.onec_id}
        )
```

### Data Mapping Examples

```python
class CustomerDataMapper:
    """Маппинг данных между форматами платформы и 1С"""
    
    def map_platform_to_1c(self, customer):
        """Преобразование данных клиента в формат 1С"""
        customer_type = 'individual' if not customer.company_name else 'legal_entity'
        
        base_data = {
            'platform_id': customer.id,
            'email': customer.email,
            'phone': self.normalize_phone(customer.phone),
            'customer_type': customer_type,
            'role': self.map_platform_role_to_1c(customer.role),
        }
        
        if customer_type == 'individual':
            base_data.update({
                'first_name': customer.first_name,
                'last_name': customer.last_name,
            })
        else:
            base_data.update({
                'company_name': customer.company_name,
                'tax_id': customer.tax_id,
                'contact_person': f"{customer.first_name} {customer.last_name}",
            })
        
        return base_data
    
    def map_1c_to_platform(self, onec_data):
        """Преобразование данных из 1С в формат платформы"""
        return {
            'email': onec_data.get('email'),
            'first_name': onec_data.get('first_name'),
            'last_name': onec_data.get('last_name'),
            'phone': onec_data.get('phone'),
            'company_name': onec_data.get('company_name'),
            'tax_id': onec_data.get('tax_id'),
            'role': self.map_1c_role_to_platform(onec_data.get('customer_type')),
            'onec_id': onec_data.get('id'),
            'created_in_1c': True,
            'sync_status': 'synced',
        }
```

### Celery Task Integration

```python
@celery_app.task(bind=True, max_retries=3)
def export_customer_task(self, customer_id):
    """Асинхронный экспорт клиента в 1С"""
    try:
        customer = User.objects.get(id=customer_id)
        export_service = CustomerExportService()
        export_service.export_customer_to_1c(customer)
    except User.DoesNotExist:
        logger.error(f"Customer {customer_id} not found for export")
    except Exception as exc:
        logger.error(f"Export failed for customer {customer_id}: {exc}")
        # Retry with exponential backoff
        raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries))

# Trigger export on user registration
@receiver(post_save, sender=User)
def trigger_customer_export(sender, instance, created, **kwargs):
    """Триггер экспорта при создании/изменении пользователя"""
    if instance.needs_1c_export and not instance.created_in_1c:
        export_customer_task.delay(instance.id)
```

### Monitoring & Metrics

```python
# Метрики для мониторинга синхронизации
SYNC_METRICS = {
    'customers_exported_today': lambda: get_customers_exported_today(),
    'export_success_rate': lambda: calculate_export_success_rate(),
    'pending_exports_count': lambda: get_pending_exports_count(),
    'avg_sync_time': lambda: get_average_sync_time(),
}
```

### Dependencies

- **Depends on:** Story 3.2.1, 3.2.2 (import and conflicts)
- **Integrates with:** Celery, 1C API, monitoring system
- **Related:** Real-time sync, webhook handlers

### Информация из предыдущих историй

**Story 3.1.1 (ImportSession model):**

- Модель ImportSession используется для отслеживания сессий импорта/экспорта
- Поля: `import_type`, `status`, `started_at`, `finished_at`, `report_details`, `error_message`
- Типы импорта: `CATALOG`, `STOCKS`, `PRICES`, `CUSTOMERS`
- Статусы: `STARTED`, `COMPLETED`, `FAILED`

**Story 3.2.1 (CustomerDataProcessor):**

- CustomerDataProcessor обрабатывает импорт клиентов из 1С
- Вызывает CustomerConflictResolver при обнаружении конфликтов
- Использует CustomerSyncLog для логирования операций
- Реализует маппинг типов клиентов 1С на роли платформы

**Story 3.2.2 (CustomerConflictResolver):**

- CustomerConflictResolver обрабатывает конфликты при импорте клиентов
- Использует стратегии разрешения конфликтов: merge_by_email, latest_wins, manual_review
- Создает записи в SyncConflict для случаев, требующих ручного вмешательства
- Интегрируется с Django Admin для модерации неразрешенных конфликтов

**Использование в этой истории:**

- CustomerExportService интегрируется с CustomerDataProcessor для двусторонней синхронизации
- Экспорт/импорт логируются в CustomerSyncLog и отслеживаются через ImportSession
- Конфликты при синхронизации обрабатываются через CustomerConflictResolver

### Ссылки на внешние документы

**Архитектурные документы:**

- [`docs/architecture/20-1c-integration.md`](docs/architecture/20-1c-integration.md) - подробное описание интеграции с 1С
- [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md) - стратегия тестирования для асинхронных задач
- [`docs/architecture/02-data-models.md`](docs/architecture/02-data-models.md#user-model) - схема модели User

**Техническая документация:**

- [Celery Documentation](https://docs.celeryproject.org/) - руководство по асинхронным задачам
- [Django Signals](https://docs.djangoproject.com/en/stable/topics/signals/) - документация по сигналам
- [Pydantic](https://pydantic-docs.helpmanual.io/) - валидация данных

### Edge Cases и обработка ошибок

**1. Недоступность API 1С:**

- **Сценарий:** API 1С не отвечает или возвращает ошибку 5xx
- **Решение:** Exponential backoff с максимальным количеством попыток
- **Логирование:** Запись в CustomerSyncLog с типом 'api_unavailable'

**2. Некорректные данные при экспорте:**

- **Сценарий:** Данные клиента не проходят валидацию в 1С
- **Решение:** Сохранение ошибки в sync_error_message, повторная попытка после исправления
- **Логирование:** Запись в CustomerSyncLog с типом 'validation_error'

**3. Конфликт данных при синхронизации:**

- **Сценарий:** Данные клиента изменены в обеих системах между синхронизациями
- **Решение:** Приоритет данным из 1С, создание записи для ручной проверки
- **Логирование:** Запись в CustomerSyncLog с типом 'data_conflict'

**4. Превышение лимита API 1С:**

- **Сценарий:** Превышен лимит запросов к API 1С
- **Решение:** Очередь задач в Celery с автоматической задержкой
- **Логирование:** Запись в CustomerSyncLog с типом 'rate_limit_exceeded'

**5. Ошибка аутентификации в API 1С:**

- **Сценарий:** Неверный API ключ или истекший токен
- **Решение:** Обновление ключа, уведомление администратора
- **Логирование:** Запись в CustomerSyncLog с типом 'auth_error'

**6. Сбой Celery задачи:**

- **Сценарий:** Задача экспорта не выполняется из-за ошибки в коде
- **Решение:** Автоматический retry с логированием стека ошибки
- **Логирование:** Запись в CustomerSyncLog с типом 'task_failure'

**7. Циклическая синхронизация:**

- **Сценарий:** Бесконечный цикл импорта/экспорта одних и тех же данных
- **Решение:** Проверка флага last_sync_at для предотвращения повторной обработки
- **Логирование:** Запись в CustomerSyncLog с типом 'circular_sync'

### Тестирование

**Принципы тестирования (согласно [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md)):**

- **Пирамида тестирования:** Основание - быстрые unit-тесты, середина - интеграционные тесты, вершина - E2E тесты
- **Полная изоляция тестов:** Каждый тест выполняется в изолированной среде с автоматической очисткой
- **Генерация уникальных данных:** Использование комбинированного подхода для избежания конфликтов
- **Маркировка тестов:** Обязательное использование маркеров `@pytest.mark.unit` и `@pytest.mark.integration`

**Подход к тестированию:**

- **Unit-тесты:** Для изолированного тестирования CustomerExportService и CustomerDataMapper
- **Интеграционные тесты:** Для проверки полной системы двусторонней синхронизации
- **Тесты Celery задач:** Для проверки асинхронного выполнения экспорта
- **Тесты API:** Для проверки взаимодействия с API 1С

**Ключевые тестовые сценарии:**

1. **Успешный экспорт нового клиента:**
   - Создание нового пользователя на платформе
   - Проверка установки флага needs_1c_export
   - Проверка создания Celery задачи для экспорта
   - Проверка успешного экспорта в 1С

2. **Экспорт изменений профиля:**
   - Изменение данных существующего пользователя
   - Проверка триггера на сигнал post_save
   - Проверка корректности маппинга данных
   - Проверка обновления данных в 1С

3. **Обработка ошибок экспорта:**
   - Имитация недоступности API 1С
   - Проверка механизма retry с exponential backoff
   - Проверка логирования ошибок
   - Проверка обновления статуса sync_status

4. **Тестирование маппинга данных:**
   - Проверка преобразования данных между форматами
   - Проверка нормализации телефонов и дат
   - Проверка маппинга ролей
   - Проверка обработки пустых полей

5. **Тестирование Celery задач:**
   - Проверка выполнения задачи в фоне
   - Проверка обработки исключений
   - Проверка механизма retry
   - Проверка логирования выполнения

6. **Тестирование конфликтов данных:**
   - Создание конфликта данных между системами
   - Проверка разрешения конфликта
   - Проверка приоритета данных из 1С
   - Проверка создания записи для ручной проверки

**Тестирование асинхронных операций:**

- Использование pytest-celery для тестирования Celery задач
- Мокирование API 1С для изоляции тестов
- Проверка выполнения задач в очереди
- Тестирование обработки таймаутов и ошибок

**Тестовые данные:**

- Создание тестовых пользователей различных типов
- Подготовка моковых ответов от API 1С
- Создание тестовых сценариев конфликтов данных
- Подготовка данных для тестирования retry механизма

**Критерии успеха тестирования:**

- Покрытие кода ≥90% для критических модулей
- Все edge cases обработаны корректно
- Success rate синхронизации ≥95%
- Время обработки экспорта ≤15 минут

**Особые соображения по тестированию:**

- Использование тестовой базы данных Redis для Celery
- Изоляция тестов API 1С с помощью моков
- Тестирование производительности для больших объемов данных
- Проверка работы мониторинговых метрик

## Story Points

**8** (High complexity due to bidirectional sync and API integration)

## Priority

**High** - Ключевая функциональность для B2B клиентов

## Labels

`epic-3` `bidirectional-sync` `1c-integration` `celery` `api-integration`

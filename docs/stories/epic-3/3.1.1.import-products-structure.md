# Story 3.1.1: import-products-structure

## Status

Draft → In Progress

## Story

**As a** разработчик,
**I want** создать систему импорта товаров из 1С,
**so that** каталог автоматически синхронизируется с ERP системой.

## Acceptance Criteria

1. Обновлена модель `Product` и создана модель `ImportSession` для поддержки интеграции.
2. Логика импорта разделена на архитектуру Парсер/Процессор.
3. Создана management-команда `import_catalog_from_1c` с валидацией данных, использующая сессии импорта.
4. Реализована логика обработки ролевого ценообразования.
5. Настроено детальное логирование процесса импорта в `ImportSession`.
6. Написаны unit и integration тесты для всего функционала.

### Детальные задачи

- [ ] **Обновить модели для интеграции (AC: 1)**
  - [ ] В модель `Product` добавить поля: `onec_id`, `sync_status`, `last_sync_at`.
  - [ ] Создать миграцию для модели `Product`.
  
    ```bash
    # Создание миграции для Product
    python manage.py makemigrations products --name add_1c_integration_fields
    ```

  - [ ] Создать модель `ImportSession` с полями: `import_type`, `status`, `started_at`, `finished_at`, `report_details` (JSONField), `error_message`.
  - [ ] Создать миграцию для модели `ImportSession`.

    ```bash
    # Создание миграции для ImportSession
    python manage.py makemigrations products --name add_import_session
    
    # Применение миграций
    python manage.py migrate
    ```

- [ ] **Реализовать архитектуру Парсер/Процессор (AC: 2)**
  - [ ] Создать `XMLDataParser` для файлов `goods.xml`, `offers.xml`, `prices.xml`, `rests.xml`.
  - [ ] Создать `ProductDataProcessor`, который принимает данные от парсера.

- [ ] **Создать management-команду `import_catalog_from_1c` с валидацией (AC: 3, 5)**
  - [ ] Реализовать параметры: `--file`, `--dry-run`, `--chunk-size`.
  - [ ] Команда должна создавать запись `ImportSession` в начале работы.
  - [ ] Команда должна оркестрировать вызов `XMLDataParser` и `ProductDataProcessor`.
  - [ ] В конце работы команда обновляет статус `ImportSession` (`completed` или `failed`).
  - [ ] В `ProductDataProcessor` добавить валидатор уникальности `onec_id`.
  - [ ] В `ProductDataProcessor` добавить валидатор обязательных полей.

- [ ] **Реализовать обработку цен (AC: 4)**
  - [ ] Добавить поля для всех ролей в модель `Product`
  - [ ] В `ProductDataProcessor` реализовать маппинг цен из `prices.xml`.
  - [ ] Реализовать fallback-логику для `federation_rep`.
    - Если цена для `federation_rep` отсутствует, использовать розничную цену (`retail`).

- [ ] **Настроить логирование (AC: 6)**
  - [ ] В `ProductDataProcessor` логировать ошибки валидации и статистику в `ImportSession.report_details`.

- [ ] **Создать тесты (AC: 7)**
  - [ ] Unit-тесты для `XMLDataParser` с проверкой структуры XML файлов.
  - [ ] Unit-тесты для `ProductDataProcessor` с проверкой валидации и маппинга цен.
  - [ ] Интеграционные тесты для команды `import_catalog_from_1c` с тестовыми данными.
  - [ ] Тесты обработки ошибок импорта и логирования в `ImportSession`.
  - [ ] Тесты ролевого ценообразования с fallback-логикой.
  - [ ] Performance тесты для больших объемов данных (≥1000 товаров).

## Definition of Done

- [ ] Команда успешно импортирует тестовые данные товаров
- [ ] Все тесты проходят с покрытием ≥90% (критические модули ≥90% по [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md))
- [ ] Логируются все операции импорта в `ImportSession`
- [ ] Код прошел code review
- [ ] Документация обновлена

## Testing Strategy

### Подход к тестированию

Тестирование импорта из 1С следует стратегии, описанной в [`docs/architecture/10-testing-strategy.md`](docs/architecture/10-testing-strategy.md):

- Unit-тесты для изолированных компонентов
- Интеграционные тесты для проверки взаимодействия
- Performance тесты для больших объемов данных

### Ключевые тестовые сценарии

#### 1. Unit-тесты для XMLDataParser

```python
# tests/unit/test_services/test_xml_parser.py
@pytest.mark.unit
class TestXMLDataParser:
    def test_parse_goods_xml_structure(self):
        """Проверка корректного парсинга структуры goods.xml"""
        
    def test_parse_prices_xml_with_role_mapping(self):
        """Проверка маппинга типов цен на роли пользователей"""
        
    def test_handle_malformed_xml_gracefully(self):
        """Проверка обработки некорректного XML"""
```

#### 2. Unit-тесты для ProductDataProcessor

```python
# tests/unit/test_services/test_product_processor.py
@pytest.mark.unit
class TestProductDataProcessor:
    def test_validate_unique_onec_id(self):
        """Проверка валидации уникальности onec_id"""
        
    def test_map_prices_to_user_roles(self):
        """Проверка маппинга цен на роли пользователей"""
        
    def test_federation_rep_fallback_to_retail(self):
        """Проверка fallback-логики для federation_rep"""
        # Создаем тестовые данные без цены для federation_rep
        product_data = {
            'name': 'Test Product',
            'retail_price': 1000.00,
            'wholesale_level1_price': 800.00,
            'wholesale_level2_price': 750.00,
            'trainer_price': 700.00,
            # federation_rep_price отсутствует
        }
        
        # Проверяем что для federation_rep используется розничная цена
        processor = ProductDataProcessor(session_id=1)
        processed_data = processor.process_price_mapping(product_data)
        
        assert processed_data['federation_rep_price'] == 1000.00  # retail_price
```

#### 3. Интеграционные тесты для команды import_catalog_from_1c

```python
# tests/integration/test_management_commands/test_import_catalog_from_1c.py
@pytest.mark.django_db
@pytest.mark.integration
class TestImportCatalogCommand:
    def test_successful_import_with_test_data(self):
        """Проверка успешного импорта тестовых данных"""
        
    def test_import_creates_import_session_with_correct_status(self):
        """Проверка создания ImportSession с корректным статусом"""
        
    def test_import_logs_errors_to_import_session(self):
        """Проверка логирования ошибок в ImportSession"""
```

#### 4. Performance тесты

```python
# tests/performance/test_import_performance.py
@pytest.mark.django_db
@pytest.mark.slow
class TestImportPerformance:
    def test_import_1000_products_within_timeout(self):
        """Проверка импорта 1000 товаров в допустимое время"""
        
    def test_memory_usage_stable_during_large_import(self):
        """Проверка стабильного использования памяти при большом импорте"""
```

### Тестовые данные

Для тестирования использовать примеры XML файлов из `backend/tests/fixtures/1c-data/`:

- `propertiesGoods/propertiesGoods_X_X_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.xml`
- `propertiesOffers/propertiesOffers_X_X_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.xml`
- `rests/rests.xml`
- `units/units.xml`

### Требования к покрытию

- Общее покрытие: ≥70%
- Покрытие критических модулей: ≥90%
  - `apps.products.services.parser`
  - `apps.products.services.processor`
  - `apps.products.management.commands.import_catalog_from_1c`
  - `apps.products.models.ImportSession`

### Mock Objects

Использование mock-объектов для тестирования:

```python
# tests/unit/test_services/test_xml_parser.py
import pytest
from unittest.mock import mock_open, patch

@pytest.fixture
def mock_xml_file():
    return """<?xml version="1.0" encoding="UTF-8"?>
<Каталог>
  <Товары>
    <Товар>
      <Ид>test-uuid</Ид>
      <Наименование>Test Product</Наименование>
      <Артикул>TEST-001</Артикул>
    </Товар>
  </Товары>
</Каталог>"""

@pytest.fixture
def mock_prices_xml():
    return """<?xml version="1.0" encoding="UTF-8"?>
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>test-uuid</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>retail-uuid</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>"""

def test_xml_parser_with_mock(mock_xml_file):
    """Тестирование парсера с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_xml_file)):
        parser = XMLDataParser()
        result = parser.parse("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['name'] == 'Test Product'
        assert result[0]['sku'] == 'TEST-001'

def test_prices_parser_with_mock(mock_prices_xml):
    """Тестирование парсера цен с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_prices_xml)):
        parser = XMLDataParser()
        result = parser.parse_prices("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['retail_price'] == 1000.00
```

### Запуск тестов

```bash
# Запуск всех тестов импорта
pytest tests/unit/test_services/test_xml_parser.py tests/unit/test_services/test_product_processor.py tests/integration/test_management_commands/test_import_catalog_from_1c.py -v

# Запуск с покрытием
pytest --cov=apps.products.services --cov=apps.products.management.commands --cov-report=html

# Запуск performance тестов
pytest tests/performance/test_import_performance.py -v
```

## Разбиение на задачи

### Задача 1: Создание модели ImportSession (Приоритет: Высокий, 2 story points)

**Описание:** Создать модель ImportSession для отслеживания сессий импорта с полями import_type, status, started_at, finished_at, report_details, error_message.

**Файлы для изменения:**

- `backend/apps/products/models.py` - добавить модель ImportSession
- `backend/apps/products/migrations/XXXX_add_import_session.py` - создать миграцию

**Критерии приемки:**

- Модель создана со всеми полями и выборками
- Миграция создана и применена
- Написаны unit-тесты для модели

---

### Задача 2: Реализация XMLDataParser (Приоритет: Высокий, 3 story points)

**Описание:** Создать класс XMLDataParser для парсинга XML файлов от 1С (goods.xml, offers.xml, prices.xml, rests.xml).

**Файлы для изменения:**

- `backend/apps/products/services/parser.py` - создать класс XMLDataParser

**Критерии приемки:**

- Класс реализован с методами для парсинга всех типов XML
- Обрабатываются ошибки некорректной структуры XML
- Написаны unit-тесты с тестовыми данными из `backend/tests/fixtures/1c-data/`

---

### Задача 3: Реализация ProductDataProcessor (Приоритет: Высокий, 5 story points)

**Описание:** Создать класс ProductDataProcessor для обработки данных от парсера и сохранения в базу данных.

**Файлы для изменения:**

- `backend/apps/products/services/processor.py` - создать класс ProductDataProcessor

**Критерии приемки:**

- Класс реализован с методами валидации и сохранения данных
- Реализован валидатор уникальности onec_id
- Реализован валидатор обязательных полей
- Реализован маппинг типов цен на роли пользователей
- Реализована fallback-логика для federation_rep → retail/RRP
- Написаны unit-тесты

---

### Задача 4: Создание management-команды import_catalog_from_1c с валидацией (Приоритет: Высокий, 4 story points)

**Описание:** Создать management-команду для импорта каталога из 1С с параметрами --file, --dry-run, --chunk-size и встроенной валидацией данных.

**Файлы для изменения:**

- `backend/apps/products/management/commands/import_catalog_from_1c.py` - создать команду

**Критерии приемки:**

- Команда создана с необходимыми параметрами
- Команда создает и обновляет ImportSession
- Команда оркестрирует вызов XMLDataParser и ProductDataProcessor
- Реализованы валидаторы уникальности onec_id и обязательных полей
- Написаны интеграционные тесты

---

### Задача 5: Тестирование системы импорта (Приоритет: Средний, 4 story points)

**Описание:** Написать comprehensive тесты для всей системы импорта.

**Файлы для изменения:**

- `tests/unit/test_services/test_xml_parser.py` - unit-тесты для парсера
- `tests/unit/test_services/test_product_processor.py` - unit-тесты для процессора
- `tests/integration/test_management_commands/test_import_catalog_from_1c.py` - интеграционные тесты
- `tests/performance/test_import_performance.py` - performance тесты

**Критерии приемки:**

- Все тесты проходят
- Покрытие кода ≥90% для критических модулей
- Performance тесты подтверждают обработку ≥1000 товаров

---

### Задача 6: Документирование и настройка окружения (Приоритет: Низкий, 1 story point)

**Описание:** Завершить документирование и настроить переменные окружения.

**Файлы для изменения:**

- `backend/.env.example` - добавить переменные окружения
- Обновить документацию при необходимости

**Критерии приемки:**

- Переменные окружения добавлены в .env.example
- Документация обновлена

**Добавляемые переменные окружения:**

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3
IMPORT_MAX_FILE_SIZE=100

# Безопасность
IMPORT_REQUIRE_CONFIRMATION=true

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

### Предлагаемый порядок выполнения

1. Задача 1: Создание модели ImportSession
2. Задача 2: Реализация XMLDataParser
3. Задача 3: Реализация ProductDataProcessor
4. Задача 4: Создание management-команды с валидацией
5. Задача 5: Тестирование системы импорта
6. Задача 6: Документирование и настройка окружения

## Dev Notes

### Story Context

**Epic Integration Points:**

- Интегрируется с: 1С:Управление торговлей
- Технология: Django Management Commands + XML/JSON parsing
- Следует паттерну: [`docs/prd/requirements.md#pricing`](docs/prd/requirements.md#pricing) (FREESPORT ролевое ценообразование)
- Точки касания: Product model, User roles, sync logging
- См. также: [`docs/architecture/tech-stack.md`](docs/architecture/tech-stack.md) (технологический стек)

### Technical Architecture

```python
# apps/products/models.py (дополнение)
class ImportSession(models.Model):
    class ImportType(models.TextChoices):
        CATALOG = 'catalog', 'Каталог товаров'
        STOCKS = 'stocks', 'Остатки товаров'
        PRICES = 'prices', 'Цены товаров'
    
    class ImportStatus(models.TextChoices):
        STARTED = 'started', 'Начато'
        COMPLETED = 'completed', 'Завершено'
        FAILED = 'failed', 'Ошибка'
    
    import_type = models.CharField(max_length=20, choices=ImportType.choices, default=ImportType.CATALOG)
    status = models.CharField(max_length=20, choices=ImportStatus.choices, default=ImportStatus.STARTED)
    started_at = models.DateTimeField(auto_now_add=True)
    finished_at = models.DateTimeField(null=True, blank=True)
    report_details = models.JSONField(default=dict, blank=True)
    error_message = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-started_at']

# apps/products/services/parser.py
class XMLDataParser:
    def parse(self, file_path):
        # returns list[dict]
        pass

# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id):
        self.session_id = session_id

    def process_data(self, data: list[dict]):
        # validation and db operations
        pass

# apps/products/management/commands/import_catalog_from_1c.py
class Command(BaseCommand):
    def handle(self, *args, **options):
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        parser = XMLDataParser()
        processor = ProductDataProcessor(session.id)
        
        raw_data = parser.parse(options['file'])
        processor.process_data(raw_data)
        
        session.status = ImportSession.ImportStatus.COMPLETED
        session.save()
```

### Domain Concepts & Data Structure

#### 1С:Управление торговлей

**1С:Управление торговлей** - это ERP-система для управления торговой деятельностью, которая выгружает данные в формате CommerceML 3.1. Система предоставляет полную информацию о товарах, ценах, остатках и контрагентах.

#### Ролевое ценообразование FREESPORT

**Ролевое ценообразование** - это система маппинга типов цен из 1С на роли пользователей в FREESPORT. Каждый тип цены из 1С соответствует определенной роли пользователя в системе.

**Информация по типам цен (из `priceLists.xml`):**

`Опт 1` -> `wholesale_level1`
`Опт 2` -> `wholesale_level2`
`Опт 3` -> `wholesale_level3`
`Тренерская` -> `trainer`
`РРЦ` -> `retail` / `RRP`
`МРЦ` -> `MSRP`

**Внимание:** Тип цены для `federation_rep` не найден в данных 1С. Используется fallback-логика: `РРЦ` → `federation_rep`.

Для каждой роли в модели Product предусмотрены соответствующие поля цен.

#### Структура XML файлов от 1С

Данные из 1С поступают в формате CommerceML 3.1 и разделены по типам в разные файлы:

**Основные файлы:**

- `goods.xml` - основная информация о товарах (продуктах)
- `offers.xml` - торговые предложения (SKU), вариации товаров
- `prices.xml` - цены для каждого SKU
- `rests.xml` - остатки SKU на складах

**Структура goods.xml:**

```xml
<Каталог>
  <Товары>
    <Товар>
      <Ид>UUID-товара</Ид>
      <Артикул>Артикул товара</Артикул>
      <Наименование>Название товара</Наименование>
      <БазоваяЕдиница>Код единицы измерения</БазоваяЕдиница>
      <Группы>
        <Ид>UUID-категории</Ид>
      </Группы>
      <Описание>HTML-описание</Описание>
      <Картинка>путь/к/изображению.jpg</Картинка>
    </Товар>
  </Товары>
</Каталог>
```

**Структура prices.xml:**

```xml
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>UUID-товара или SKU</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>UUID-типа-цены</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>
```

**Маппинг типов цен на роли пользователей:**

- UUID типа цены из `priceLists.xml` маппится на роль пользователя в системе FREESPORT
- Пример: "Опт 1 (300-600 тыс.руб в квартал)" → `wholesale_level1`
- Fallback-логика: если цена для роли отсутствует, используется розничная цена

Подробное описание структуры данных см. в [`docs/architecture/20-1c-integration.md`](docs/architecture/20-1c-integration.md) (Приложение А).

#### Chunk Processing Strategy

Для обработки больших объемов данных используется стратегия порционной обработки:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id, chunk_size=1000):
        self.session_id = session_id
        self.chunk_size = chunk_size
    
    def process_data(self, data: list[dict]):
        """Обработка данных порциями для оптимизации памяти"""
        for i in range(0, len(data), self.chunk_size):
            chunk = data[i:i + self.chunk_size]
            self.process_chunk(chunk)
    
    def process_chunk(self, chunk: list[dict]):
        """Обработка одной порции данных"""
        with transaction.atomic():
            for item in chunk:
                self.process_item(item)
```

Параметр `--chunk-size` в management-команде позволяет настраивать размер порции в зависимости от доступной памяти.

#### Duplicate Handling Strategy

Стратегия обработки дубликатов товаров основана на поле `onec_id`:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def process_item(self, item_data: dict):
        """Обработка одного товара с проверкой на дубликаты"""
        onec_id = item_data.get('onec_id')
        
        if not onec_id:
            self.log_error('Missing onec_id', item_data)
            return
        
        try:
            # Поиск существующего товара
            product = Product.objects.get(onec_id=onec_id)
            # Обновление существующего товара
            self.update_product(product, item_data)
        except Product.DoesNotExist:
            # Создание нового товара
            self.create_product(item_data)
        except Product.MultipleObjectsReturned:
            # Обработка случая множественных дубликатов
            self.handle_multiple_duplicates(onec_id, item_data)
    
    def update_product(self, product: Product, item_data: dict):
        """Обновление существующего товара"""
        # Обновляем только поля, которые могут изменяться
        product.name = item_data.get('name', product.name)
        product.description = item_data.get('description', product.description)
        # Обновляем цены и остатки
        self.update_prices(product, item_data)
        self.update_stock(product, item_data)
        product.save()
```

### Environment Variables

Для работы с импортом из 1С потребуются следующие переменные окружения:

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

### Testing

**Требования к тестированию:**

- Unit-тесты для изолированных компонентов (парсер, процессор)
- Интеграционные тесты для проверки взаимодействия компонентов
- Performance тесты для больших объемов данных (≥1000 товаров)
- Тесты обработки ошибок и логирования
- Тесты безопасности (XML Bomb, инъекции)

**Стандарты тестирования:**

- Использовать pytest с маркировкой @pytest.mark.unit и @pytest.mark.integration
- Применять Factory Boy для генерации тестовых данных
- Использовать mock-объекты для внешних зависимостей (файлы, API)
- Обеспечить изоляцию тестов с помощью транзакций

### Security Considerations

**Безопасность импорта данных из 1С:**

1. **Валидация XML структуры**: Все XML файлы должны проходить валидацию перед парсингом для предотвращения XML-инъекций
2. **Ограничение размера файлов**: Установить максимальный размер файлов для импорта (настроить через переменную окружения IMPORT_MAX_FILE_SIZE)
3. **Проверка прав доступа**: Только авторизованные пользователи с правами администратора могут запускать команды импорта
4. **Резервное копирование**: Перед началом импорта создавать резервную копию затрагиваемых данных
5. **Атомарность операций**: Использовать транзакции для обеспечения целостности данных при частичных сбоях
6. **Санитизация данных**: Очищать все текстовые поля от потенциально опасного содержимого

**Переменные окружения для безопасности:**

```bash
# Максимальный размер файла импорта (в MB)
IMPORT_MAX_FILE_SIZE=100

# Таймаут операции импорта (в секундах)
IMPORT_TIMEOUT=300

# Требовать подтверждение перед импортом
IMPORT_REQUIRE_CONFIRMATION=true

# Максимальное количество элементов в XML
XML_PARSER_MAX_ELEMENTS=10000
```

#### XML Bomb Protection

Защита от атак типа XML Bomb (Billion Laughs Attack):

```python
# apps/products/services/parser.py
import xml.etree.ElementTree as ET
from xml.dom import minidom

class XMLDataParser:
    def __init__(self):
        self.max_elements = int(os.environ.get('XML_PARSER_MAX_ELEMENTS', '10000'))
        self.element_count = 0
    
    def safe_xml_parse(self, file_path):
        """Безопасный парсинг XML с защитой от XML Bomb"""
        parser = ET.XMLParser(resolve_entities=False)
        
        # Ограничение количества элементов
        class SafeTreeBuilder(ET.TreeBuilder):
            def start(self, tag, attrs):
                if parser.element_count >= parser.max_elements:
                    raise ValueError(f"XML contains too many elements (max: {parser.max_elements})")
                parser.element_count += 1
                return super().start(tag, attrs)
        
        parser = ET.XMLParser(target=SafeTreeBuilder(), resolve_entities=False)
        tree = ET.parse(file_path, parser=parser)
        return tree
```

#### Data Sanitization

Санитизация данных для защиты от инъекций:

```python
# apps/products/services/processor.py
import bleach
from django.core.exceptions import ValidationError

class ProductDataProcessor:
    def sanitize_html_field(self, html_content: str) -> str:
        """Очистка HTML-контента в описаниях товаров"""
        if not html_content:
            return html_content
        
        # Разрешенные теги и атрибуты
        allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']
        allowed_attributes = {'*': ['class']}
        
        # Очистка HTML
        clean_html = bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )
        
        return clean_html
    
    def sanitize_text_field(self, text: str) -> str:
        """Очистка текстовых полей"""
        if not text:
            return text
        
        # Удаление потенциально опасных символов
        clean_text = text.strip()
        # Ограничение длины
        max_length = 1000
        if len(clean_text) > max_length:
            clean_text = clean_text[:max_length]
        
        return clean_text
    
    def validate_price_field(self, price_value) -> float:
        """Валидация и очистка цен"""
        try:
            price = float(price_value)
            if price < 0:
                raise ValidationError("Price cannot be negative")
            if price > 999999.99:
                raise ValidationError("Price too high")
            return round(price, 2)
        except (ValueError, TypeError):
            raise ValidationError("Invalid price format")
```

#### Access Control

Контроль доступа для запуска команд импорта:

```python
# apps/products/management/commands/import_catalog_from_1c.py
from django.contrib.auth.decorators import user_passes_test
from django.core.management.base import CommandError
from django.contrib.auth import get_user_model

User = get_user_model()

def is_superuser(user):
    """Проверка, что пользователь является суперпользователем"""
    return user.is_superuser

class Command(BaseCommand):
    help = "Импорт каталога товаров из файла 1С"
    
    def check_user_permissions(self, username):
        """Проверка прав доступа пользователя"""
        try:
            user = User.objects.get(username=username)
            if not user.is_superuser:
                raise CommandError(f"User {username} is not a superuser")
            return user
        except User.DoesNotExist:
            raise CommandError(f"User {username} does not exist")
    
    def handle(self, *args, **options):
        # Проверка прав доступа
        if options.get('username'):
            self.check_user_permissions(options['username'])
        else:
            self.stdout.write(
                self.style.WARNING('Warning: No username provided. '
                                 'Make sure you have proper permissions.')
            )
        
        # Продолжение выполнения команды
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        # ... остальной код
```

Для использования в коде:

```python
# apps/products/views.py
from django.contrib.auth.decorators import user_passes_test
from django.views.decorators.http import require_POST

@user_passes_test(is_superuser)
@require_POST
def trigger_import_view(request):
    """Представление для запуска импорта через веб-интерфейс"""
    # Проверка прав доступа уже выполнена декоратором
    pass
```

### Error Handling

**Стратегия обработки ошибок импорта:**

1. **Валидационные ошибки**:
   - Ошибки структуры XML: логировать с детализацией, продолжать обработку других файлов
   - Ошибки валидации данных: логировать с указанием поля и значения, пропускать запись

2. **Ошибки базы данных**:
   - Ошибки соединения: повторная попытка с экспоненциальным backedoff
   - Ошибки целостности: откат транзакции, логирование, остановка импорта

3. **Системные ошибки**:
   - Нехватка памяти: остановка импорта с уведомлением
   - Ошибки файловой системы: проверка прав доступа, логирование

4. **Логирование ошибок**:
   - Все ошибки логируются в ImportSession.error_details
   - Критические ошибки отправляют уведомление администратору
   - Создается отчет с детализацией всех ошибок импорта

#### Validation Errors

Детальная обработка ошибок валидации:

```python
# apps/products/services/processor.py
class ValidationError(Exception):
    """Класс для ошибок валидации данных"""
    def __init__(self, field, value, message, severity='error'):
        self.field = field
        self.value = value
        self.message = message
        self.severity = severity  # 'warning', 'error', 'critical'
        super().__init__(f"{field}: {message}")

class ProductDataProcessor:
    def validate_product_data(self, data: dict) -> list[ValidationError]:
        """Валидация данных товара с возвратом списка ошибок"""
        errors = []
        
        # Валидация обязательных полей
        required_fields = ['name', 'onec_id']
        for field in required_fields:
            if not data.get(field):
                errors.append(ValidationError(
                    field=field,
                    value=data.get(field),
                    message=f'{field} is required',
                    severity='error'
                ))
        
        # Валидация типов данных
        price_fields = ['retail_price', 'wholesale_level1_price', 'wholesale_level2_price',
                       'trainer_price', 'federation_rep_price']
        for field in price_fields:
            if field in data and data[field] is not None:
                try:
                    price = float(data[field])
                    if price < 0:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} cannot be negative',
                            severity='error'
                        ))
                    elif price > 999999.99:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} is too high',
                            severity='warning'
                        ))
                except (ValueError, TypeError):
                    errors.append(ValidationError(
                        field=field,
                        value=data[field],
                        message=f'Invalid {field} format',
                        severity='error'
                    ))
        
        # Валидация длины текстовых полей
        text_fields = ['name', 'description', 'sku']
        for field in text_fields:
            if field in data and data[field]:
                max_length = 255 if field != 'description' else 5000
                if len(data[field]) > max_length:
                    errors.append(ValidationError(
                        field=field,
                        value=data[field][:50] + '...',
                        message=f'{field} is too long (max {max_length})',
                        severity='warning'
                    ))
        
        return errors
    
    def handle_validation_errors(self, errors: list[ValidationError], item_data: dict):
        """Обработка ошибок валидации"""
        critical_errors = [e for e in errors if e.severity == 'critical']
        error_errors = [e for e in errors if e.severity == 'error']
        warning_errors = [e for e in errors if e.severity == 'warning']
        
        # Критические ошибки - остановка обработки
        if critical_errors:
            raise Exception(f"Critical validation errors: {[e.message for e in critical_errors]}")
        
        # Ошибки - пропуск записи с логированием
        if error_errors:
            self.log_validation_errors(error_errors, item_data)
            return False  # Пропустить запись
        
        # Предупреждения - логировать, но продолжить обработку
        if warning_errors:
            self.log_validation_warnings(warning_errors, item_data)
        
        return True  # Продолжить обработку
```

**Уровни логирования:**

- INFO: успешные операции, статистика
- WARNING: пропущенные записи, некритичные ошибки
- ERROR: критические ошибки, требующие внимания
- CRITICAL: ошибки, остановившие импорт

### Dependencies

- **Blocks:** [`docs/stories/epic-3/3.1.2.loading-scripts.md`](docs/stories/epic-3/3.1.2.loading-scripts.md) (скрипты загрузки)
- **Depends on:** [`docs/stories/epic-1/1.8.database-design.md`](docs/stories/epic-1/1.8.database-design.md) (Database design)
- **Related:**
  - [`docs/architecture/source-tree.md`](docs/architecture/source-tree.md) (структура проекта)
  - [`docs/architecture/coding-standards.md`](docs/architecture/coding-standards.md) (стандарты кодирования Django)
  - [`docs/prd/requirements.md`](docs/prd/requirements.md) (требования к интеграции с 1С)
  - [`docs/epics/epic-3/parser-plan.md`](docs/epics/epic-3/parser-plan.md) (план разработки парсеров)

## Story Points

**14** (Complexity increased due to combined validation task)

## Priority

**High** - Критический путь для Epic 3

## Labels

`epic-3` `1c-integration` `product-management` `django-commands` `refactoring`

## Change Log

| Дата | Версия | Описание | Автор |
|------|--------|----------|-------|
| 2025-09-07 | 1.0 | Первоначальная версия истории | Product Owner |
| 2025-10-09 | 1.1 | Исправление путей к тестовым данным, унификация названия команды | Product Owner |
| 2025-10-10 | 1.2 | Добавление разделов Security Considerations и Error Handling, интеграция валидаторов в процессор, добавление примеров тестов | Product Owner |
| 2025-10-10 | 1.3 | Объединение задач (AC: 3) и (AC: 5), изменение нумерации задач, обновление критериев приемки | Product Owner |

## Dev Agent Record

### Agent Model Used

James - Full Stack Developer (dev agent)

### Completion Notes

- ✅ **Task 3.1.1-A (AC: 3) ЗАВЕРШЕН**: Дополнены поля интеграции с 1С в Product модель
- ✅ Добавлены поля: `onec_id` (unique), `sync_status` (choices), `last_sync_at`, `error_message`
- ✅ Создана миграция `0009_add_1c_integration_fields`
- ✅ Добавлены индексы для оптимизации запросов по новым полям
- ✅ Написаны comprehensive unit тесты для всех новых полей
- ✅ Все тесты проходят успешно (10/10 passed)
- ✅ Нет регрессий в существующем функционале
- ✅ Исправлены некорректные пути к тестам в архитектурной документации

### File List

- backend/apps/products/models.py - добавлены 1С интеграционные поля
- backend/apps/products/migrations/0009_add_1c_integration_fields.py - миграция БД
- backend/tests/unit/test_models/test_product_models.py - добавлены тесты для новых полей
- docs/architecture/source-tree.md - исправлены пути к тестам
- docs/stories/2.5.product-detail-api.md - исправлены пути к тестам

## QA Results

### Review Date: 2025-09-23

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation of the `Product` model update is of high quality. The code is clean, follows project conventions, and includes appropriate database indexes for performance.

### Refactoring Performed

No refactoring was necessary as the code quality is high.

### Compliance Check

- Coding Standards: [✓]
- Project Structure: [✓]
- Testing Strategy: [✓]
- All ACs Met: [✗] (Only a part of AC #1 is complete)

### Improvements Checklist

The following items represent the remaining work required to complete this story:

- [ ] Create the `ImportSession` model (AC #1)
- [ ] Implement the `XMLDataParser` and `ProductDataProcessor` (AC #2)
- [ ] Create the `import_catalog_from_1c` management command with validation (AC #3, #5)
- [ ] Implement price mapping and fallback logic (AC #4)
- [ ] Implement detailed logging into `ImportSession` (AC #5)
- [ ] Write integration tests for the complete workflow (AC #6)

### Security Review

No security implications were found in the current changes.

### Performance Considerations

Database indexes have been correctly added for the new fields, which satisfies performance considerations for this change.

### Files Modified During Review

None.

### Gate Status

Gate: CONCERNS → docs/qa/gates/3.1.1-import-products-structure.yml

### Recommended Status

[✗ Changes Required - See unchecked items above]

# Story 3.1.1: import-products-structure

## Status

Draft → In Progress

## Story

**As a** разработчик,
**I want** создать систему импорта товаров из 1С,
**so that** каталог автоматически синхронизируется с ERP системой.

## Acceptance Criteria

1. Обновлены **существующие** модели `Product`, `Category`, `Brand` и создана модель `ImportSession` для поддержки интеграции.
2. Логика импорта разделена на архитектуру Парсер/Процессор.
3. Создана **базовая** management-команда `import_catalog_from_1c` с валидацией данных и сессиями импорта (параметры: --data-dir, --dry-run).
4. Реализована логика обработки ролевого ценообразования.
5. Настроено детальное логирование процесса импорта в `ImportSession`.
6. Написаны unit и integration тесты для всего функционала.

### Детальные задачи

- [ ] **Обновить существующие модели для интеграции (AC: 1)**
  
  - [ ] **Brand (существующая модель в models.py):**
    - [ ] Добавить `onec_id = CharField(max_length=100, unique=True, null=True, blank=True, db_index=True)`
    - [ ] Создать миграцию `add_onec_id_to_brand`
  
  - [ ] **Category (существующая модель в models.py):**
    - [ ] Добавить `onec_id = CharField(max_length=100, unique=True, null=True, blank=True, db_index=True)`
    - [ ] Создать миграцию `add_onec_id_to_category`
  
  - [ ] **Product (существующая модель в models.py):**
    - [ ] Добавить поля: `onec_id`, `parent_onec_id`, `sync_status`, `last_sync_at`, `error_message`
    - [ ] Добавить enum `SyncStatus` с choices
    - [ ] Создать миграцию `add_1c_integration_fields`
    - [ ] Добавить индексы: onec_id, parent_onec_id, sync_status
  
  - [ ] **ImportSession (новая модель в models.py):**
    - [ ] Добавить в конец файла models.py
    - [ ] Определить enums: ImportType, ImportStatus
    - [ ] Определить поля: import_type, status, started_at, finished_at, report_details, error_message
    - [ ] Создать миграцию `add_import_session`
    - [ ] Добавить индексы

    ```bash
    # Последовательность миграций
    python manage.py makemigrations products --name add_onec_id_to_brand
    python manage.py makemigrations products --name add_onec_id_to_category
    python manage.py makemigrations products --name add_1c_integration_fields
    python manage.py makemigrations products --name add_import_session
    python manage.py migrate
    ```

- [ ] **Создать сервисный слой (AC: 2)**
  - [ ] Создать директорию `backend/apps/products/services/`
  - [ ] Создать `services/__init__.py`
  - [ ] Создать `services/parser.py` с классом `XMLDataParser` для файлов `goods.xml`, `offers.xml`, `prices.xml`, `rests.xml`
  - [ ] Создать `services/processor.py` с классом `ProductDataProcessor`, который принимает данные от парсера

- [ ] **Создать базовую команду `import_catalog_from_1c` (AC: 3, 5)**
  - [ ] Создать файл `backend/apps/products/management/commands/import_catalog_from_1c.py`
  - [ ] Реализовать **базовые** параметры:
    - [ ] `--data-dir` - путь к директории с XML файлами (обязательный)
    - [ ] `--dry-run` - тестовый запуск без записи в БД
  - [ ] Реализовать валидацию структуры директории (проверка наличия goods/, offers/, prices/, rests/)
  - [ ] Команда должна создавать запись `ImportSession` в начале работы
  - [ ] Команда должна оркестрировать вызов `XMLDataParser` и `ProductDataProcessor`
  - [ ] Реализовать последовательный парсинг файлов:
    1. Parse `goods.xml` → create Product placeholders (parent_onec_id, is_active=False)
    2. Parse `offers.xml` → enrich Products (onec_id, is_active=True)
    3. Parse `prices.xml` → update prices
    4. Parse `rests.xml` → update stock
  - [ ] В конце работы команда обновляет статус `ImportSession` (`completed` или `failed`)
  - [ ] В `ProductDataProcessor` добавить валидатор уникальности `onec_id`
  - [ ] В `ProductDataProcessor` добавить валидатор обязательных полей
  
**Примечание:** Расширенные параметры (--chunk-size, --skip-validation) будут добавлены в Story 3.1.2

- [ ] **Реализовать обработку цен (AC: 4)**
  - [ ] Создать модель `PriceType` для маппинга типов цен из 1С на роли пользователей
  - [ ] Создать миграцию для модели `PriceType`
  - [ ] Реализовать парсинг `priceLists.xml` для заполнения справочника `PriceType`
  - [ ] В `ProductDataProcessor` реализовать маппинг цен из `prices.xml` на существующие поля модели `Product`
  - [ ] Реализовать fallback-логику для `federation_price`:
    - Если цена для `federation_price` отсутствует, использовать `recommended_retail_price` (РРЦ)

- [ ] **Настроить логирование (AC: 6)**
  - [ ] В `ProductDataProcessor` логировать ошибки валидации и статистику в `ImportSession.report_details`.

- [ ] **Создать тесты (AC: 7)**
  - [ ] Unit-тесты для `XMLDataParser` с проверкой структуры XML файлов.
  - [ ] Unit-тесты для `ProductDataProcessor` с проверкой валидации и маппинга цен.
  - [ ] Интеграционные тесты для команды `import_catalog_from_1c` с тестовыми данными.
  - [ ] Тесты обработки ошибок импорта и логирования в `ImportSession`.
  - [ ] Тесты ролевого ценообразования с fallback-логикой.
  - [ ] Performance тесты для больших объемов данных (≥1000 товаров).

## Definition of Done

- [ ] Команда успешно импортирует тестовые данные товаров
- [ ] Все тесты проходят с покрытием ≥90% (критические модули ≥90% по [`docs/architecture/10-testing-strategy.md`](../../architecture/10-testing-strategy.md))
- [ ] Логируются все операции импорта в `ImportSession`
- [ ] Код прошел code review
- [ ] Документация обновлена

## Testing Strategy

### Подход к тестированию

Тестирование импорта из 1С следует стратегии, описанной в [`docs/architecture/10-testing-strategy.md`](../../architecture/10-testing-strategy.md):

- Unit-тесты для изолированных компонентов
- Интеграционные тесты для проверки взаимодействия
- Performance тесты для больших объемов данных

### Ключевые тестовые сценарии

#### 1. Unit-тесты для XMLDataParser

```python
# tests/unit/test_services/test_xml_parser.py
@pytest.mark.unit
class TestXMLDataParser:
    def test_parse_goods_xml_structure(self):
        """Проверка корректного парсинга структуры goods.xml"""
        
    def test_parse_prices_xml_with_role_mapping(self):
        """Проверка маппинга типов цен на роли пользователей"""
        
    def test_handle_malformed_xml_gracefully(self):
        """Проверка обработки некорректного XML"""
```

#### 2. Unit-тесты для ProductDataProcessor

```python
# tests/unit/test_services/test_product_processor.py
@pytest.mark.unit
class TestProductDataProcessor:
    def test_validate_unique_onec_id(self):
        """Проверка валидации уникальности onec_id"""
        
    def test_two_stage_product_creation(self):
        """Проверка двухэтапного создания товара"""
        processor = ProductDataProcessor(session_id=1)
        
        # Этап 1: Создание заготовки из goods.xml
        goods_data = {
            'id': 'parent-uuid-123',
            'name': 'Base Product Name',
            'description': 'Product description',
            'category_id': 1
        }
        product = processor.create_product_placeholder(goods_data)
        
        assert product.parent_onec_id == 'parent-uuid-123'
        assert product.name == 'Base Product Name'
        assert product.is_active is False
        assert product.onec_id is None  # Еще не установлен
        
        # Этап 2: Обогащение данными из offers.xml
        offer_data = {
            'id': 'parent-uuid-123#sku-uuid-456',
            'name': 'Product Name with Size M',
            'sku': 'PROD-001-M'
        }
        processor.enrich_product_from_offer(offer_data)
        
        product.refresh_from_db()
        assert product.onec_id == 'parent-uuid-123#sku-uuid-456'
        assert product.name == 'Product Name with Size M'  # Перезаписано
        assert product.sku == 'PROD-001-M'
        assert product.is_active is True
        
    def test_map_prices_to_user_roles(self):
        """Проверка маппинга цен на роли пользователей"""
        
    def test_federation_price_fallback(self):
        """Проверка fallback-логики для federation_price"""
        # Создаем тестовые данные без цены для federation_price
        product_data = {
            'name': 'Test Product',
            'retail_price': 1000.00,
            'recommended_retail_price': 1200.00,  # РРЦ
            'opt1_price': 800.00,
            'opt2_price': 750.00,
            'trainer_price': 700.00,
            # federation_price отсутствует
        }
        
        # Проверяем что для federation_price используется recommended_retail_price
        processor = ProductDataProcessor(session_id=1)
        processed_data = processor.process_price_mapping(product_data)
        
        assert processed_data['federation_price'] == 1200.00  # recommended_retail_price
```

#### 3. Интеграционные тесты для команды import_catalog_from_1c

```python
# tests/integration/test_management_commands/test_import_catalog_from_1c.py
@pytest.mark.django_db
@pytest.mark.integration
class TestImportCatalogCommand:
    def test_successful_import_with_test_data(self):
        """Проверка успешного импорта тестовых данных"""
        
    def test_import_creates_import_session_with_correct_status(self):
        """Проверка создания ImportSession с корректным статусом"""
        
    def test_import_logs_errors_to_import_session(self):
        """Проверка логирования ошибок в ImportSession"""
```

#### 4. Performance тесты

```python
# tests/performance/test_import_performance.py
@pytest.mark.django_db
@pytest.mark.slow
class TestImportPerformance:
    def test_import_1000_products_within_timeout(self):
        """Проверка импорта 1000 товаров в допустимое время"""
        
    def test_memory_usage_stable_during_large_import(self):
        """Проверка стабильного использования памяти при большом импорте"""
```

### Тестовые данные

Для тестирования используются примеры XML файлов, расположенные в директории `backend/tests/fixtures/1c-data/`:

**Структура тестовых данных:**

```text
backend/tests/fixtures/1c-data/
├── goods/
│   └── import_files/
│       ├── goods.xml           # Базовые товары
│       ├── 01/                 # Изображения товаров с ID начинающимся на 01
│       ├── 12/                 # Изображения товаров с ID начинающимся на 12
│       └── [XY]/               # Директории по первым двум цифрам UUID товара
├── groups/
│   └── groups.xml              # Категории товаров
├── offers/
│   └── offers.xml              # Торговые предложения (SKU)
├── prices/
│   └── prices.xml              # Цены для SKU
├── rests/
│   └── rests.xml               # Остатки на складах
├── priceLists/
│   └── priceLists.xml          # Справочник типов цен
├── storages/
│   └── storages.xml            # Справочник складов
├── units/
│   └── units.xml               # Справочник единиц измерения
├── contragents/
│   └── contragents.xml         # Справочник контрагентов
├── propertiesGoods/
│   └── propertiesGoods_*.xml   # Свойства товаров (9 файлов)
└── propertiesOffers/
    └── propertiesOffers_*.xml  # Свойства предложений (2 файла)
```

**Примечание:** Тестовые XML файлы должны содержать минимальный набор данных для проверки всех сценариев импорта, включая:

- Товары с различными типами цен
- SKU с характеристиками (размер, цвет)
- Остатки на нескольких складах
- Корректные и некорректные данные для проверки валидации

### Требования к покрытию

- Общее покрытие: ≥70%
- Покрытие критических модулей: ≥90%
  - `apps.products.services.parser`
  - `apps.products.services.processor`
  - `apps.products.management.commands.import_catalog_from_1c`
  - `apps.products.models.ImportSession`

### Mock Objects

Использование mock-объектов для тестирования:

```python
# tests/unit/test_services/test_xml_parser.py
import pytest
from unittest.mock import mock_open, patch

@pytest.fixture
def mock_xml_file():
    return """<?xml version="1.0" encoding="UTF-8"?>
<Каталог>
  <Товары>
    <Товар>
      <Ид>test-uuid</Ид>
      <Наименование>Test Product</Наименование>
      <Артикул>TEST-001</Артикул>
    </Товар>
  </Товары>
</Каталог>"""

@pytest.fixture
def mock_prices_xml():
    return """<?xml version="1.0" encoding="UTF-8"?>
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>test-uuid</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>retail-uuid</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>"""

def test_xml_parser_with_mock(mock_xml_file):
    """Тестирование парсера с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_xml_file)):
        parser = XMLDataParser()
        result = parser.parse("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['name'] == 'Test Product'
        assert result[0]['sku'] == 'TEST-001'

def test_prices_parser_with_mock(mock_prices_xml):
    """Тестирование парсера цен с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_prices_xml)):
        parser = XMLDataParser()
        result = parser.parse_prices("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['retail_price'] == 1000.00
```

### Запуск тестов

```bash
# Запуск всех тестов импорта
pytest tests/unit/test_services/test_xml_parser.py tests/unit/test_services/test_product_processor.py tests/integration/test_management_commands/test_import_catalog_from_1c.py -v

# Запуск с покрытием
pytest --cov=apps.products.services --cov=apps.products.management.commands --cov-report=html

# Запуск performance тестов
pytest tests/performance/test_import_performance.py -v
```

## Разбиение на задачи

### Задача 1: Создание модели ImportSession (Приоритет: Высокий, 2 story points)

**Описание:** Создать модель ImportSession для отслеживания сессий импорта с полями import_type, status, started_at, finished_at, report_details, error_message.

**Файлы для изменения:**

- `backend/apps/products/models.py` - добавить модель ImportSession
- `backend/apps/products/migrations/XXXX_add_import_session.py` - создать миграцию

**Критерии приемки:**

- Модель создана со всеми полями и выборками
- Миграция создана и применена
- Написаны unit-тесты для модели

---

### Задача 2: Реализация XMLDataParser (Приоритет: Высокий, 3 story points)

**Описание:** Создать класс XMLDataParser для парсинга XML файлов от 1С (goods.xml, offers.xml, prices.xml, rests.xml).

**Файлы для изменения:**

- `backend/apps/products/services/parser.py` - создать класс XMLDataParser

**Критерии приемки:**

- Класс реализован с методами для парсинга всех типов XML
- Обрабатываются ошибки некорректной структуры XML
- Написаны unit-тесты с тестовыми данными из `backend/tests/fixtures/1c-data/`

---

### Задача 3: Реализация ProductDataProcessor (Приоритет: Высокий, 5 story points)

**Описание:** Создать класс ProductDataProcessor для обработки данных от парсера и сохранения в базу данных.

**Файлы для изменения:**

- `backend/apps/products/services/processor.py` - создать класс ProductDataProcessor

**Критерии приемки:**

- Класс реализован с методами валидации и сохранения данных
- Реализован валидатор уникальности onec_id
- Реализован валидатор обязательных полей
- Реализован маппинг типов цен на роли пользователей
- Реализована fallback-логика для federation_price → recommended_retail_price
- Написаны unit-тесты

---

### Задача 4: Создание management-команды import_catalog_from_1c с валидацией (Приоритет: Высокий, 4 story points)

**Описание:** Создать management-команду для импорта каталога из 1С с параметрами --file, --dry-run, --chunk-size и встроенной валидацией данных.

**Файлы для изменения:**

- `backend/apps/products/management/commands/import_catalog_from_1c.py` - создать команду

**Критерии приемки:**

- Команда создана с необходимыми параметрами
- Команда создает и обновляет ImportSession
- Команда оркестрирует вызов XMLDataParser и ProductDataProcessor
- Реализованы валидаторы уникальности onec_id и обязательных полей
- Написаны интеграционные тесты

---

### Задача 5: Тестирование системы импорта (Приоритет: Средний, 4 story points)

**Описание:** Написать comprehensive тесты для всей системы импорта.

**Файлы для изменения:**

- `tests/unit/test_services/test_xml_parser.py` - unit-тесты для парсера
- `tests/unit/test_services/test_product_processor.py` - unit-тесты для процессора
- `tests/integration/test_management_commands/test_import_catalog_from_1c.py` - интеграционные тесты
- `tests/performance/test_import_performance.py` - performance тесты

**Критерии приемки:**

- Все тесты проходят
- Покрытие кода ≥90% для критических модулей
- Performance тесты подтверждают обработку ≥1000 товаров

---

### Задача 6: Документирование и настройка окружения (Приоритет: Низкий, 1 story point)

**Описание:** Завершить документирование и настроить переменные окружения.

**Файлы для изменения:**

- `backend/.env.example` - добавить переменные окружения
- Обновить документацию при необходимости

**Критерии приемки:**

- Переменные окружения добавлены в .env.example
- Документация обновлена

**Добавляемые переменные окружения:**

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3
IMPORT_MAX_FILE_SIZE=100

# Безопасность
IMPORT_REQUIRE_CONFIRMATION=true

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

### Предлагаемый порядок выполнения

1. Задача 1: Создание модели ImportSession
2. Задача 2: Реализация XMLDataParser
3. Задача 3: Реализация ProductDataProcessor
4. Задача 4: Создание management-команды с валидацией
5. Задача 5: Тестирование системы импорта
6. Задача 6: Документирование и настройка окружения

## Dev Notes

### Story Context

**Epic Integration Points:**

- Интегрируется с: 1С:Управление торговлей
- Технология: Django Management Commands + XML/JSON parsing
- Следует паттерну: [`docs/prd/requirements.md#pricing`](../../prd/requirements.md#pricing) (FREESPORT ролевое ценообразование)
- Точки касания: Product model, User roles, sync logging
- См. также: [`docs/architecture/tech-stack.md`](../../architecture/tech-stack.md) (технологический стек)

### Technical Architecture

```python
# apps/products/models.py (дополнение)

# Обновление модели Product
class Product(models.Model):
    # ... существующие поля
    
    # Интеграция с 1С
    onec_id = models.CharField(
        'ID в 1С (SKU)', 
        max_length=255, 
        unique=True, 
        null=True, 
        blank=True,
        db_index=True,
        help_text='Составной ID из offers.xml (uuid#uuid)'
    )
    parent_onec_id = models.CharField(
        'ID базового товара в 1С', 
        max_length=255, 
        null=True, 
        blank=True,
        db_index=True,
        help_text='ID из goods.xml, используется для связи с базовым товаром'
    )
    sync_status = models.CharField(
        'Статус синхронизации',
        max_length=20,
        choices=[
            ('pending', 'Ожидает синхронизации'),
            ('synced', 'Синхронизирован'),
            ('error', 'Ошибка синхронизации'),
        ],
        default='pending'
    )
    last_sync_at = models.DateTimeField('Последняя синхронизация', null=True, blank=True)

# Новая модель ImportSession
class ImportSession(models.Model):
    class ImportType(models.TextChoices):
        CATALOG = 'catalog', 'Каталог товаров'
        STOCKS = 'stocks', 'Остатки товаров'
        PRICES = 'prices', 'Цены товаров'
    
    class ImportStatus(models.TextChoices):
        STARTED = 'started', 'Начато'
        COMPLETED = 'completed', 'Завершено'
        FAILED = 'failed', 'Ошибка'
    
    import_type = models.CharField(max_length=20, choices=ImportType.choices, default=ImportType.CATALOG)
    status = models.CharField(max_length=20, choices=ImportStatus.choices, default=ImportStatus.STARTED)
    started_at = models.DateTimeField(auto_now_add=True)
    finished_at = models.DateTimeField(null=True, blank=True)
    report_details = models.JSONField(default=dict, blank=True)
    error_message = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-started_at']

# apps/products/services/parser.py
class XMLDataParser:
    def parse(self, file_path):
        # returns list[dict]
        pass

# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id):
        self.session_id = session_id

    def process_data(self, data: list[dict]):
        # validation and db operations
        pass

# apps/products/management/commands/import_catalog_from_1c.py
class Command(BaseCommand):
    def handle(self, *args, **options):
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        parser = XMLDataParser()
        processor = ProductDataProcessor(session.id)
        
        raw_data = parser.parse(options['file'])
        processor.process_data(raw_data)
        
        session.status = ImportSession.ImportStatus.COMPLETED
        session.save()
```

### Domain Concepts & Data Structure

#### 1С:Управление торговлей

**1С:Управление торговлей** - это ERP-система для управления торговой деятельностью, которая выгружает данные в формате CommerceML 3.1. Система предоставляет полную информацию о товарах, ценах, остатках и контрагентах.

#### Ролевое ценообразование FREESPORT

**Ролевое ценообразование** - это система маппинга типов цен из 1С на роли пользователей в FREESPORT. Каждый тип цены из 1С соответствует определенной роли пользователя в системе.

##### Существующие поля цен в модели Product

Модель `Product` уже содержит все необходимые поля для ролевого ценообразования:

**Основные цены по ролям:**

- `retail_price` (Decimal, обязательное) - Розничная цена для B2C покупателей
- `opt1_price` (Decimal, nullable) - Оптовая цена уровень 1 (wholesale_level1)
- `opt2_price` (Decimal, nullable) - Оптовая цена уровень 2 (wholesale_level2)
- `opt3_price` (Decimal, nullable) - Оптовая цена уровень 3 (wholesale_level3)
- `trainer_price` (Decimal, nullable) - Цена для тренеров
- `federation_price` (Decimal, nullable) - Цена для представителей федерации

**Информационные цены для B2B:**

- `recommended_retail_price` (Decimal, nullable) - Рекомендованная розничная цена (RRP)
- `max_suggested_retail_price` (Decimal, nullable) - Максимальная рекомендованная цена (MSRP)

##### Маппинг типов цен из 1С на поля Product

**Информация по типам цен (из `priceLists.xml`):**

| Тип цены в 1С | Поле в Product | Роль пользователя | Примечание |
|---------------|----------------|-------------------|------------|
| `Опт 1 (300-600 тыс.руб в квартал)` | `opt1_price` | `wholesale_level1` | Оптовая цена уровень 1 |
| `Опт 2 (600-900 тыс.руб в квартал)` | `opt2_price` | `wholesale_level2` | Оптовая цена уровень 2 |
| `Опт 3 (900+ тыс.руб в квартал)` | `opt3_price` | `wholesale_level3` | Оптовая цена уровень 3 |
| `Тренерская` | `trainer_price` | `trainer` | Специальная цена для тренеров |
| `РРЦ` (Розничная цена) | `retail_price` | `retail` | Розничная цена для B2C |
| `РРЦ` (Рекомендованная) | `recommended_retail_price` | - | Информационная цена для B2B |
| `МРЦ` | `max_suggested_retail_price` | - | Максимальная цена для B2B |

**Внимание:** Тип цены для `federation_price` не найден в данных 1С. Используется fallback-логика: `recommended_retail_price` (РРЦ) → `federation_price`.

##### Модель PriceType для маппинга

Для гибкого маппинга типов цен из 1С создается справочная модель `PriceType`:

```python
# apps/products/models.py
class PriceType(models.Model):
    """
    Справочник типов цен из 1С для маппинга на поля Product
    """
    onec_id = models.CharField(
        'UUID типа цены в 1С',
        max_length=100,
        unique=True,
        help_text='UUID из priceLists.xml'
    )
    onec_name = models.CharField(
        'Название в 1С',
        max_length=200,
        help_text='Например: "Опт 1 (300-600 тыс.руб в квартал)"'
    )
    product_field = models.CharField(
        'Поле в модели Product',
        max_length=50,
        choices=[
            ('retail_price', 'Розничная цена'),
            ('opt1_price', 'Оптовая цена уровень 1'),
            ('opt2_price', 'Оптовая цена уровень 2'),
            ('opt3_price', 'Оптовая цена уровень 3'),
            ('trainer_price', 'Цена для тренера'),
            ('federation_price', 'Цена для представителя федерации'),
            ('recommended_retail_price', 'Рекомендованная розничная цена'),
            ('max_suggested_retail_price', 'Максимальная рекомендованная цена'),
        ],
        help_text='Поле Product, в которое мапится эта цена'
    )
    user_role = models.CharField(
        'Роль пользователя',
        max_length=50,
        blank=True,
        help_text='Роль пользователя, для которой применяется эта цена'
    )
    is_active = models.BooleanField('Активный', default=True)
    created_at = models.DateTimeField('Дата создания', auto_now_add=True)
    
    class Meta:
        verbose_name = 'Тип цены'
        verbose_name_plural = 'Типы цен'
        db_table = 'price_types'
        ordering = ['onec_name']
    
    def __str__(self):
        return f"{self.onec_name} → {self.product_field}"
```

#### Парсинг priceLists.xml для заполнения справочника PriceType

Перед импортом товаров необходимо загрузить справочник типов цен из `priceLists.xml`:

```python
# apps/products/services/parser.py
class PriceListParser:
    """Парсер для priceLists.xml"""
    
    def parse_price_lists(self, file_path: str) -> list[dict]:
        """Парсинг справочника типов цен"""
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        price_types = []
        for price_type_node in root.findall('.//ТипЦены'):
            price_type_data = {
                'onec_id': price_type_node.findtext('Ид'),
                'onec_name': price_type_node.findtext('Наименование'),
                'currency': price_type_node.findtext('Валюта', 'RUB'),
            }
            
            # Определяем маппинг на поле Product
            product_field = self.map_price_type_to_field(price_type_data['onec_name'])
            price_type_data['product_field'] = product_field
            
            price_types.append(price_type_data)
        
        return price_types
    
    def map_price_type_to_field(self, onec_name: str) -> str:
        """Маппинг названия типа цены из 1С на поле Product"""
        name_lower = onec_name.lower()
        
        if 'опт 1' in name_lower or 'опт1' in name_lower:
            return 'opt1_price'
        elif 'опт 2' in name_lower or 'опт2' in name_lower:
            return 'opt2_price'
        elif 'опт 3' in name_lower or 'опт3' in name_lower:
            return 'opt3_price'
        elif 'тренер' in name_lower:
            return 'trainer_price'
        elif 'ррц' in name_lower and 'рекомендован' in name_lower:
            return 'recommended_retail_price'
        elif 'ррц' in name_lower:
            return 'retail_price'
        elif 'мрц' in name_lower:
            return 'max_suggested_retail_price'
        else:
            # По умолчанию - розничная цена
            return 'retail_price'

# apps/products/services/processor.py
class PriceTypeProcessor:
    """Процессор для создания/обновления справочника PriceType"""
    
    def process_price_types(self, price_types_data: list[dict]):
        """Создание/обновление записей PriceType"""
        from apps.products.models import PriceType
        
        for price_type_data in price_types_data:
            PriceType.objects.update_or_create(
                onec_id=price_type_data['onec_id'],
                defaults={
                    'onec_name': price_type_data['onec_name'],
                    'product_field': price_type_data['product_field'],
                    'is_active': True,
                }
            )
```

**Использование в management-команде:**

```python
# apps/products/management/commands/import_catalog_from_1c.py
def handle(self, *args, **options):
    # Шаг 1: Загрузка справочника типов цен
    price_list_parser = PriceListParser()
    price_types_data = price_list_parser.parse_price_lists('priceLists/priceLists.xml')
    
    price_type_processor = PriceTypeProcessor()
    price_type_processor.process_price_types(price_types_data)
    
    self.stdout.write(f"Loaded {len(price_types_data)} price types")
    
    # Шаг 2: Импорт товаров...
```

#### Структура XML файлов от 1С

Данные из 1С поступают в формате CommerceML 3.1 и разделены по типам в разные файлы:

**Основные файлы:**

- `goods.xml` - основная информация о товарах (продуктах)
- `offers.xml` - торговые предложения (SKU), вариации товаров
- `prices.xml` - цены для каждого SKU
- `rests.xml` - остатки SKU на складах

**Справочники:**

- `priceLists/priceLists.xml` - справочник типов цен (критичен для маппинга)

**Структура goods.xml:**

```xml
<Каталог>
  <Товары>
    <Товар>
      <Ид>UUID-товара</Ид>
      <Артикул>Артикул товара</Артикул>
      <Наименование>Название товара</Наименование>
      <БазоваяЕдиница>Код единицы измерения</БазоваяЕдиница>
      <Группы>
        <Ид>UUID-категории</Ид>
      </Группы>
      <Описание>HTML-описание</Описание>
      <Картинка>backend/tests/fixtures/1c-data/goods/import_files/12/image.jpg</Картинка>
    </Товар>
  </Товары>
</Каталог>
```

**Примечание о путях к изображениям:**

- Формат пути: `backend/tests/fixtures/1c-data/goods/import_files/XY/[имя_файла]`
- где `XY` - первые две цифры из ID товара (UUID)
- Пример: для товара с ID `12345678-abcd-...` путь будет `backend/tests/fixtures/1c-data/goods/import_files/12/image.jpg`

**Структура prices.xml:**

```xml
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>UUID-товара или SKU</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>UUID-типа-цены</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>
```

**Маппинг типов цен на роли пользователей:**

- UUID типа цены из `priceLists.xml` маппится на роль пользователя в системе FREESPORT
- Пример: "Опт 1 (300-600 тыс.руб в квартал)" → `wholesale_level1`
- Fallback-логика: если цена для роли отсутствует, используется розничная цена

Подробное описание структуры данных см. в [`docs/architecture/20-1c-integration.md`](../../architecture/20-1c-integration.md) (Приложение А).

#### Chunk Processing Strategy

Для обработки больших объемов данных используется стратегия порционной обработки:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id, chunk_size=1000):
        self.session_id = session_id
        self.chunk_size = chunk_size
    
    def process_data(self, data: list[dict]):
        """Обработка данных порциями для оптимизации памяти"""
        for i in range(0, len(data), self.chunk_size):
            chunk = data[i:i + self.chunk_size]
            self.process_chunk(chunk)
    
    def process_chunk(self, chunk: list[dict]):
        """Обработка одной порции данных"""
        with transaction.atomic():
            for item in chunk:
                self.process_item(item)
```

Параметр `--chunk-size` в management-команде позволяет настраивать размер порции в зависимости от доступной памяти.

#### Двухэтапная обработка товаров

Система использует двухэтапную обработку для корректного создания товаров:

##### Этап 1: Создание заготовок из goods.xml

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def create_product_placeholder(self, goods_data: dict):
        """Создание заготовки товара из goods.xml"""
        product = Product.objects.create(
            parent_onec_id=goods_data['id'],  # Сохраняем ID базового товара
            name=goods_data['name'],  # Временное имя
            description=goods_data.get('description', ''),
            category_id=goods_data.get('category_id'),
            is_active=False  # Неактивен до обогащения данными
        )
        return product
```

##### Этап 2: Обогащение данными из offers.xml

```python
    def enrich_product_from_offer(self, offer_data: dict):
        """Обогащение товара данными из offers.xml"""
        # Извлекаем parent_onec_id из составного ID (uuid#uuid)
        onec_id = offer_data['id']  # Например: "parent-uuid#sku-uuid"
        parent_id = onec_id.split('#')[0] if '#' in onec_id else onec_id
        
        try:
            # Находим заготовку по parent_onec_id
            product = Product.objects.get(parent_onec_id=parent_id)
            
            # Обновляем финальными данными
            product.onec_id = onec_id  # Полный составной ID
            product.name = offer_data['name']  # Перезаписываем именем SKU
            product.sku = offer_data.get('sku')
            product.is_active = True
            product.save()
            
        except Product.DoesNotExist:
            self.log_error(f'Parent product not found for {parent_id}', offer_data)
```

#### Duplicate Handling Strategy

Стратегия обработки дубликатов товаров основана на поле `onec_id`:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def process_item(self, item_data: dict):
        """Обработка одного товара с проверкой на дубликаты"""
        onec_id = item_data.get('onec_id')
        
        if not onec_id:
            self.log_error('Missing onec_id', item_data)
            return
        
        try:
            # Поиск существующего товара
            product = Product.objects.get(onec_id=onec_id)
            # Обновление существующего товара
            self.update_product(product, item_data)
        except Product.DoesNotExist:
            # Создание нового товара
            self.create_product(item_data)
        except Product.MultipleObjectsReturned:
            # Обработка случая множественных дубликатов
            self.log_error(f'Multiple products found with onec_id={onec_id}', item_data)
    
    def update_product(self, product: Product, item_data: dict):
        """Обновление существующего товара"""
        # Обновляем только поля, которые могут изменяться
        product.name = item_data.get('name', product.name)
        product.description = item_data.get('description', product.description)
        # Обновляем цены и остатки
        self.update_prices(product, item_data)
        self.update_stock(product, item_data)
        product.save()
```

### Environment Variables

Для работы с импортом из 1С потребуются следующие переменные окружения:

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

### Testing

**Требования к тестированию:**

- Unit-тесты для изолированных компонентов (парсер, процессор)
- Интеграционные тесты для проверки взаимодействия компонентов
- Performance тесты для больших объемов данных (≥1000 товаров)
- Тесты обработки ошибок и логирования
- Тесты безопасности (XML Bomb, инъекции)

**Стандарты тестирования:**

- Использовать pytest с маркировкой @pytest.mark.unit и @pytest.mark.integration
- Применять Factory Boy для генерации тестовых данных
- Использовать mock-объекты для внешних зависимостей (файлы, API)
- Обеспечить изоляцию тестов с помощью транзакций

### Security Considerations

**Безопасность импорта данных из 1С:**

1. **Валидация XML структуры**: Все XML файлы должны проходить валидацию перед парсингом для предотвращения XML-инъекций
2. **Ограничение размера файлов**: Установить максимальный размер файлов для импорта (настроить через переменную окружения IMPORT_MAX_FILE_SIZE)
3. **Проверка прав доступа**: Только авторизованные пользователи с правами администратора могут запускать команды импорта
4. **Резервное копирование**: Перед началом импорта создавать резервную копию затрагиваемых данных
5. **Атомарность операций**: Использовать транзакции для обеспечения целостности данных при частичных сбоях
6. **Санитизация данных**: Очищать все текстовые поля от потенциально опасного содержимого

**Переменные окружения для безопасности:**

```bash
# Максимальный размер файла импорта (в MB)
IMPORT_MAX_FILE_SIZE=100

# Таймаут операции импорта (в секундах)
IMPORT_TIMEOUT=300

# Требовать подтверждение перед импортом
IMPORT_REQUIRE_CONFIRMATION=true

# Максимальное количество элементов в XML
XML_PARSER_MAX_ELEMENTS=10000
```

#### XML Bomb Protection

Защита от атак типа XML Bomb (Billion Laughs Attack):

```python
# apps/products/services/parser.py
import xml.etree.ElementTree as ET
from xml.dom import minidom

class XMLDataParser:
    def __init__(self):
        self.max_elements = int(os.environ.get('XML_PARSER_MAX_ELEMENTS', '10000'))
        self.element_count = 0
    
    def safe_xml_parse(self, file_path):
        """Безопасный парсинг XML с защитой от XML Bomb"""
        parser = ET.XMLParser(resolve_entities=False)
        
        # Ограничение количества элементов
        class SafeTreeBuilder(ET.TreeBuilder):
            def start(self, tag, attrs):
                if parser.element_count >= parser.max_elements:
                    raise ValueError(f"XML contains too many elements (max: {parser.max_elements})")
                parser.element_count += 1
                return super().start(tag, attrs)
        
        parser = ET.XMLParser(target=SafeTreeBuilder(), resolve_entities=False)
        tree = ET.parse(file_path, parser=parser)
        return tree
```

#### Data Sanitization

Санитизация данных для защиты от инъекций:

```python
# apps/products/services/processor.py
import bleach
from django.core.exceptions import ValidationError

class ProductDataProcessor:
    def sanitize_html_field(self, html_content: str) -> str:
        """Очистка HTML-контента в описаниях товаров"""
        if not html_content:
            return html_content
        
        # Разрешенные теги и атрибуты
        allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']
        allowed_attributes = {'*': ['class']}
        
        # Очистка HTML
        clean_html = bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )
        
        return clean_html
    
    def sanitize_text_field(self, text: str) -> str:
        """Очистка текстовых полей"""
        if not text:
            return text
        
        # Удаление потенциально опасных символов
        clean_text = text.strip()
        # Ограничение длины
        max_length = 1000
        if len(clean_text) > max_length:
            clean_text = clean_text[:max_length]
        
        return clean_text
    
    def validate_price_field(self, price_value) -> float:
        """Валидация и очистка цен"""
        try:
            price = float(price_value)
            if price < 0:
                raise ValidationError("Price cannot be negative")
            if price > 999999.99:
                raise ValidationError("Price too high")
            return round(price, 2)
        except (ValueError, TypeError):
            raise ValidationError("Invalid price format")
```

#### Access Control

Контроль доступа для запуска команд импорта:

```python
# apps/products/management/commands/import_catalog_from_1c.py
from django.contrib.auth.decorators import user_passes_test
from django.core.management.base import CommandError
from django.contrib.auth import get_user_model

User = get_user_model()

def is_superuser(user):
    """Проверка, что пользователь является суперпользователем"""
    return user.is_superuser

class Command(BaseCommand):
    help = "Импорт каталога товаров из файла 1С"
    
    def check_user_permissions(self, username):
        """Проверка прав доступа пользователя"""
        try:
            user = User.objects.get(username=username)
            if not user.is_superuser:
                raise CommandError(f"User {username} is not a superuser")
            return user
        except User.DoesNotExist:
            raise CommandError(f"User {username} does not exist")
    
    def handle(self, *args, **options):
        # Проверка прав доступа
        if options.get('username'):
            self.check_user_permissions(options['username'])
        else:
            self.stdout.write(
                self.style.WARNING('Warning: No username provided. '
                                 'Make sure you have proper permissions.')
            )
        
        # Продолжение выполнения команды
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        # ... остальной код
```

Для использования в коде:

```python
# apps/products/views.py
from django.contrib.auth.decorators import user_passes_test
from django.views.decorators.http import require_POST

@user_passes_test(is_superuser)
@require_POST
def trigger_import_view(request):
    """Представление для запуска импорта через веб-интерфейс"""
    # Проверка прав доступа уже выполнена декоратором
    pass
```

### Error Handling

**Стратегия обработки ошибок импорта:**

1. **Валидационные ошибки**:
   - Ошибки структуры XML: логировать с детализацией, продолжать обработку других файлов
   - Ошибки валидации данных: логировать с указанием поля и значения, пропускать запись

2. **Ошибки базы данных**:
   - Ошибки соединения: повторная попытка с экспоненциальным backedoff
   - Ошибки целостности: откат транзакции, логирование, остановка импорта

3. **Системные ошибки**:
   - Нехватка памяти: остановка импорта с уведомлением
   - Ошибки файловой системы: проверка прав доступа, логирование

4. **Логирование ошибок**:
   - Все ошибки логируются в ImportSession.error_details
   - Критические ошибки отправляют уведомление администратору
   - Создается отчет с детализацией всех ошибок импорта

#### Validation Errors

Детальная обработка ошибок валидации:

```python
# apps/products/services/processor.py
class ValidationError(Exception):
    """Класс для ошибок валидации данных"""
    def __init__(self, field, value, message, severity='error'):
        self.field = field
        self.value = value
        self.message = message
        self.severity = severity  # 'warning', 'error', 'critical'
        super().__init__(f"{field}: {message}")

class ProductDataProcessor:
    def validate_product_data(self, data: dict) -> list[ValidationError]:
        """Валидация данных товара с возвратом списка ошибок"""
        errors = []
        
        # Валидация обязательных полей
        required_fields = ['name', 'onec_id']
        for field in required_fields:
            if not data.get(field):
                errors.append(ValidationError(
                    field=field,
                    value=data.get(field),
                    message=f'{field} is required',
                    severity='error'
                ))
        
        # Валидация типов данных
        price_fields = ['retail_price', 'opt1_price', 'opt2_price', 'opt3_price',
                       'trainer_price', 'federation_price', 'recommended_retail_price',
                       'max_suggested_retail_price']
        for field in price_fields:
            if field in data and data[field] is not None:
                try:
                    price = float(data[field])
                    if price < 0:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} cannot be negative',
                            severity='error'
                        ))
                    elif price > 999999.99:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} is too high',
                            severity='warning'
                        ))
                except (ValueError, TypeError):
                    errors.append(ValidationError(
                        field=field,
                        value=data[field],
                        message=f'Invalid {field} format',
                        severity='error'
                    ))
        
        # Валидация длины текстовых полей
        text_fields = ['name', 'description', 'sku']
        for field in text_fields:
            if field in data and data[field]:
                max_length = 255 if field != 'description' else 5000
                if len(data[field]) > max_length:
                    errors.append(ValidationError(
                        field=field,
                        value=data[field][:50] + '...',
                        message=f'{field} is too long (max {max_length})',
                        severity='warning'
                    ))
        
        return errors
    
    def handle_validation_errors(self, errors: list[ValidationError], item_data: dict):
        """Обработка ошибок валидации"""
        critical_errors = [e for e in errors if e.severity == 'critical']
        error_errors = [e for e in errors if e.severity == 'error']
        warning_errors = [e for e in errors if e.severity == 'warning']
        
        # Критические ошибки - остановка обработки
        if critical_errors:
            raise Exception(f"Critical validation errors: {[e.message for e in critical_errors]}")
        
        # Ошибки - пропуск записи с логированием
        if error_errors:
            self.log_validation_errors(error_errors, item_data)
            return False  # Пропустить запись
        
        # Предупреждения - логировать, но продолжить обработку
        if warning_errors:
            self.log_validation_warnings(warning_errors, item_data)
        
        return True  # Продолжить обработку
```

**Уровни логирования:**

- INFO: успешные операции, статистика
- WARNING: пропущенные записи, некритичные ошибки
- ERROR: критические ошибки, требующие внимания
- CRITICAL: ошибки, остановившие импорт

### Dependencies

- **Blocks:** [`docs/stories/epic-3/3.1.2.loading-scripts.md`](3.1.2.loading-scripts.md) (скрипты загрузки)
- **Depends on:** [`docs/stories/epic-1/1.8.database-design.md`](../epic-1/1.8.database-design.md) (Database design)
- **Related:**
  - [`docs/architecture/source-tree.md`](../../architecture/source-tree.md) (структура проекта)
  - [`docs/architecture/coding-standards.md`](../../architecture/coding-standards.md) (стандарты кодирования Django)
  - [`docs/prd/requirements.md`](../../prd/requirements.md) (требования к интеграции с 1С)
  - [`docs/epics/epic-3/parser-plan.md`](../../epics/epic-3/parser-plan.md) (план разработки парсеров)

## Story Points

**14** (Complexity increased due to combined validation task)

## Priority

**High** - Критический путь для Epic 3

## Labels

`epic-3` `1c-integration` `product-management` `django-commands` `refactoring`

## Change Log

| Дата | Версия | Описание | Автор |
|------|--------|----------|-------|
| 2025-09-07 | 1.0 | Первоначальная версия истории | Product Owner |
| 2025-10-09 | 1.1 | Исправление путей к тестовым данным, унификация названия команды | Product Owner |
| 2025-10-10 | 1.2 | Добавление разделов Security Considerations и Error Handling, интеграция валидаторов в процессор, добавление примеров тестов | Product Owner |
| 2025-10-10 | 1.3 | Объединение задач (AC: 3) и (AC: 5), изменение нумерации задач, обновление критериев приемки | Product Owner |
| 2025-10-10 | 1.4 | Добавлено поле parent_onec_id в модель Product для двухэтапной обработки товаров (goods.xml → offers.xml) | Product Owner |
| 2025-10-10 | 1.5 | Документированы существующие поля цен, добавлена модель PriceType и парсинг priceLists.xml для маппинга типов цен из 1С | Product Owner |
| 2025-10-10 | 1.6 | Исправлена структура тестовых данных в соответствии с реальным расположением файлов (все XML в поддиректориях) | Product Owner |

## Dev Agent Record

### Agent Model Used

James - Full Stack Developer (dev agent)

### Completion Notes

### File List

- backend/apps/products/models.py - добавлены 1С интеграционные поля
- backend/apps/products/migrations/0009_add_1c_integration_fields.py - миграция БД
- backend/tests/unit/test_models/test_product_models.py - добавлены тесты для новых полей
- ../../architecture/source-tree.md - исправлены пути к тестам
- ../epic-2/2.5.product-detail-api.md - исправлены пути к тестам

## QA Results

### Review Date: 2025-09-23

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation of the `Product` model update is of high quality. The code is clean, follows project conventions, and includes appropriate database indexes for performance.

### Refactoring Performed

No refactoring was necessary as the code quality is high.

### Compliance Check

- Coding Standards: [✓]
- Project Structure: [✓]
- Testing Strategy: [✓]
- All ACs Met: [✗] (Only a part of AC #1 is complete)

### Improvements Checklist

The following items represent the remaining work required to complete this story:

- [ ] Add `parent_onec_id` field to the `Product` model (AC #1)
- [ ] Create the `ImportSession` model (AC #1)
- [ ] Create the `PriceType` model for price mapping (AC #4)
- [ ] Implement parsing of `priceLists.xml` to populate `PriceType` (AC #4)
- [ ] Implement the `XMLDataParser` and `ProductDataProcessor` (AC #2)
- [ ] Create the `import_catalog_from_1c` management command with validation (AC #3, #5)
- [ ] Implement price mapping from `prices.xml` to Product fields using PriceType (AC #4)
- [ ] Implement fallback logic for `federation_price` (AC #4)
- [ ] Implement detailed logging into `ImportSession` (AC #5)
- [ ] Write integration tests for the complete workflow (AC #6)

### Security Review

No security implications were found in the current changes.

### Performance Considerations

Database indexes have been correctly added for the new fields, which satisfies performance considerations for this change.

### Files Modified During Review

None.

### Gate Status

Gate: CONCERNS → docs/qa/gates/3.1.1-import-products-structure.yml

### Recommended Status

[✗ Changes Required - See unchecked items above]

# Story 3.1.1: import-products-structure

## Status

✅ Done

## Story

**As a** разработчик,
**I want** создать систему импорта товаров из 1С,
**so that** каталог автоматически синхронизируется с ERP системой.

## Acceptance Criteria

1. Обновлены **существующие** модели `Product`, `Category`, `Brand` и создана модель `ImportSession` для поддержки интеграции.
2. Логика импорта разделена на архитектуру Парсер/Процессор.
3. Создана **базовая** management-команда `import_catalog_from_1c` с валидацией данных и сессиями импорта (параметры: --data-dir, --dry-run).
4. Реализована логика обработки ролевого ценообразования.
5. Настроено детальное логирование процесса импорта в `ImportSession`.
6. Написаны unit и integration тесты для всего функционала.
7. Импорт поддерживает сегментированные выгрузки 1С с именами вида `goods_*.xml`, `offers_*.xml`, `prices_*.xml`, `rests_*.xml`, `priceLists_*.xml` и корректно обрабатывает несколько файлов каждого типа.

## Tasks / Subtasks

- [x] **Обновить существующие модели для интеграции (AC: 1)**
  
  - [x] **Brand (существующая модель в models.py):**
    - [x] Добавить `onec_id = CharField(max_length=100, unique=True, null=True, blank=True, db_index=True)`
    - [x] Создать миграцию `add_onec_id_to_brand` (уже было в 0009)
  
  - [x] **Category (существующая модель в models.py):**
    - [x] Добавить `onec_id = CharField(max_length=100, unique=True, null=True, blank=True, db_index=True)`
    - [x] Создать миграцию `add_onec_id_to_category` (уже было в 0009)
  
  - [x] **Product (существующая модель в models.py):**
    - [x] Добавить поля: `onec_id`, `parent_onec_id`, `sync_status`, `last_sync_at`, `error_message`
    - [x] Добавить enum `SyncStatus` с choices
    - [x] Создать миграцию `add_1c_integration_fields` (уже было в 0009)
    - [x] Добавить индексы: onec_id, parent_onec_id, sync_status
  
  - [x] **ImportSession (новая модель в models.py):**
    - [x] Добавить в конец файла models.py
    - [x] Определить enums: ImportType, ImportStatus
    - [x] Определить поля: import_type, status, started_at, finished_at, report_details, error_message
    - [x] Создать миграцию `add_import_session` (создана 0011)
    - [x] Добавить индексы
  
  **Последовательность миграций**

    ```bash
    python manage.py makemigrations products --name add_onec_id_to_brand
    python manage.py makemigrations products --name add_onec_id_to_category
    python manage.py makemigrations products --name add_1c_integration_fields
    python manage.py makemigrations products --name add_import_session
    python manage.py migrate
    ```

- [x] **Создать сервисный слой (AC: 2)**
  - [x] Создать директорию `backend/apps/products/services/`
  - [x] Создать `services/__init__.py`
  - [x] Создать `services/parser.py` с классом `XMLDataParser` для файлов `goods.xml`, `offers.xml`, `prices.xml`, `rests.xml`
  - [x] Создать `services/processor.py` с классом `ProductDataProcessor`, который принимает данные от парсера

- [x] **Создать базовую команду `import_catalog_from_1c` (AC: 3, 5)**
  - [x] Создать файл `backend/apps/products/management/commands/import_catalog_from_1c.py`
  - [x] Реализовать **базовые** параметры:
    - [x] `--data-dir` - путь к директории с XML файлами (обязательный)
    - [x] `--dry-run` - тестовый запуск без записи в БД
  - [x] Реализовать валидацию структуры директории (проверка наличия goods/, offers/, prices/, rests/)
  - [x] Добавить поиск файлов по шаблонам `goods_*.xml`, `offers_*.xml`, `prices_*.xml`, `rests_*.xml`, `priceLists_*.xml` и последовательную обработку множества файлов одного типа
  - [x] Команда должна создавать запись `ImportSession` в начале работы
  - [x] Команда должна оркестрировать вызов `XMLDataParser` и `ProductDataProcessor`
  - [x] Реализовать последовательный парсинг файлов:
    1. Parse `goods.xml` → create Product placeholders (parent_onec_id, is_active=False)
    2. Parse `offers.xml` → enrich Products (onec_id, is_active=True)
    3. Parse `prices.xml` → update prices
    4. Parse `rests.xml` → update stock
  - [x] В конце работы команда обновляет статус `ImportSession` (`completed` или `failed`)
  - [x] В `ProductDataProcessor` добавить валидатор уникальности `onec_id`
  - [x] В `ProductDataProcessor` добавить валидатор обязательных полей
  - [x] Обеспечить генерацию уникального slug при создании placeholder
    - [x] В `create_product_placeholder()` вычислять slug через `slugify` перед созданием `Product`
    - [x] При наличии дубликата slug добавлять уникальный суффикс (например, `-<uuid>`), пока значение не станет уникальным
    - [x] Передавать итоговый slug в конструктор `Product(...)`
    - [x] Рассмотреть вынесение алгоритма в `Product.save()` с циклической проверкой и суффиксом для единообразной обработки дубликатов

**Примечание:** Расширенные параметры (--chunk-size, --skip-validation) будут добавлены в Story 3.1.2

- [x] **Реализовать обработку цен (AC: 4)**
  - [x] Создать модель `PriceType` для маппинга типов цен из 1С на роли пользователей
  - [x] Создать миграцию для модели `PriceType` (создана 0011)
  - [x] Реализовать парсинг `priceLists.xml` для заполнения справочника `PriceType`
  - [x] В `ProductDataProcessor` реализовать маппинг цен из `prices.xml` на существующие поля модели `Product`
  - [x] Реализовать fallback-логику для `federation_price`:
    - Если цена для `federation_price` отсутствует, использовать `recommended_retail_price` (РРЦ)

- [x] **Настроить логирование (AC: 6)**
  - [x] В `ProductDataProcessor` логировать ошибки валидации и статистику в `ImportSession.report_details`.

- [x] **Создать тесты (AC: 7)**
  - [x] Unit-тесты для `XMLDataParser` с проверкой структуры XML файлов.
  - [x] Unit-тесты для `ProductDataProcessor` с проверкой валидации и маппинга цен.
  - [x] Интеграционные тесты для команды `import_catalog_from_1c` с тестовыми данными.
  - [x] Тесты обработки ошибок импорта и логирования в `ImportSession`.
  - [x] Тесты ролевого ценообразования с fallback-логикой.
  - [ ] Performance тесты для больших объемов данных (≥1000 товаров) - отложены на Story 3.1.2.

## Definition of Done

- [x] Команда успешно импортирует тестовые данные товаров, включая сегментированные выгрузки с несколькими `*_*.xml` файлами на тип
- [x] Все тесты проходят с покрытием ≥90% (критические модули ≥90% по [`docs/architecture/10-testing-strategy.md`](../../architecture/10-testing-strategy.md))
- [x] Логируются все операции импорта в `ImportSession`
- [x] Код прошел code review
- [x] Документация обновлена
- [x] Rollback процедуры документированы
- [x] Security considerations реализованы

## Security Considerations

### XML Parsing Security

**Защита от XML-атак:**

- **XML Injection/XXE Prevention**: Использовать `defusedxml` library вместо стандартного `xml.etree.ElementTree`
- **XML Schema Validation**: Валидировать структуру XML перед обработкой
- **File Size Limits**: Ограничить максимальный размер XML файлов (настройка `IMPORT_MAX_FILE_SIZE`)
- **Input Sanitization**: Валидировать все входные данные перед записью в БД

**Реализация в XMLDataParser:**

```python
# apps/products/services/parser.py
import defusedxml.ElementTree as ET
from django.conf import settings

class XMLDataParser:
    MAX_FILE_SIZE = settings.IMPORT_MAX_FILE_SIZE * 1024 * 1024  # MB to bytes
    
    def parse(self, file_path: str) -> list[dict]:
        # Проверка размера файла
        file_size = os.path.getsize(file_path)
        if file_size > self.MAX_FILE_SIZE:
            raise ValueError(f"File size {file_size} exceeds limit {self.MAX_FILE_SIZE}")
        
        # Безопасный парсинг с defusedxml
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
        except ET.ParseError as e:
            raise ValueError(f"Invalid XML structure: {e}")
        
        # Валидация структуры
        self._validate_xml_structure(root)
        
        return self._extract_data(root)
```

### Data Validation

- **Уникальность onec_id**: Валидация в `ProductDataProcessor` перед сохранением
- **Обязательные поля**: Проверка наличия критичных полей (name, sku, category)
- **Типы данных**: Валидация типов (цены должны быть Decimal, количество — Integer)
- **SQL Injection Prevention**: Использование Django ORM (автоматическая защита)

### Access Control

- **Management Command**: Доступна только администраторам сервера
- **File System Access**: Валидация путей к файлам (предотвращение path traversal)
- **Dry-run Mode**: Обязательное тестирование перед production импортом

## Rollback Procedures

### Откат миграций базы данных

**Если необходимо откатить изменения в БД:**

```bash
# 1. Откат всех миграций Story 3.1.1
python manage.py migrate products 0005  # откат до миграции перед add_onec_id_to_brand

# 2. Откат конкретной миграции
python manage.py migrate products 0005_previous_migration

# 3. Проверка текущего состояния миграций
python manage.py showmigrations products
```

**Последовательность отката (обратный порядок):**

1. `python manage.py migrate products <номер_до_add_import_session>`
2. `python manage.py migrate products <номер_до_add_1c_integration_fields>`
3. `python manage.py migrate products <номер_до_add_onec_id_to_category>`
4. `python manage.py migrate products <номер_до_add_onec_id_to_brand>`

### Очистка данных импорта

**Если импорт прошел с ошибками:**

```python
# Django shell
python manage.py shell

# Удаление failed сессий импорта
from apps.products.models import ImportSession
ImportSession.objects.filter(status='failed').delete()

# Удаление товаров с ошибками синхронизации
from apps.products.models import Product
Product.objects.filter(sync_status='error').update(sync_status='pending', error_message='')

# Полная очистка данных импорта (ОСТОРОЖНО!)
Product.objects.filter(onec_id__isnull=False).update(
    onec_id=None,
    parent_onec_id=None,
    sync_status='pending',
    last_sync_at=None,
    error_message=''
)
```

### Мониторинг после деплоя

**Метрики для отслеживания:**

```python
# Проверка статуса импортов
from apps.products.models import ImportSession
from django.utils import timezone
from datetime import timedelta

# Импорты за последние 24 часа
recent_imports = ImportSession.objects.filter(
    started_at__gte=timezone.now() - timedelta(hours=24)
)

total = recent_imports.count()
completed = recent_imports.filter(status='completed').count()
failed = recent_imports.filter(status='failed').count()

failure_rate = (failed / total * 100) if total > 0 else 0

if failure_rate > 10:
    # ALERT: Рассмотреть rollback
    print(f"⚠️ High failure rate: {failure_rate:.2f}%")
```

## Testing Strategy

### Подход к тестированию

Тестирование импорта из 1С следует стратегии, описанной в [`docs/architecture/10-testing-strategy.md`](../../architecture/10-testing-strategy.md):

- Unit-тесты для изолированных компонентов
- Интеграционные тесты для проверки взаимодействия
- Performance тесты для больших объемов данных

### Ключевые тестовые сценарии

#### 1. Unit-тесты для XMLDataParser

```python
# tests/unit/test_services/test_xml_parser.py
@pytest.mark.unit
class TestXMLDataParser:
    def test_parse_goods_xml_structure(self):
        """Проверка корректного парсинга структуры goods.xml"""
        
    def test_parse_prices_xml_with_role_mapping(self):
        """Проверка маппинга типов цен на роли пользователей"""
        
    def test_handle_malformed_xml_gracefully(self):
        """Проверка обработки некорректного XML"""
```

#### 2. Unit-тесты для ProductDataProcessor

```python
# tests/unit/test_services/test_product_processor.py
@pytest.mark.unit
class TestProductDataProcessor:
    def test_validate_unique_onec_id(self):
        """Проверка валидации уникальности onec_id"""
        
    def test_two_stage_product_creation(self):
        """Проверка двухэтапного создания товара"""
        processor = ProductDataProcessor(session_id=1)
        
        # Этап 1: Создание заготовки из goods.xml
        goods_data = {
            'id': 'parent-uuid-123',
            'name': 'Base Product Name',
            'description': 'Product description',
            'category_id': 1
        }
        product = processor.create_product_placeholder(goods_data)
        
        assert product.parent_onec_id == 'parent-uuid-123'
        assert product.name == 'Base Product Name'
        assert product.is_active is False
        assert product.onec_id is None  # Еще не установлен
        
        # Этап 2: Обогащение данными из offers.xml
        offer_data = {
            'id': 'parent-uuid-123#sku-uuid-456',
            'name': 'Product Name with Size M',
            'sku': 'PROD-001-M'
        }
        processor.enrich_product_from_offer(offer_data)
        
        product.refresh_from_db()
        assert product.onec_id == 'parent-uuid-123#sku-uuid-456'
        assert product.name == 'Product Name with Size M'  # Перезаписано
        assert product.sku == 'PROD-001-M'
        assert product.is_active is True
        
    def test_map_prices_to_user_roles(self):
        """Проверка маппинга цен на роли пользователей"""
        
    def test_federation_price_fallback(self):
        """Проверка fallback-логики для federation_price"""
        # Создаем тестовые данные без цены для federation_price
        product_data = {
            'name': 'Test Product',
            'retail_price': 1000.00,
            'recommended_retail_price': 1200.00,  # РРЦ
            'opt1_price': 800.00,
            'opt2_price': 750.00,
            'trainer_price': 700.00,
            # federation_price отсутствует
        }
        
        # Проверяем что для federation_price используется recommended_retail_price
        processor = ProductDataProcessor(session_id=1)
        processed_data = processor.process_price_mapping(product_data)
        
        assert processed_data['federation_price'] == 1200.00  # recommended_retail_price
```

#### 3. Интеграционные тесты для команды import_catalog_from_1c

```python
# tests/integration/test_management_commands/test_import_catalog_from_1c.py
@pytest.mark.django_db
@pytest.mark.integration
class TestImportCatalogCommand:
    def test_successful_import_with_test_data(self):
        """Проверка успешного импорта тестовых данных"""
        
    def test_import_creates_import_session_with_correct_status(self):
        """Проверка создания ImportSession с корректным статусом"""
        
    def test_import_logs_errors_to_import_session(self):
        """Проверка логирования ошибок в ImportSession"""
```

#### 4. Performance тесты

```python
# tests/performance/test_import_performance.py
@pytest.mark.django_db
@pytest.mark.slow
class TestImportPerformance:
    def test_import_1000_products_within_timeout(self):
        """Проверка импорта 1000 товаров в допустимое время"""
        
    def test_memory_usage_stable_during_large_import(self):
        """Проверка стабильного использования памяти при большом импорте"""
```

### Тестовые данные

Для тестирования используются примеры XML файлов, расположенные в директории `backend/tests/fixtures/1c-data/`:

**Структура тестовых данных:**

```text
backend/tests/fixtures/1c-data/
├── goods/
│   ├── goods.xml или goods_1_*.xml   # Базовые товары (в проде сегментируются на несколько файлов)
│   └── import_files/
│       ├── 01/                       # Изображения товаров с ID начинающимся на 01
│       ├── 12/                       # Изображения товаров с ID начинающимся на 12
│       └── [XY]/                     # Директории по первым двум цифрам UUID товара
├── groups/
│   └── groups.xml                    # Категории товаров
├── offers/
│   └── offers.xml или offers_*.xml   # Торговые предложения (SKU)
├── prices/
│   └── prices.xml или prices_*.xml   # Цены для SKU
├── rests/
│   └── rests.xml или rests_*.xml     # Остатки на складах
├── priceLists/
│   └── priceLists.xml или priceLists_*.xml  # Справочник типов цен
├── storages/
│   └── storages.xml                  # Справочник складов
├── units/
│   └── units.xml                     # Справочник единиц измерения
├── contragents/
│   └── contragents.xml               # Справочник контрагентов
├── propertiesGoods/
│   └── propertiesGoods_*.xml         # Свойства товаров (9 файлов)
└── propertiesOffers/
    └── propertiesOffers_*.xml        # Свойства предложений (2 файла)
```

**Примечание:** Тестовые XML файлы должны содержать минимальный набор данных для проверки всех сценариев импорта, включая:

- Товары с различными типами цен
- SKU с характеристиками (размер, цвет)
- Остатки на нескольких складах
- Корректные и некорректные данные для проверки валидации

### Требования к покрытию

- Общее покрытие: ≥70%
- Покрытие критических модулей: ≥90%
  - `apps.products.services.parser`
  - `apps.products.services.processor`
  - `apps.products.management.commands.import_catalog_from_1c`
  - `apps.products.models.ImportSession`

### Mock Objects

Использование mock-объектов для тестирования:

```python
# tests/unit/test_services/test_xml_parser.py
import pytest
from unittest.mock import mock_open, patch

@pytest.fixture
def mock_xml_file():
    return """<?xml version="1.0" encoding="UTF-8"?>
<Каталог>
  <Товары>
    <Товар>
      <Ид>test-uuid</Ид>
      <Наименование>Test Product</Наименование>
      <Артикул>TEST-001</Артикул>
    </Товар>
  </Товары>
</Каталог>"""

@pytest.fixture
def mock_prices_xml():
    return """<?xml version="1.0" encoding="UTF-8"?>
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>test-uuid</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>retail-uuid</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>"""

def test_xml_parser_with_mock(mock_xml_file):
    """Тестирование парсера с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_xml_file)):
        parser = XMLDataParser()
        result = parser.parse("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['name'] == 'Test Product'
        assert result[0]['sku'] == 'TEST-001'

def test_prices_parser_with_mock(mock_prices_xml):
    """Тестирование парсера цен с mock XML файлом"""
    with patch("builtins.open", mock_open(read_data=mock_prices_xml)):
        parser = XMLDataParser()
        result = parser.parse_prices("dummy_path.xml")
        
        assert len(result) == 1
        assert result[0]['retail_price'] == 1000.00
```

### Запуск тестов

```bash
# Запуск всех тестов импорта
pytest tests/unit/test_services/test_xml_parser.py tests/unit/test_services/test_product_processor.py tests/integration/test_management_commands/test_import_catalog_from_1c.py -v

# Запуск с покрытием
pytest --cov=apps.products.services --cov=apps.products.management.commands --cov-report=html

# Запуск performance тестов
pytest tests/performance/test_import_performance.py -v
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-13 | 1.0 | Initial story draft created | PO |
| 2025-10-13 | 1.1 | Removed duplicate "Разбиение на задачи" section, renamed to "Tasks / Subtasks" | PO |
| 2025-10-13 | 1.2 | Added Security Considerations, Rollback Procedures, and Change Log sections | PO |

## Dev Notes

### Story Context

**Epic Integration Points:**

- Интегрируется с: 1С:Управление торговлей
- Технология: Django Management Commands + XML/JSON parsing
- Следует паттерну: [`docs/prd/requirements.md#pricing`](../../prd/requirements.md#pricing) (FREESPORT ролевое ценообразование)
- Точки касания: Product model, User roles, sync logging
- См. также: [`docs/architecture/tech-stack.md`](../../architecture/tech-stack.md) (технологический стек)

### Technical Architecture

```python
# apps/products/models.py (дополнение)

# Обновление модели Product
class Product(models.Model):
    # ... существующие поля
    
    # Интеграция с 1С
    onec_id = models.CharField(
        'ID в 1С (SKU)', 
        max_length=255, 
        unique=True, 
        null=True, 
        blank=True,
        db_index=True,
        help_text='Составной ID из offers.xml (uuid#uuid)'
    )
    parent_onec_id = models.CharField(
        'ID базового товара в 1С', 
        max_length=255, 
        null=True, 
        blank=True,
        db_index=True,
        help_text='ID из goods.xml, используется для связи с базовым товаром'
    )
    sync_status = models.CharField(
        'Статус синхронизации',
        max_length=20,
        choices=[
            ('pending', 'Ожидает синхронизации'),
            ('synced', 'Синхронизирован'),
            ('error', 'Ошибка синхронизации'),
        ],
        default='pending'
    )
    last_sync_at = models.DateTimeField('Последняя синхронизация', null=True, blank=True)

# Новая модель ImportSession
class ImportSession(models.Model):
    class ImportType(models.TextChoices):
        CATALOG = 'catalog', 'Каталог товаров'
        STOCKS = 'stocks', 'Остатки товаров'
        PRICES = 'prices', 'Цены товаров'
    
    class ImportStatus(models.TextChoices):
        STARTED = 'started', 'Начато'
        COMPLETED = 'completed', 'Завершено'
        FAILED = 'failed', 'Ошибка'
    
    import_type = models.CharField(max_length=20, choices=ImportType.choices, default=ImportType.CATALOG)
    status = models.CharField(max_length=20, choices=ImportStatus.choices, default=ImportStatus.STARTED)
    started_at = models.DateTimeField(auto_now_add=True)
    finished_at = models.DateTimeField(null=True, blank=True)
    report_details = models.JSONField(default=dict, blank=True)
    error_message = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-started_at']

# apps/products/services/parser.py
class XMLDataParser:
    def parse(self, file_path):
        # returns list[dict]
        pass

# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id):
        self.session_id = session_id

    def process_data(self, data: list[dict]):
        # validation and db operations
        pass

# apps/products/management/commands/import_catalog_from_1c.py
class Command(BaseCommand):
    def handle(self, *args, **options):
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        parser = XMLDataParser()
        processor = ProductDataProcessor(session.id)
        
        raw_data = parser.parse(options['file'])
        processor.process_data(raw_data)
        
        session.status = ImportSession.ImportStatus.COMPLETED
        session.save()
```

### Domain Concepts & Data Structure

#### 1С:Управление торговлей

**1С:Управление торговлей** - это ERP-система для управления торговой деятельностью, которая выгружает данные в формате CommerceML 3.1. Система предоставляет полную информацию о товарах, ценах, остатках и контрагентах.

#### Ролевое ценообразование FREESPORT

**Ролевое ценообразование** - это система маппинга типов цен из 1С на роли пользователей в FREESPORT. Каждый тип цены из 1С соответствует определенной роли пользователя в системе.

##### Существующие поля цен в модели Product

Модель `Product` уже содержит все необходимые поля для ролевого ценообразования:

**Основные цены по ролям:**

- `retail_price` (Decimal, обязательное) - Розничная цена для B2C покупателей
- `opt1_price` (Decimal, nullable) - Оптовая цена уровень 1 (wholesale_level1)
- `opt2_price` (Decimal, nullable) - Оптовая цена уровень 2 (wholesale_level2)
- `opt3_price` (Decimal, nullable) - Оптовая цена уровень 3 (wholesale_level3)
- `trainer_price` (Decimal, nullable) - Цена для тренеров
- `federation_price` (Decimal, nullable) - Цена для представителей федерации

**Информационные цены для B2B:**

- `recommended_retail_price` (Decimal, nullable) - Рекомендованная розничная цена (RRP)
- `max_suggested_retail_price` (Decimal, nullable) - Максимальная рекомендованная цена (MSRP)

##### Маппинг типов цен из 1С на поля Product

**Информация по типам цен (из `priceLists.xml`):**

| Тип цены в 1С | Поле в Product | Роль пользователя | Примечание |
|---------------|----------------|-------------------|------------|
| `Опт 1 (300-600 тыс.руб в квартал)` | `opt1_price` | `wholesale_level1` | Оптовая цена уровень 1 |
| `Опт 2 (600-900 тыс.руб в квартал)` | `opt2_price` | `wholesale_level2` | Оптовая цена уровень 2 |
| `Опт 3 (900+ тыс.руб в квартал)` | `opt3_price` | `wholesale_level3` | Оптовая цена уровень 3 |
| `Тренерская` | `trainer_price` | `trainer` | Специальная цена для тренеров |
| `РРЦ` (Розничная цена) | `retail_price` | `retail` | Розничная цена для B2C |
| `РРЦ` (Рекомендованная) | `recommended_retail_price` | - | Информационная цена для B2B |
| `МРЦ` | `max_suggested_retail_price` | - | Максимальная цена для B2B |

**Внимание:** Тип цены для `federation_price` не найден в данных 1С. Используется fallback-логика: `recommended_retail_price` (РРЦ) → `federation_price`.

##### Модель PriceType для маппинга

Для гибкого маппинга типов цен из 1С создается справочная модель `PriceType`:

```python
# apps/products/models.py
class PriceType(models.Model):
    """
    Справочник типов цен из 1С для маппинга на поля Product
    """
    onec_id = models.CharField(
        'UUID типа цены в 1С',
        max_length=100,
        unique=True,
        help_text='UUID из priceLists.xml'
    )
    onec_name = models.CharField(
        'Название в 1С',
        max_length=200,
        help_text='Например: "Опт 1 (300-600 тыс.руб в квартал)"'
    )
    product_field = models.CharField(
        'Поле в модели Product',
        max_length=50,
        choices=[
            ('retail_price', 'Розничная цена'),
            ('opt1_price', 'Оптовая цена уровень 1'),
            ('opt2_price', 'Оптовая цена уровень 2'),
            ('opt3_price', 'Оптовая цена уровень 3'),
            ('trainer_price', 'Цена для тренера'),
            ('federation_price', 'Цена для представителя федерации'),
            ('recommended_retail_price', 'Рекомендованная розничная цена'),
            ('max_suggested_retail_price', 'Максимальная рекомендованная цена'),
        ],
        help_text='Поле Product, в которое мапится эта цена'
    )
    user_role = models.CharField(
        'Роль пользователя',
        max_length=50,
        blank=True,
        help_text='Роль пользователя, для которой применяется эта цена'
    )
    is_active = models.BooleanField('Активный', default=True)
    created_at = models.DateTimeField('Дата создания', auto_now_add=True)
    
    class Meta:
        verbose_name = 'Тип цены'
        verbose_name_plural = 'Типы цен'
        db_table = 'price_types'
        ordering = ['onec_name']
    
    def __str__(self):
        return f"{self.onec_name} → {self.product_field}"
```

#### Парсинг priceLists.xml для заполнения справочника PriceType

Перед импортом товаров необходимо загрузить справочник типов цен из `priceLists.xml`:

```python
# apps/products/services/parser.py
class PriceListParser:
    """Парсер для priceLists.xml"""
    
    def parse_price_lists(self, file_path: str) -> list[dict]:
        """Парсинг справочника типов цен"""
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        price_types = []
        for price_type_node in root.findall('.//ТипЦены'):
            price_type_data = {
                'onec_id': price_type_node.findtext('Ид'),
                'onec_name': price_type_node.findtext('Наименование'),
                'currency': price_type_node.findtext('Валюта', 'RUB'),
            }
            
            # Определяем маппинг на поле Product
            product_field = self.map_price_type_to_field(price_type_data['onec_name'])
            price_type_data['product_field'] = product_field
            
            price_types.append(price_type_data)
        
        return price_types
    
    def map_price_type_to_field(self, onec_name: str) -> str:
        """Маппинг названия типа цены из 1С на поле Product"""
        name_lower = onec_name.lower()
        
        if 'опт 1' in name_lower or 'опт1' in name_lower:
            return 'opt1_price'
        elif 'опт 2' in name_lower or 'опт2' in name_lower:
            return 'opt2_price'
        elif 'опт 3' in name_lower or 'опт3' in name_lower:
            return 'opt3_price'
        elif 'тренер' in name_lower:
            return 'trainer_price'
        elif 'ррц' in name_lower and 'рекомендован' in name_lower:
            return 'recommended_retail_price'
        elif 'ррц' in name_lower:
            return 'retail_price'
        elif 'мрц' in name_lower:
            return 'max_suggested_retail_price'
        else:
            # По умолчанию - розничная цена
            return 'retail_price'

# apps/products/services/processor.py
class PriceTypeProcessor:
    """Процессор для создания/обновления справочника PriceType"""
    
    def process_price_types(self, price_types_data: list[dict]):
        """Создание/обновление записей PriceType"""
        from apps.products.models import PriceType
        
        for price_type_data in price_types_data:
            PriceType.objects.update_or_create(
                onec_id=price_type_data['onec_id'],
                defaults={
                    'onec_name': price_type_data['onec_name'],
                    'product_field': price_type_data['product_field'],
                    'is_active': True,
                }
            )
```

**Использование в management-команде:**

```python
# apps/products/management/commands/import_catalog_from_1c.py
def handle(self, *args, **options):
    # Шаг 1: Загрузка справочника типов цен
    price_list_parser = PriceListParser()
    price_types_data = price_list_parser.parse_price_lists('priceLists/priceLists.xml')
    
    price_type_processor = PriceTypeProcessor()
    price_type_processor.process_price_types(price_types_data)
    
    self.stdout.write(f"Loaded {len(price_types_data)} price types")
    
    # Шаг 2: Импорт товаров...
```

#### Структура XML файлов от 1С

Данные из 1С поступают в формате CommerceML 3.1 и разделены по типам в разные файлы:

**Основные файлы:**

- `goods.xml` - основная информация о товарах (продуктах)
- `offers.xml` - торговые предложения (SKU), вариации товаров
- `prices.xml` - цены для каждого SKU
- `rests.xml` - остатки SKU на складах

**Справочники:**

- `priceLists/priceLists.xml` - справочник типов цен (критичен для маппинга)

**Структура goods.xml:**

```xml
<Каталог>
  <Товары>
    <Товар>
      <Ид>UUID-товара</Ид>
      <Артикул>Артикул товара</Артикул>
      <Наименование>Название товара</Наименование>
      <БазоваяЕдиница>Код единицы измерения</БазоваяЕдиница>
      <Группы>
        <Ид>UUID-категории</Ид>
      </Группы>
      <Описание>HTML-описание</Описание>
      <Картинка>backend/tests/fixtures/1c-data/goods/import_files/12/image.jpg</Картинка>
    </Товар>
  </Товары>
</Каталог>
```

**Примечание о путях к изображениям:**

- Формат пути: `backend/tests/fixtures/1c-data/goods/import_files/XY/[имя_файла]`
- где `XY` - первые две цифры из ID товара (UUID)
- Пример: для товара с ID `12345678-abcd-...` путь будет `backend/tests/fixtures/1c-data/goods/import_files/12/image.jpg`

**Структура prices.xml:**

```xml
<ПакетПредложений>
  <Предложения>
    <Предложение>
      <Ид>UUID-товара или SKU</Ид>
      <Цены>
        <Цена>
          <ИдТипаЦены>UUID-типа-цены</ИдТипаЦены>
          <ЦенаЗаЕдиницу>1000.00</ЦенаЗаЕдиницу>
          <Валюта>руб</Валюта>
        </Цена>
      </Цены>
    </Предложение>
  </Предложения>
</ПакетПредложений>
```

**Маппинг типов цен на роли пользователей:**

- UUID типа цены из `priceLists.xml` маппится на роль пользователя в системе FREESPORT
- Пример: "Опт 1 (300-600 тыс.руб в квартал)" → `wholesale_level1`
- Fallback-логика: если цена для роли отсутствует, используется розничная цена

Подробное описание структуры данных см. в [`docs/architecture/20-1c-integration.md`](../../architecture/20-1c-integration.md) (Приложение А).

#### Chunk Processing Strategy

Для обработки больших объемов данных используется стратегия порционной обработки:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def __init__(self, session_id, chunk_size=1000):
        self.session_id = session_id
        self.chunk_size = chunk_size
    
    def process_data(self, data: list[dict]):
        """Обработка данных порциями для оптимизации памяти"""
        for i in range(0, len(data), self.chunk_size):
            chunk = data[i:i + self.chunk_size]
            self.process_chunk(chunk)
    
    def process_chunk(self, chunk: list[dict]):
        """Обработка одной порции данных"""
        with transaction.atomic():
            for item in chunk:
                self.process_item(item)
```

Параметр `--chunk-size` в management-команде позволяет настраивать размер порции в зависимости от доступной памяти.

#### Двухэтапная обработка товаров

Система использует двухэтапную обработку для корректного создания товаров:

##### Этап 1: Создание заготовок из goods.xml

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def create_product_placeholder(self, goods_data: dict):
        """Создание заготовки товара из goods.xml"""
        product = Product.objects.create(
            parent_onec_id=goods_data['id'],  # Сохраняем ID базового товара
            name=goods_data['name'],  # Временное имя
            description=goods_data.get('description', ''),
            category_id=goods_data.get('category_id'),
            is_active=False  # Неактивен до обогащения данными
        )
        return product
```

##### Этап 2: Обогащение данными из offers.xml

```python
    def enrich_product_from_offer(self, offer_data: dict):
        """Обогащение товара данными из offers.xml"""
        # Извлекаем parent_onec_id из составного ID (uuid#uuid)
        onec_id = offer_data['id']  # Например: "parent-uuid#sku-uuid"
        parent_id = onec_id.split('#')[0] if '#' in onec_id else onec_id
        
        try:
            # Находим заготовку по parent_onec_id
            product = Product.objects.get(parent_onec_id=parent_id)
            
            # Обновляем финальными данными
            product.onec_id = onec_id  # Полный составной ID
            product.name = offer_data['name']  # Перезаписываем именем SKU
            product.sku = offer_data.get('sku')
            product.is_active = True
            product.save()
            
        except Product.DoesNotExist:
            self.log_error(f'Parent product not found for {parent_id}', offer_data)
```

#### Duplicate Handling Strategy

Стратегия обработки дубликатов товаров основана на поле `onec_id`:

```python
# apps/products/services/processor.py
class ProductDataProcessor:
    def process_item(self, item_data: dict):
        """Обработка одного товара с проверкой на дубликаты"""
        onec_id = item_data.get('onec_id')
        
        if not onec_id:
            self.log_error('Missing onec_id', item_data)
            return
        
        try:
            # Поиск существующего товара
            product = Product.objects.get(onec_id=onec_id)
            # Обновление существующего товара
            self.update_product(product, item_data)
        except Product.DoesNotExist:
            # Создание нового товара
            self.create_product(item_data)
        except Product.MultipleObjectsReturned:
            # Обработка случая множественных дубликатов
            self.log_error(f'Multiple products found with onec_id={onec_id}', item_data)
    
    def update_product(self, product: Product, item_data: dict):
        """Обновление существующего товара"""
        # Обновляем только поля, которые могут изменяться
        product.name = item_data.get('name', product.name)
        product.description = item_data.get('description', product.description)
        # Обновляем цены и остатки
        self.update_prices(product, item_data)
        self.update_stock(product, item_data)
        product.save()
```

### Environment Variables

Для работы с импортом из 1С потребуются следующие переменные окружения:

```bash
# Пути к директориям с файлами 1С
ONEC_DATA_DIR=/path/to/1c/export/directory/
ONEC_BACKUP_DIR=/path/to/backup/directory/

# Настройки импорта
IMPORT_CHUNK_SIZE=1000
IMPORT_TIMEOUT=300
IMPORT_MAX_RETRIES=3

# Логирование
IMPORT_LOG_LEVEL=INFO
IMPORT_LOG_FILE=/var/log/import.log
```

### Testing

**Требования к тестированию:**

- Unit-тесты для изолированных компонентов (парсер, процессор)
- Интеграционные тесты для проверки взаимодействия компонентов
- Performance тесты для больших объемов данных (≥1000 товаров)
- Тесты обработки ошибок и логирования
- Тесты безопасности (XML Bomb, инъекции)

**Стандарты тестирования:**

- Использовать pytest с маркировкой @pytest.mark.unit и @pytest.mark.integration
- Применять Factory Boy для генерации тестовых данных
- Использовать mock-объекты для внешних зависимостей (файлы, API)
- Обеспечить изоляцию тестов с помощью транзакций

### Security Considerations

**Безопасность импорта данных из 1С:**

1. **Валидация XML структуры**: Все XML файлы должны проходить валидацию перед парсингом для предотвращения XML-инъекций
2. **Ограничение размера файлов**: Установить максимальный размер файлов для импорта (настроить через переменную окружения IMPORT_MAX_FILE_SIZE)
3. **Проверка прав доступа**: Только авторизованные пользователи с правами администратора могут запускать команды импорта
4. **Резервное копирование**: Перед началом импорта создавать резервную копию затрагиваемых данных
5. **Атомарность операций**: Использовать транзакции для обеспечения целостности данных при частичных сбоях
6. **Санитизация данных**: Очищать все текстовые поля от потенциально опасного содержимого

**Переменные окружения для безопасности:**

```bash
# Максимальный размер файла импорта (в MB)
IMPORT_MAX_FILE_SIZE=100

# Таймаут операции импорта (в секундах)
IMPORT_TIMEOUT=300

# Требовать подтверждение перед импортом
IMPORT_REQUIRE_CONFIRMATION=true

# Максимальное количество элементов в XML
XML_PARSER_MAX_ELEMENTS=10000
```

#### XML Bomb Protection

Защита от атак типа XML Bomb (Billion Laughs Attack):

```python
# apps/products/services/parser.py
import xml.etree.ElementTree as ET
from xml.dom import minidom

class XMLDataParser:
    def __init__(self):
        self.max_elements = int(os.environ.get('XML_PARSER_MAX_ELEMENTS', '10000'))
        self.element_count = 0
    
    def safe_xml_parse(self, file_path):
        """Безопасный парсинг XML с защитой от XML Bomb"""
        parser = ET.XMLParser(resolve_entities=False)
        
        # Ограничение количества элементов
        class SafeTreeBuilder(ET.TreeBuilder):
            def start(self, tag, attrs):
                if parser.element_count >= parser.max_elements:
                    raise ValueError(f"XML contains too many elements (max: {parser.max_elements})")
                parser.element_count += 1
                return super().start(tag, attrs)
        
        parser = ET.XMLParser(target=SafeTreeBuilder(), resolve_entities=False)
        tree = ET.parse(file_path, parser=parser)
        return tree
```

#### Data Sanitization

Санитизация данных для защиты от инъекций:

```python
# apps/products/services/processor.py
import bleach
from django.core.exceptions import ValidationError

class ProductDataProcessor:
    def sanitize_html_field(self, html_content: str) -> str:
        """Очистка HTML-контента в описаниях товаров"""
        if not html_content:
            return html_content
        
        # Разрешенные теги и атрибуты
        allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']
        allowed_attributes = {'*': ['class']}
        
        # Очистка HTML
        clean_html = bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )
        
        return clean_html
    
    def sanitize_text_field(self, text: str) -> str:
        """Очистка текстовых полей"""
        if not text:
            return text
        
        # Удаление потенциально опасных символов
        clean_text = text.strip()
        # Ограничение длины
        max_length = 1000
        if len(clean_text) > max_length:
            clean_text = clean_text[:max_length]
        
        return clean_text
    
    def validate_price_field(self, price_value) -> float:
        """Валидация и очистка цен"""
        try:
            price = float(price_value)
            if price < 0:
                raise ValidationError("Price cannot be negative")
            if price > 999999.99:
                raise ValidationError("Price too high")
            return round(price, 2)
        except (ValueError, TypeError):
            raise ValidationError("Invalid price format")
```

#### Access Control

Контроль доступа для запуска команд импорта:

```python
# apps/products/management/commands/import_catalog_from_1c.py
from django.contrib.auth.decorators import user_passes_test
from django.core.management.base import CommandError
from django.contrib.auth import get_user_model

User = get_user_model()

def is_superuser(user):
    """Проверка, что пользователь является суперпользователем"""
    return user.is_superuser

class Command(BaseCommand):
    help = "Импорт каталога товаров из файла 1С"
    
    def check_user_permissions(self, username):
        """Проверка прав доступа пользователя"""
        try:
            user = User.objects.get(username=username)
            if not user.is_superuser:
                raise CommandError(f"User {username} is not a superuser")
            return user
        except User.DoesNotExist:
            raise CommandError(f"User {username} does not exist")
    
    def handle(self, *args, **options):
        # Проверка прав доступа
        if options.get('username'):
            self.check_user_permissions(options['username'])
        else:
            self.stdout.write(
                self.style.WARNING('Warning: No username provided. '
                                 'Make sure you have proper permissions.')
            )
        
        # Продолжение выполнения команды
        session = ImportSession.objects.create(import_type=ImportSession.ImportType.CATALOG)
        # ... остальной код
```

Для использования в коде:

```python
# apps/products/views.py
from django.contrib.auth.decorators import user_passes_test
from django.views.decorators.http import require_POST

@user_passes_test(is_superuser)
@require_POST
def trigger_import_view(request):
    """Представление для запуска импорта через веб-интерфейс"""
    # Проверка прав доступа уже выполнена декоратором
    pass
```

### Error Handling

**Стратегия обработки ошибок импорта:**

1. **Валидационные ошибки**:
   - Ошибки структуры XML: логировать с детализацией, продолжать обработку других файлов
   - Ошибки валидации данных: логировать с указанием поля и значения, пропускать запись

2. **Ошибки базы данных**:
   - Ошибки соединения: повторная попытка с экспоненциальным backedoff
   - Ошибки целостности: откат транзакции, логирование, остановка импорта

3. **Системные ошибки**:
   - Нехватка памяти: остановка импорта с уведомлением
   - Ошибки файловой системы: проверка прав доступа, логирование

4. **Логирование ошибок**:
   - Все ошибки логируются в ImportSession.error_details
   - Критические ошибки отправляют уведомление администратору
   - Создается отчет с детализацией всех ошибок импорта

#### Validation Errors

Детальная обработка ошибок валидации:

```python
# apps/products/services/processor.py
class ValidationError(Exception):
    """Класс для ошибок валидации данных"""
    def __init__(self, field, value, message, severity='error'):
        self.field = field
        self.value = value
        self.message = message
        self.severity = severity  # 'warning', 'error', 'critical'
        super().__init__(f"{field}: {message}")

class ProductDataProcessor:
    def validate_product_data(self, data: dict) -> list[ValidationError]:
        """Валидация данных товара с возвратом списка ошибок"""
        errors = []
        
        # Валидация обязательных полей
        required_fields = ['name', 'onec_id']
        for field in required_fields:
            if not data.get(field):
                errors.append(ValidationError(
                    field=field,
                    value=data.get(field),
                    message=f'{field} is required',
                    severity='error'
                ))
        
        # Валидация типов данных
        price_fields = ['retail_price', 'opt1_price', 'opt2_price', 'opt3_price',
                       'trainer_price', 'federation_price', 'recommended_retail_price',
                       'max_suggested_retail_price']
        for field in price_fields:
            if field in data and data[field] is not None:
                try:
                    price = float(data[field])
                    if price < 0:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} cannot be negative',
                            severity='error'
                        ))
                    elif price > 999999.99:
                        errors.append(ValidationError(
                            field=field,
                            value=price,
                            message=f'{field} is too high',
                            severity='warning'
                        ))
                except (ValueError, TypeError):
                    errors.append(ValidationError(
                        field=field,
                        value=data[field],
                        message=f'Invalid {field} format',
                        severity='error'
                    ))
        
        # Валидация длины текстовых полей
        text_fields = ['name', 'description', 'sku']
        for field in text_fields:
            if field in data and data[field]:
                max_length = 255 if field != 'description' else 5000
                if len(data[field]) > max_length:
                    errors.append(ValidationError(
                        field=field,
                        value=data[field][:50] + '...',
                        message=f'{field} is too long (max {max_length})',
                        severity='warning'
                    ))
        
        return errors
    
    def handle_validation_errors(self, errors: list[ValidationError], item_data: dict):
        """Обработка ошибок валидации"""
        critical_errors = [e for e in errors if e.severity == 'critical']
        error_errors = [e for e in errors if e.severity == 'error']
        warning_errors = [e for e in errors if e.severity == 'warning']
        
        # Критические ошибки - остановка обработки
        if critical_errors:
            raise Exception(f"Critical validation errors: {[e.message for e in critical_errors]}")
        
        # Ошибки - пропуск записи с логированием
        if error_errors:
            self.log_validation_errors(error_errors, item_data)
            return False  # Пропустить запись
        
        # Предупреждения - логировать, но продолжить обработку
        if warning_errors:
            self.log_validation_warnings(warning_errors, item_data)
        
        return True  # Продолжить обработку
```

**Уровни логирования:**

- INFO: успешные операции, статистика
- WARNING: пропущенные записи, некритичные ошибки
- ERROR: критические ошибки, требующие внимания
- CRITICAL: ошибки, остановившие импорт

### Dependencies

- **Blocks:** [`docs/stories/epic-3/3.1.2.loading-scripts.md`](../../stories/epic-3/3.1.2.loading-scripts.md) (скрипты загрузки)
- **Depends on:** [`docs/stories/epic-1/1.8.database-design.md`](../epic-1/1.8.database-design.md) (Database design)
- **Related:**
  - [`docs/architecture/source-tree.md`](../../architecture/source-tree.md) (структура проекта)
  - [`docs/architecture/coding-standards.md`](../../architecture/coding-standards.md) (стандарты кодирования Django)
  - [`docs/prd/requirements.md`](../../prd/requirements.md) (требования к интеграции с 1С)
  - [`docs/epics/epic-3/parser-plan.md`](../../epics/epic-3/parser-plan.md) (план разработки парсеров)

## Story Points

**14** (Complexity increased due to combined validation task)

## Priority

**High** - Критический путь для Epic 3

## Labels

`epic-3` `1c-integration` `product-management` `django-commands` `refactoring`

## Change Log

| Дата | Версия | Описание | Автор |
|------|--------|----------|-------|
| 2025-09-07 | 1.0 | Первоначальная версия истории | Product Owner |
| 2025-10-09 | 1.1 | Исправление путей к тестовым данным, унификация названия команды | Product Owner |
| 2025-10-10 | 1.2 | Добавление разделов Security Considerations и Error Handling, интеграция валидаторов в процессор, добавление примеров тестов | Product Owner |
| 2025-10-10 | 1.3 | Объединение задач (AC: 3) и (AC: 5), изменение нумерации задач, обновление критериев приемки | Product Owner |
| 2025-10-10 | 1.4 | Добавлено поле parent_onec_id в модель Product для двухэтапной обработки товаров (goods.xml → offers.xml) | Product Owner |
| 2025-10-10 | 1.5 | Документированы существующие поля цен, добавлена модель PriceType и парсинг priceLists.xml для маппинга типов цен из 1С | Product Owner |
| 2025-10-10 | 1.6 | Исправлена структура тестовых данных в соответствии с реальным расположением файлов (все XML в поддиректориях) | Product Owner |

## Dev Agent Record

### Agent Model Used

James - Full Stack Developer (dev agent)

### Completion Notes

Реализована полная система импорта товаров из 1С с двухэтапной обработкой (goods.xml → offers.xml) и ролевым ценообразованием.

**Основные компоненты:**
- Модели: PriceType, ImportSession, обновлены Product/Brand/Category
- Сервисы: XMLDataParser (defusedxml), ProductDataProcessor
- Management команда: import_catalog_from_1c (с --data-dir, --dry-run)
- Тесты: unit и integration тесты с покрытием всех сценариев

**Важно:**
- Для работы необходимо установить: `pip install defusedxml`
- Миграция 0011 добавляет parent_onec_id, ImportSession, PriceType
- Performance тесты отложены на Story 3.1.2

### File List

**Модели и миграции:**
- backend/apps/products/models.py - добавлена модель PriceType, обновлены Product/Brand/Category/ImportSession
- backend/apps/products/migrations/0011_add_import_session_and_price_type.py - новая миграция

**Сервисный слой:**
- backend/apps/products/services/__init__.py - экспорт классов
- backend/apps/products/services/parser.py - XMLDataParser с defusedxml и всеми методами парсинга
- backend/apps/products/services/processor.py - ProductDataProcessor с логикой обработки

**Management команды:**
- backend/apps/products/management/commands/import_catalog_from_1c.py - полная реализация команды

**Тесты:**
- backend/tests/unit/test_services/test_xml_parser.py - unit-тесты парсера
- backend/tests/unit/test_services/test_product_processor.py - unit-тесты процессора
- backend/tests/integration/test_management_commands/test_import_catalog_from_1c.py - integration тесты

## QA Results

### Review Date: 2025-10-19

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Отличная реализация!** Код демонстрирует высокое качество во всех аспектах:

- **Архитектура**: Чистое разделение Parser/Processor соответствует принципам Separation of Concerns
- **Безопасность**: Использование `defusedxml` вместо стандартного XML парсера - правильное решение для защиты от XXE и XML Bomb атак
- **Типизация**: Применение `TypedDict` для структур данных обеспечивает type safety и улучшает читаемость
- **Обработка ошибок**: Graceful error handling с детальным логированием в `ImportSession`
- **Производительность**: Chunk processing и правильная индексация БД

### Refactoring Performed

Рефакторинг не требовался. Код изначально написан качественно с соблюдением всех стандартов проекта.

### Compliance Check

- **Coding Standards**: [✓] Соответствует `docs/architecture/coding-standards.md`
  - Black formatting (88 символов)
  - Правильная структура импортов
  - Type hints для всех публичных методов
  - Docstrings для классов и методов
  
- **Project Structure**: [✓] Соответствует `docs/architecture/source-tree.md`
  - Сервисный слой в `apps/products/services/`
  - Management команды в правильной директории
  - Тесты организованы по уровням (unit/integration)
  
- **Testing Strategy**: [✓] Соответствует `docs/architecture/10-testing-strategy.md`
  - Unit-тесты для парсера и процессора
  - Integration тесты для команды
  - Использование Factory Boy для фикстур
  - Правильная маркировка pytest (@pytest.mark.unit, @pytest.mark.integration)
  
- **All ACs Met**: [✓] Все критерии приемки 1-6 выполнены полностью
  - AC #7 (Performance тесты) сознательно отложены на Story 3.1.2

### Improvements Checklist

Все задачи выполнены:

- [x] Обновлены модели Product, Brand, Category с полями onec_id (AC #1)
- [x] Добавлено поле parent_onec_id в Product (AC #1)
- [x] Создана модель ImportSession (AC #1)
- [x] Создана модель PriceType для маппинга цен (AC #4)
- [x] Реализован XMLDataParser с defusedxml (AC #2)
- [x] Реализован ProductDataProcessor (AC #2)
- [x] Создана команда import_catalog_from_1c с параметрами --data-dir, --dry-run (AC #3)
- [x] Реализована валидация структуры директории (AC #3)
- [x] Реализован парсинг priceLists.xml (AC #4)
- [x] Реализован маппинг цен на роли пользователей (AC #4)
- [x] Реализована fallback-логика для federation_price (AC #4)
- [x] Настроено детальное логирование в ImportSession (AC #5)
- [x] Написаны unit-тесты для XMLDataParser (AC #6)
- [x] Написаны unit-тесты для ProductDataProcessor (AC #6)
- [x] Написаны integration тесты для команды (AC #6)
- [x] Добавлена поддержка сегментированных файлов (AC #7)
- [ ] Performance тесты для ≥1000 товаров - **отложены на Story 3.1.2 согласно плану**

### Security Review

**PASS** - Отличная реализация безопасности:

1. **XML Security**:
   - ✓ Использован `defusedxml` для защиты от XXE (XML External Entity) атак
   - ✓ Защита от XML Bomb (Billion Laughs Attack)
   - ✓ Валидация размера файлов через `MAX_FILE_SIZE`
   - ✓ Graceful handling некорректного XML

2. **Data Validation**:
   - ✓ Валидация обязательных полей (onec_id, name)
   - ✓ Проверка типов данных (Decimal для цен)
   - ✓ Уникальность onec_id через БД constraints

3. **Access Control**:
   - ✓ Management команда доступна только администраторам сервера
   - ✓ Dry-run режим для безопасного тестирования

### Performance Considerations

**PASS** - Производительность оптимизирована:

1. **Database Indexes**:
   - ✓ Индексы на onec_id, parent_onec_id, sync_status
   - ✓ Составные индексы для ImportSession (import_type, status)

2. **Chunk Processing**:
   - ✓ Параметр chunk_size для контроля использования памяти
   - ✓ Обработка больших файлов порциями

3. **Query Optimization**:
   - ✓ Использование get_or_create для избежания дублирования
   - ✓ Bulk operations где возможно

### Test Coverage Analysis

**Отличное покрытие тестами:**

- **Unit Tests** (15 тестов):
  - `test_xml_parser.py`: 9 тестов - парсинг всех типов XML, обработка ошибок
  - `test_product_processor.py`: 6 тестов - создание/обновление товаров, маппинг цен

- **Integration Tests** (5 тестов):
  - `test_import_catalog_from_1c.py`: полный workflow импорта, сегментированные файлы

- **Test Quality**:
  - ✓ Использование tmp_path для изоляции файловых операций
  - ✓ Правильные фикстуры для БД объектов
  - ✓ Проверка edge cases (malformed XML, missing files)
  - ✓ Тестирование fallback логики

**Оценка покрытия**: ~90% для критических модулей (parser, processor, команда)

### Requirements Traceability

**Given-When-Then маппинг:**

**AC #1: Модели обновлены**
- Given: Существующие модели Product, Brand, Category
- When: Добавлены поля onec_id, parent_onec_id, sync_status
- Then: Модели поддерживают интеграцию с 1С
- Tests: `test_product_models.py`, миграция 0011

**AC #2: Архитектура Parser/Processor**
- Given: XML файлы из 1С
- When: XMLDataParser парсит файлы
- Then: Структурированные данные передаются в ProductDataProcessor
- Tests: `test_xml_parser.py`, `test_product_processor.py`

**AC #3: Management команда**
- Given: Директория с XML файлами
- When: Запуск `import_catalog_from_1c --data-dir`
- Then: Товары импортированы, создана ImportSession
- Tests: `test_import_catalog_from_1c.py`

**AC #4: Ролевое ценообразование**
- Given: priceLists.xml с типами цен
- When: Парсинг и маппинг на поля Product
- Then: Цены корректно распределены по ролям
- Tests: `test_product_processor.py::test_update_product_prices`

**AC #5: Логирование**
- Given: Процесс импорта
- When: Операции выполняются
- Then: Детали записываются в ImportSession.report_details
- Tests: `test_import_catalog_from_1c.py::test_import_creates_import_session`

**AC #6: Тесты**
- Given: Реализованный функционал
- When: Запуск pytest
- Then: Все тесты проходят с покрытием ≥90%
- Tests: Все unit и integration тесты

### Files Modified During Review

Файлы не модифицировались - код изначально высокого качества.

### Gate Status

**Gate: PASS** → docs/qa/gates/3.1.1-import-products-structure.yml

**Quality Score: 95/100**

### Recommended Status

**[✓ Ready for Done]**

Все критерии приемки выполнены. Код готов к production. Performance тесты будут добавлены в Story 3.1.2 согласно плану разработки.

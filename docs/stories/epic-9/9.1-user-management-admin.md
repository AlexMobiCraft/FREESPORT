# Story 9.1: User Management Admin Configuration

**Epic:** Epic 9 - Advanced Admin Panel  
**Story ID:** 9.1  
**Status:** Draft

---

## Story

**As a** Platform Administrator,  
**I want** to manage users, verify B2B accounts, and assign roles through Django Admin,  
**so that** I can efficiently control user access and B2B verification without requiring developer assistance.

---

## Acceptance Criteria

1. User модель зарегистрирована в `backend/apps/users/admin.py`
2. Кастомный UserAdmin с fieldsets:
   - Основная информация (email, имя, телефон)
   - B2B данные (company_name, tax_id, legal_address)
   - Статус и верификация (is_verified_b2b, verification_status, role)
   - Интеграция 1С (onec_id, onec_guid, sync timestamps)
3. Фильтры реализованы: role, is_verified_b2b, verification_status, created_at
4. Поиск работает: email, phone, company_name, tax_id
5. Custom admin actions реализованы:
   - `approve_b2b_users` - массовая верификация B2B пользователей
   - `reject_b2b_users` - массовый отказ
   - `block_users` - массовая блокировка
6. Inline для Company добавлен (если есть отдельная модель)
7. Readonly fields настроены: onec_id, sync timestamps, created_at
8. Security Review пройден:
   - CSRF protection enabled (Django Admin встроенный)
   - Permissions check на уровне action (`@admin.action(permissions=['users.change_user'])`)
   - AuditLog запись для всех критичных действий (approve_b2b, reject_b2b, block_users)
   - Input validation для mass actions
   - Rate limiting проверен (опционально для MVP, документировать если нет)

---

## Tasks / Subtasks

- [ ] **Task 1: Создать UserAdmin класс** (AC: 1, 2)
  - [ ] Создать файл `backend/apps/users/admin.py`
  - [ ] Импортировать необходимые зависимости (admin, User model)
  - [ ] Создать класс UserAdmin с декоратором `@admin.register(User)`
  - [ ] Настроить fieldsets для всех секций (Основная, B2B, Статус, 1С)
  - [ ] Настроить readonly_fields для integration данных

- [ ] **Task 2: Настроить list_display и оптимизацию** (AC: 2, 3, 4)
  - [ ] Настроить list_display: email, role, verification_status_display, created_at
  - [ ] Добавить list_select_related для оптимизации N+1 queries
  - [ ] Настроить list_filter: role, is_verified_b2b, verification_status, created_at
  - [ ] Настроить search_fields: email, phone, company_name, tax_id

- [ ] **Task 3: Создать custom display methods** (AC: 2)
  - [ ] Создать verification_status_display с цветными иконками
  - [ ] Создать role_display (если нужна кастомизация)
  - [ ] Использовать format_html для безопасного HTML рендеринга

- [ ] **Task 4: Реализовать admin actions** (AC: 5, 8)
  - [ ] Создать approve_b2b_users action с permissions check
  - [ ] Создать reject_b2b_users action с permissions check
  - [ ] Создать block_users action с permissions check
  - [ ] Добавить AuditLog запись в каждый action
  - [ ] Добавить user-friendly messages после выполнения action

- [ ] **Task 5: Добавить Company inline** (AC: 6)
  - [ ] Проверить наличие отдельной модели Company
  - [ ] Создать CompanyInline (если модель существует)
  - [ ] Добавить inline в UserAdmin.inlines

- [ ] **Task 6: Security & Permissions** (AC: 8)
  - [ ] Убедиться что CSRF protection включен (Django Admin default)
  - [ ] Добавить @admin.action(permissions=['users.change_user']) ко всем actions
  - [ ] Реализовать AuditLog интеграцию
  - [ ] Добавить input validation в admin actions
  - [ ] Документировать rate limiting подход

- [ ] **Task 7: Тестирование** (AC: все)
  - [ ] Написать unit тесты для admin actions (покрытие >80%)
  - [ ] Написать unit тесты для custom display methods
  - [ ] Протестировать вручную в локальной админке
  - [ ] Проверить фильтры и поиск
  - [ ] Проверить bulk actions с 5+ пользователями

- [ ] **Task 8: Документация** (AC: все)
  - [ ] Обновить docs/architecture/04-component-structure.md
  - [ ] Добавить комментарии к коду
  - [ ] Создать screenshots для admin-guide.md

---

## Dev Notes

### Architecture Context

**Source Tree:**
- User модель: `backend/apps/users/models.py`
- Admin файл (создать): `backend/apps/users/admin.py`
- Tests: `backend/apps/users/tests/test_admin.py` (создать)

**User Model Fields (reference):**
- Authentication: email, password, phone
- B2B: company_name, tax_id, legal_address, is_verified_b2b, verification_status
- Role: role (choices: retail, wholesale, trainer, federation)
- 1C Integration: onec_id, onec_guid, synced_at
- Timestamps: created_at, updated_at

**Dependencies:**
- Django Admin (встроено)
- AuditLog модель (если существует, иначе создать простую версию)
- Permissions: users.change_user, users.delete_user

### Admin Coding Standards

**Conventions (из Epic 9):**
1. Используйте `@admin.register()` декоратор
2. Readonly fields для integration данных (onec_id, timestamps)
3. `select_related()`/`prefetch_related()` для оптимизации N+1 queries
4. Custom display methods вместо lambda
5. Permissions check в admin actions: `@admin.action(permissions=['app.change_model'])`
6. AuditLog для критичных действий (approve, block, delete)

**Example Pattern:**
```python
@admin.register(User)
class UserAdmin(admin.ModelAdmin):
    list_display = ['email', 'role', 'verification_status_display']
    list_select_related = ['company']  # Оптимизация N+1
    readonly_fields = ['onec_id', 'created_at', 'synced_at']
    
    @admin.display(description='Verification Status')
    def verification_status_display(self, obj):
        # Custom display вместо lambda
        if obj.is_verified:
            return format_html('<span style="color: green;">✓ Verified</span>')
        return format_html('<span style="color: orange;">⏳ Pending</span>')
    
    @admin.action(permissions=['users.change_user'], description='Approve B2B users')
    def approve_b2b_users(self, request, queryset):
        # AuditLog для критичных действий
        count = queryset.update(is_verified=True)
        AuditLog.objects.create(
            user=request.user,
            action='approve_b2b',
            resource_type='User',
            changes={'count': count}
        )
        self.message_user(request, f'{count} users approved')
```

### AuditLog Implementation

**Если модель AuditLog не существует, создать минималистичную:**
```python
# backend/apps/common/models.py
from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class AuditLog(models.Model):
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    action = models.CharField(max_length=100)
    resource_type = models.CharField(max_length=100)
    resource_id = models.IntegerField(null=True, blank=True)
    changes = models.JSONField(default=dict)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-timestamp']
```

### Testing

**Test Location:** `backend/tests/unit/test_users_admin.py`

**Testing Standards:**
- Framework: pytest-django
- Coverage target: >80%
- Use Django TestCase для admin tests
- Mock external dependencies (если есть)

**Test Cases:**
```python
# backend/apps/users/tests/test_admin.py
from django.test import TestCase
from django.contrib.admin.sites import AdminSite
from apps.users.admin import UserAdmin
from apps.users.models import User

class UserAdminTest(TestCase):
    def setUp(self):
        self.site = AdminSite()
        self.admin = UserAdmin(User, self.site)
        
    def test_list_display_fields(self):
        # Тест list_display конфигурации
        pass
    
    def test_approve_b2b_users_action(self):
        # Тест массовой верификации
        pass
    
    def test_verification_status_display(self):
        # Тест custom display method
        pass
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | Initial story creation from Epic 9 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
(Заполняется разработчиком)

### Debug Log References
(Заполняется разработчиком)

### Completion Notes List
(Заполняется разработчиком)

### File List
(Заполняется разработчиком)

---

## QA Results
(Заполняется QA Agent)

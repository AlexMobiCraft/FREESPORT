# Story 14.3: Дедупликация атрибутов при импорте из 1С

## Status

Ready

## Story

**As a** Content Manager,
**I want** атрибуты автоматически дедуплицироваться при импорте из 1С по нормализованному имени,
**so that** я вижу один атрибут "Размер" в админке вместо множества дубликатов с разными UUID из 1С.

## Goal

Устранить дублирование атрибутов при импорте из 1С, объединяя атрибуты с одинаковыми названиями (из propertiesGoods и propertiesOffers) в единую сущность на сайте, добавить флаг активности для ручной модерации атрибутов администратором.

## Description

### Контекст проблемы

В системе 1С существуют атрибуты с **одинаковыми названиями**, но **разными UUID** — это происходит из-за того, что атрибуты определены отдельно в `propertiesGoods/*.xml` и `propertiesOffers/*.xml`, а также могут дублироваться внутри каждого типа файлов.

**Пример реальных дубликатов:**

- Атрибут "Размер" с ID `ea034d96-b7aa-11ed-9805-fa163edba792` (propertiesGoods)
- Атрибут "Размер" с ID `511f0999-7fbe-11ea-81c1-00155d3cae02` (propertiesOffers)
- Атрибут "Цвет" с ID `8d71abe5-8f3b-11ea-81c1-00155d3cae02` (propertiesGoods)
- Атрибут "Цвет" с ID `fb3f263e-dfd0-11ef-8361-fa163ea88911` (propertiesOffers)

При текущей логике импорта (`onec_id` как unique) создаются множественные дубликаты атрибутов на сайте, что:

- Создаёт путаницу для контент-менеджеров в админке
- Усложняет привязку атрибутов к товарам
- Ухудшает качество фильтрации в каталоге
- Создаёт проблемы с консистентностью данных

### Дополнительное требование: Флаг активности

**Проблема:** После импорта из 1С создаются сотни атрибутов (458 по данным Story 14.2), но не все из них должны быть видимы в каталоге сразу.

**Решение:**

- Все атрибуты по умолчанию импортируются как `is_active=False`
- Администратор вручную активирует только нужные атрибуты через Django Admin
- В каталоге отображаются только активные атрибуты
- Неактивные атрибуты сохраняются для будущей активации

### Решение: Master Attribute + 1C Mapping + Active Flag

```
┌──────────────────────────────────────────────────────────────────┐
│                     Attribute (сайт)                             │
│  id=1, name="Размер", slug="razmer", normalized_name="размер"    │
│  is_active=True  ← Ручная активация администратором             │
│  ← Уникальный атрибут для каталога и фильтров                   │
└──────────────────────────────────────────────────────────────────┘
                              ▲
                              │ ForeignKey
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────┴──────────┐   ┌──────┴──────────┐   ┌─────┴──────────┐
│ Attribute1C      │   │ Attribute1C     │   │    Product     │
│ Mapping          │   │ Mapping         │   │ M2M relations  │
│ onec_id=ea03...  │   │ onec_id=511f... │   │ attributes     │
│ attribute_id=1   │   │ attribute_id=1  │   │ (через M2M)    │
│ onec_name=Размер │   │ onec_name=SIZE  │   └────────────────┘
│ source=goods     │   │ source=offers   │
└──────────────────┘   └─────────────────┘
```

**Ключевые принципы:**

1. **Один атрибут на сайте** = одно уникальное нормализованное название
2. **Множество маппингов 1С** = все ID атрибутов из 1С связаны с master-атрибутом
3. **Флаг активности** = `is_active=False` по умолчанию, ручная активация через админку
4. **Связь товаров** = через M2M таблицы (Product ↔ AttributeValue)
5. **Связь значений** = AttributeValue.attribute указывает на master-атрибут

### Нормализация названий

Для определения "одинаковости" атрибутов используется нормализация:

- Приведение к lowercase
- Удаление пробелов
- Удаление спецсимволов
- Учёт кириллицы и латиницы

**Примеры:**

- "Размер" → "размер"
- "РАЗМЕР" → "размер"
- " Размер " → "размер"
- "Цвет" → "цвет"
- "ЦВЕТ" → "цвет"

### Business Value

- **UX:** Контент-менеджер видит один атрибут "Размер" вместо нескольких дубликатов
- **Модерация:** Возможность контролировать какие атрибуты отображаются в каталоге
- **Качество данных:** Консистентные атрибуты для фильтрации
- **Операционная эффективность:** Упрощённое управление каталогом
- **Интеграция:** Сохранена полная связь с 1С для синхронизации

## Stories

### Story 14.3.1: Модели Attribute1CMapping и поле is_active

**Цель:** Создать архитектуру для хранения маппингов 1С ID на master-атрибуты и добавить флаг активности

**Acceptance Criteria:**

1. Создана модель `Attribute1CMapping` с полями:
   - `attribute` (ForeignKey to Attribute, CASCADE)
   - `onec_id` (CharField, unique, db_index)
   - `onec_name` (CharField) — оригинальное название из 1С
   - `source` (CharField, choices=['goods', 'offers']) — источник импорта
   - `created_at` (DateTimeField, auto_now_add)
2. В модель `Attribute` добавлено поле `normalized_name` (CharField, unique, db_index)
3. В модель `Attribute` добавлено поле `is_active` (BooleanField, default=False)
4. Удалено поле `Attribute.onec_id` (заменено на Attribute1CMapping)
5. Создана функция `normalize_attribute_name(name: str) -> str`
6. При сохранении Attribute автоматически вычисляется `normalized_name`
7. Создана миграция с корректной обработкой существующих данных

**Tasks (breakdown):**

1. [ ] **Schema foundation:** Добавить модель `Attribute1CMapping` в `apps/products/models.py` (поля, индексы, `source` choices, `created_at`) и зарегистрировать её в `apps/products/__init__.py` при необходимости.
2. [ ] **Normalized key:** Расширить `Attribute` полем `normalized_name` (CharField, unique, db_index) и обеспечить миграцию существующих значений.
3. [ ] **Activation flag:** Добавить `is_active` (BooleanField, default=False) в `Attribute`, покрыть админку/сериализаторы временными заглушками, чтобы флаг не ломал текущий UI.
4. [ ] **Normalization util:** Создать `normalize_attribute_name()` в `apps/products/utils.py`, добавить докстринги/типизацию и переиспользовать функцию в модели/сервисах.
5. [ ] **Model hook:** Переопределить `Attribute.save()` (и, при необходимости, `clean()`), чтобы автоматически писать `normalized_name` через новую утилиту + добавить валидацию уникальности.
6. [ ] **Legacy cleanup:** Удалить поле `Attribute.onec_id`, обновить связанные Serializer/Admin/Import места, где использовался `onec_id` напрямую.
7. [ ] **Data migration:** Создать миграции, создающие новую таблицу, новые поля и скрипт обратной совместимости (копия `onec_id` → `Attribute1CMapping`, вычисление `normalized_name`, установка `is_active=False`).
8. [ ] **Unit coverage:** Написать тесты для `normalize_attribute_name()` (pytest unit) и `Attribute1CMapping`/`Attribute` (уникальность, каскады, default `is_active`).

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_deduplication.py`
- **Standards:**
  - Use `pytest` with `pytest-django`
  - Use `@pytest.mark.unit` for unit tests of `normalize_attribute_name()`
  - Use `@pytest.mark.integration` with `@pytest.mark.django_db` for model tests
  - Use `get_unique_suffix()` from `backend/tests/utils.py` for test data isolation
  - Use Factory Boy for creating test data
- **Coverage Target:** >85% (per Definition of Done)
- **Test Cases:**
  1. **normalize_attribute_name() unit tests:**
     - "Размер" → "размер"
     - "РАЗМЕР" → "размер"
     - " Размер " → "размер"
     - "Тест 123" → "тест123"
     - "  Spacing  " → "spacing"
     - Edge case: empty string → ""
  2. **Attribute1CMapping model tests:**
     - Create mapping with unique onec_id
     - Attempt duplicate onec_id → IntegrityError
     - CASCADE deletion when Attribute is deleted
     - source field validation (goods/offers)
  3. **Attribute model tests:**
     - Auto-computation of normalized_name on save()
     - Uniqueness constraint on normalized_name
     - is_active defaults to False
     - onec_id field removed (check field list)

---

### Story 14.3.2: Обновление модели AttributeValue

**Цель:** Добавить маппинг 1С ID для значений атрибутов и логику дедупликации

**Acceptance Criteria:**

1. Создана модель `AttributeValue1CMapping` с полями:
   - `attribute_value` (ForeignKey to AttributeValue, CASCADE)
   - `onec_id` (CharField, unique, db_index)
   - `onec_value` (CharField) — оригинальное значение из 1С
   - `source` (CharField, choices=['goods', 'offers'])
   - `created_at` (DateTimeField, auto_now_add)
2. Добавлено поле `AttributeValue.normalized_value` (CharField, db_index) для дедупликации
3. Добавлен unique constraint на пару (attribute, normalized_value)
4. Удалено поле `AttributeValue.onec_id` (заменено на AttributeValue1CMapping)
5. Создана функция `normalize_attribute_value(value: str) -> str`
6. При сохранении AttributeValue автоматически вычисляется `normalized_value`
7. Создана миграция

**Tasks (breakdown):**

1. [ ] **New model:** Добавить `AttributeValue1CMapping` в `apps/products/models.py` с нужными полями (`onec_id`, `onec_value`, `source`, FK, индексы) и admin verbose names.
2. [ ] **Normalized field:** Добавить `AttributeValue.normalized_value` (CharField, db_index) и unique constraint на (attribute, normalized_value).
3. [ ] **Normalization util:** Создать `normalize_attribute_value()` в `apps/products/utils.py` (переиспользовать логику из `normalize_attribute_name()`).
4. [ ] **Model hook:** Переопределить `AttributeValue.save()` для автоматического вычисления `normalized_value`.
5. [ ] **Model wiring:** Обновить `AttributeValue` и связанные связи/serializers так, чтобы они ссылались на новую модель, а не на поле `onec_id`.
6. [ ] **Field removal:** Удалить `AttributeValue.onec_id`, почистить фабрики/фикстуры/админку/сериализаторы.
7. [ ] **Migration logic:** Написать миграцию, создающую таблицу и новые поля. **ВАЖНО:** Существующие атрибуты и значения будут удалены перед миграцией, поэтому миграция данных не требуется.
8. [ ] **Unit tests:** Добавить тесты для новой модели (уникальность, каскады, choices, normalized_value), дедупликации значений и smoke-тесты связей `Product ↔ AttributeValue`.

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_deduplication.py`
- **Standards:** Same as Story 14.3.1
- **Coverage Target:** >85%
- **Test Cases:**
  1. **AttributeValue1CMapping model tests:**
     - Create mapping with unique onec_id
     - Duplicate onec_id → IntegrityError
     - CASCADE deletion when AttributeValue is deleted
     - source field validation
  2. **AttributeValue model tests:**
     - Auto-computation of normalized_value on save()
     - Uniqueness constraint on (attribute, normalized_value)
     - onec_id field removed (check field list)
     - M2M relationships preserved with Product/ProductVariant
  3. **Value deduplication tests:**
     - Given: AttributeValue "Красный" and "красный" for same attribute
     - Then: Only one value created, second attempt raises IntegrityError
     - Verify normalized_value = "красный" for both

---

### Story 14.3.3: Обновление логики импорта атрибутов

**Цель:** Импорт атрибутов с автоматическим объединением дубликатов по нормализованному имени

**Acceptance Criteria:**

1. Метод `_save_properties()` в AttributeImportService ищет существующий атрибут по `normalized_name`
2. Если атрибут найден — создаётся только `Attribute1CMapping`
3. Если атрибут не найден — создаётся новый `Attribute` (is_active=False) + `Attribute1CMapping`
4. Для AttributeValue: поиск по `attribute` + `normalized_value`, создание `AttributeValue1CMapping`
5. При обнаружении дубля AttributeValue (по normalized_value) используется существующий, создаётся только маппинг
6. Статистика импорта включает `attributes_created`, `mappings_created`, `mappings_updated`, `values_created`, `value_mappings_created`, `values_deduplicated`
7. Логирование: какие атрибуты и значения были объединены
8. Параметр `--file-type` определяет значение поля `source` (goods/offers)
9. Параметр `--dry-run` выполняет импорт без сохранения в БД, только логирование статистики

**Tasks (breakdown):**

1. [ ] **Service refactor:** Переписать `AttributeImportService._save_properties()` так, чтобы поиск существующих записей шёл по `normalized_name` (и для значений по `attribute` + `normalized_value`).
2. [ ] **Value deduplication:** Реализовать логику объединения дублей AttributeValue: при совпадении normalized_value использовать существующий, создавать только маппинг.
3. [ ] **Creation rules:** Обеспечить, что новые `Attribute` создаются с `is_active=False`, а повторные импорты лишь докидывают `Attribute1CMapping`/`AttributeValue1CMapping` без изменения флагов.
4. [ ] **Mapping management:** Автоматически создавать/обновлять обе маппинг-модели, учитывать `source` (goods/offers) и избежать дублей по `onec_id`.
5. [ ] **Statistics/logging:** Расширить отчёт сервиса метриками `mappings_created`, `mappings_updated`, `value_mappings_created`, `values_deduplicated` и логировать случаи объединения.
6. [ ] **CLI plumbing:** Протянуть параметр `--file-type` до сервиса, чтобы корректно заполнять `source`, добавить валидацию аргумента и документацию CLI.
7. [ ] **Dry-run mode:** Добавить параметр `--dry-run` в management command, который выполняет всю логику импорта без `transaction.atomic`, только логирует статистику.
8. [ ] **Integration tests:** Добавить сценарии в `backend/apps/products/tests/test_attribute_import.py` (deduplication, value deduplication, idempotency, `is_active` default, dry-run, statistics, реальный импорт fixtures).

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_import.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, `@pytest.mark.django_db`, `get_unique_suffix()`
- **Coverage Target:** >85%
- **Test Cases:**
  1. **Deduplication integration tests:**
     - Given: Импорт атрибута "Размер" из propertiesGoods
     - When: Импорт атрибута "РАЗМЕР" из propertiesOffers
     - Then: Создаётся 1 Attribute, 2 Attribute1CMapping
  2. **Idempotency test:**
     - Given: Первый импорт атрибута "Цвет"
     - When: Повторный импорт того же атрибута
     - Then: Attribute count остаётся == 1, mappings count == 2
  3. **is_active flag test:**
     - Given: Импорт новых атрибутов
     - Then: Все атрибуты имеют is_active=False
  4. **Value deduplication test:**
     - Given: Импорт значений "Красный", "красный", "КРАСНЫЙ" для атрибута "Цвет"
     - Then: Создаётся 1 AttributeValue, 3 AttributeValue1CMapping
     - Verify normalized_value = "красный"
  5. **Statistics test:**
     - Verify statistics включает mappings_created, mappings_updated, values_deduplicated
  6. **Dry-run test:**
     - Given: --dry-run флаг
     - When: Импорт выполняется
     - Then: БД не изменяется (count Attribute/AttributeValue = 0), но статистика логируется
  7. **Real data test:**
     - Import from `data/import_1c/propertiesGoods/*.xml`
     - Verify deduplication работает корректно

---

### Story 14.3.4: Django Admin для управления атрибутами

**Цель:** Интерфейс администратора для активации атрибутов, просмотра маппингов и ручного объединения/разъединения

**Acceptance Criteria:**

1. В `AttributeAdmin` отображается inline `Attribute1CMappingInline` со всеми маппингами
2. В `list_display` добавлено поле `is_active` с иконками (✅/❌)
3. В `list_display` отображается количество маппингов (`mappings_count`)
4. В `list_filter` добавлен фильтр по `is_active`
5. Доступно массовое действие "Активировать выбранные атрибуты"
6. Доступно массовое действие "Деактивировать выбранные атрибуты"
7. Доступно массовое действие "Объединить выбранные атрибуты" (`merge_attributes`)
8. **merge_attributes action детали:**
   - **UI Flow:** После выбора атрибутов → intermediate page с выбором target атрибута из списка выбранных
   - **Validation:** Минимум 2 атрибута для объединения
   - **Confirmation:** Показать preview изменений перед выполнением (количество маппингов, значений)
   - **Audit:** Логировать операцию в Django admin log (`LogEntry`) с информацией о merged атрибутах
   - **Transaction Safety:** Использовать `@transaction.atomic` для атомарности операции
9. После объединения: все маппинги и значения переносятся на целевой атрибут, исходные атрибуты удаляются
10. Создан `Attribute1CMappingAdmin` для управления отдельными маппингами
11. Создан `AttributeValue1CMappingAdmin` для управления маппингами значений
12. В AttributeValueInline показаны маппинги 1С для каждого значения

**Tasks (breakdown):**

1. [ ] **Inline/display:** Добавить `Attribute1CMappingInline`, вывести `is_active` с иконками и `mappings_count` в `AttributeAdmin.list_display`, настроить `list_filter`/`search_fields`.
2. [ ] **Bulk toggles:** Реализовать действия `activate_attributes`/`deactivate_attributes` с сообщениями, проверкой прав и покрытием edge cases (уже активные записи).
3. [ ] **Merge workflow:** Реализовать action `merge_attributes` с intermediate page (выбор target), preview статистики и валидацией количества выбранных атрибутов.
4. [ ] **Safety/audit:** Обернуть merge в `transaction.atomic`, логировать операции через `LogEntry`, отразить изменения маппингов/значений.
5. [ ] **Mapping admin:** Добавить `Attribute1CMappingAdmin`, `AttributeValue1CMappingAdmin` и расширить `AttributeValueInline`, чтобы показывать связанные маппинги прямо в карточке.
6. [ ] **Admin tests:** Написать фронтальные тесты для UI/inline и действий (иконки, фильтры, bulk-акции, merge happy path + невалидные кейсы).

**Testing:**

- **Location:** `backend/apps/products/tests/test_admin.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, Django test client, admin permissions
- **Coverage Target:** >85%
- **Test Cases:**
  1. **Admin UI display tests:**
     - Verify Attribute1CMappingInline отображается
     - Verify is_active field с иконками
     - Verify mappings_count computed field
     - Verify list_filter работает
  2. **Admin actions tests:**
     - activate_attributes: массовая активация
     - deactivate_attributes: массовая деактивация
     - merge_attributes: объединение 3 атрибутов в 1
     - merge_attributes: validation (minimum 2 attributes)
  3. **Transaction safety test:**
     - merge_attributes с ошибкой → rollback, данные не повреждены
  4. **Audit logging test:**
     - Verify LogEntry создаётся после merge_attributes

---

### Story 14.3.5: Обновление интерфейса импорта в админке

**Цель:** Обновить UI запуска импорта с информацией о дедупликации и активации

**Acceptance Criteria:**

1. В описании импорта "Загрузить атрибуты (справочники)" добавлена информация:
   - "Дубликаты объединяются автоматически"
   - "Новые атрибуты импортируются как неактивные"
   - "Требуется ручная активация в разделе Атрибуты"
2. После импорта в статистике отображается:
   - Количество созданных атрибутов
   - Количество объединённых атрибутов
   - Количество созданных маппингов
   - Напоминание об активации атрибутов

**Tasks (breakdown):**

1. [ ] **Admin copy:** Дополнить описание импорта в `apps/integrations/views.py`, подсветив дедупликацию и флаг `is_active`.
2. [ ] **Report plumbing:** Расширить DTO/контекст отчёта из `AttributeImportService`, чтобы UI получил новые поля статистики.
3. [ ] **UI warning:** На странице админки отобразить подсказку о необходимости ручной активации и сводку созданных/объединённых атрибутов.
4. [ ] **View tests:** Добавить интеграционные тесты, проверяющие текст описания, наличие статистики и предупреждения.

**Testing:**

- **Location:** `backend/apps/integrations/tests/test_views.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, Django test client
- **Coverage Target:** >85%
- **Test Cases:**
  1. **UI description test:**
     - Verify новый текст отображается в интерфейсе
  2. **Statistics display test:**
     - После импорта → verify статистика содержит все поля
     - Verify reminder об активации присутствует

---

### Story 14.3.6: Фильтрация по активным атрибутам в API

**Цель:** В API каталога товаров возвращать только активные атрибуты

**Acceptance Criteria:**

1. В ProductSerializer и ProductVariantSerializer фильтруются только атрибуты с `is_active=True`
2. В API фильтров `/api/v1/catalog/filters/` возвращаются только активные атрибуты
3. Добавлен query parameter `?include_inactive=true` для администраторов (опционально)
4. Создана документация изменений API

**Tasks (breakdown):**

1. [ ] **Serializer filters:** Ограничить `ProductSerializer`/`ProductVariantSerializer` выдавать только активные атрибуты, добавить helper для переиспользования фильтра.
2. [ ] **Catalog filters:** Обновить `CatalogFilterViewSet` (или соответствующий класс) так, чтобы фильтры строились исключительно по активным атрибутам/значениям.
3. [ ] **Admin override:** Добавить параметр `include_inactive=true`, разрешённый только `staff` пользователям, и fallback на активные атрибуты для обычных пользователей.
4. [ ] **Schema/docs:** Обновить drf-spectacular/OpenAPI описание, задокументировать новый параметр и ответ.
5. [ ] **API tests:** Создать `backend/apps/products/tests/test_api_attributes.py` (или обновить) с кейсами фильтрации, параметра `include_inactive` и разрешений.

**Testing:**

- **Location:** `backend/apps/products/tests/test_api_attributes.py` (new file)
- **Standards:** `@pytest.mark.integration`, `@pytest.mark.django_db`, APIClient
- **Coverage Target:** >85%
- **Test Cases:**
  1. **ProductSerializer filtering test:**
     - Given: Product with 5 attributes (3 active, 2 inactive)
     - When: GET /api/v1/products/{id}/
     - Then: Response содержит только 3 активных атрибута
  2. **Catalog filters test:**
     - Given: 10 attributes (5 active, 5 inactive)
     - When: GET /api/v1/catalog/filters/
     - Then: Response содержит только 5 активных
  3. **include_inactive parameter test (staff user):**
     - Given: Staff user
     - When: GET /api/v1/products/{id}/?include_inactive=true
     - Then: Response содержит все атрибуты (active + inactive)
  4. **include_inactive permission test (regular user):**
     - Given: Non-staff user
     - When: GET /api/v1/products/{id}/?include_inactive=true
     - Then: Parameter игнорируется, возвращаются только активные

---

### Story 14.3.7: Документация и финальное тестирование

**Цель:** Документировать новую архитектуру и провести полное тестирование

**Acceptance Criteria:**

1. Обновлена документация в `docs/architecture/` — описание новой модели атрибутов
2. Создана инструкция для администраторов по активации атрибутов
3. Создан Migration Runbook с пошаговыми инструкциями
4. Обновлена документация API
5. Проведено полное тестирование с реальными данными из `data/import_1c/`
6. Все тесты проходят успешно
7. Обновлён CLAUDE.md с информацией о новой архитектуре атрибутов

**Tasks (breakdown):**

1. [ ] **Architecture docs:** Обновить шардированные файлы в `docs/architecture/` (data-models, backend-architecture, tech-stack) описанием master-атрибутов и маппингов.
2. [ ] **Admin guide:** Подготовить инструкцию (docs или wiki) по ручной активации атрибутов, merge-процессу и чтению статистики импорта.
3. [ ] **Migration Runbook:** Создать детальный runbook в `docs/guides/migration-14.3-attribute-deduplication.md` с:
   - Pre-migration checklist (backup, verification)
   - Step-by-step migration commands
   - Post-migration validation
   - Rollback plan
   - Troubleshooting guide
   - Estimated timeline (для 458 атрибутов)
4. [ ] **Real-data test:** Запустить импорт реальных XML из `data/import_1c/`, зафиксировать результаты дедупликации и приложить скриншоты/логи.
5. [ ] **Knowledge base:** Обновить `CLAUDE.md` и связанный internal knowledge base новыми процессами и чеклистами QA.
6. [ ] **Final QA:** Прогнать полный набор тестов (unit + integration), собрать отчёт о покрытии и подготовить материалы для code review.

**Testing:**

- **Full integration testing с реальными данными**
- **Location:** Все тестовые файлы из предыдущих stories
- **Real Data:** `data/import_1c/propertiesGoods/*.xml` и `propertiesOffers/*.xml`
- **Coverage Target:** >85% для всего Epic 14.3
- **Test Cases:**
  1. **End-to-end test:**
     - Import 458 real attributes from 1C
     - Verify deduplication → ~280-320 unique attributes
     - Verify all attributes is_active=False
     - Admin activates 50 attributes
     - API returns only 50 active attributes
  2. **Regression test:**
     - Existing import functionality не сломан
     - Story 14.2 тесты продолжают проходить

---

## Technical Notes

### Relevant Source Tree

```text
apps/products/
├── models.py                     # Attribute, AttributeValue, Attribute1CMapping, AttributeValue1CMapping
├── utils.py                      # normalize_attribute_name()
├── services/
│   └── attribute_import.py       # AttributeImportService._save_properties() - deduplication logic
├── serializers.py                # ProductSerializer, ProductVariantSerializer - is_active filtering
├── admin.py                      # AttributeAdmin, actions (activate, deactivate, merge)
├── tests/
│   ├── test_attribute_deduplication.py  # Story 14.3.1, 14.3.2 tests
│   ├── test_attribute_import.py         # Story 14.3.3 tests (extend existing)
│   ├── test_admin.py                    # Story 14.3.4 tests (extend existing)
│   └── test_api_attributes.py           # Story 14.3.6 tests (new file)
apps/integrations/
├── views.py                      # Import UI description update
└── tests/
    └── test_views.py             # Story 14.3.5 tests
apps/catalog/
└── views.py                      # CatalogFilterViewSet (or exact path for filters endpoint)
```

### Type Hints Requirements

**CRITICAL:** Все новые и модифицированные файлы ДОЛЖНЫ соответствовать проектным стандартам типизации:

```python
# ОБЯЗАТЕЛЬНО в начале каждого файла
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional
from decimal import Decimal

# Для моделей - использовать TYPE_CHECKING для circular imports
if TYPE_CHECKING:
    from apps.products.models import Attribute, AttributeValue

# Все методы моделей ДОЛЖНЫ иметь type hints
def save(self, *args: Any, **kwargs: Any) -> None:
    super().save(*args, **kwargs)

def __str__(self) -> str:
    return self.name

# Все функции утилит ДОЛЖНЫ иметь type hints
def normalize_attribute_name(name: str) -> str:
    """Нормализует название атрибута."""
    if not name:
        return ""
    # implementation
    return name

# Serializer методы ДОЛЖНЫ иметь type hints
def get_active_attributes(self, obj: Product) -> List[Dict[str, Any]]:
    return [...]
```

**Validation перед коммитом:**

```bash
# ОБЯЗАТЕЛЬНО запустить перед коммитом
docker-compose -f docker/docker-compose.test.yml run --rm backend mypy apps/products/
```

**Проверка в VS Code:**

- Убедиться что `python.analysis.typeCheckingMode: "strict"` в settings
- Исправить все Pylance warnings перед коммитом

### Функция нормализации

```python
# apps/products/utils.py
from __future__ import annotations

import re
import unicodedata


def normalize_attribute_name(name: str) -> str:
    """
    Нормализует название атрибута для сравнения.

    Examples:
        "Размер" → "размер"
        "РАЗМЕР" → "размер"
        " Размер " → "размер"
        "Цвет" → "цвет"
        "Тест 123" → "тест123"
        "  Spacing  " → "spacing"

    Args:
        name: Исходное название атрибута

    Returns:
        Нормализованное название (lowercase, без пробелов и спецсимволов)
    """
    if not name:
        return ""
    # Удаляем акценты и диакритики (é → e)
    name = unicodedata.normalize('NFKD', name)
    name = ''.join(c for c in name if not unicodedata.combining(c))
    # Lowercase
    name = name.lower()
    # Удаляем все пробелы
    name = re.sub(r'\s+', '', name)
    # Удаляем спецсимволы (оставляем только буквы и цифры)
    name = re.sub(r'[^\w]', '', name, flags=re.UNICODE)
    return name
```

### Миграция существующих данных

#### СТРАТЕГИЯ: Clean Slate Approach

Вместо сложной миграции существующих данных, используется подход "чистого листа":

**План миграции:**

1. **Pre-Migration (Manual):**

   ```bash
   # Создать backup существующих атрибутов (если требуется)
   python manage.py dumpdata products.Attribute products.AttributeValue > backup_attributes.json

   # Удалить все существующие атрибуты и значения
   python manage.py shell
   >>> from apps.products.models import Attribute, AttributeValue
   >>> AttributeValue.objects.all().delete()
   >>> Attribute.objects.all().delete()
   ```

2. **Run Migration:**

   ```bash
   # Создать новые таблицы и поля
   python manage.py makemigrations
   python manage.py migrate
   ```

3. **Post-Migration:**

   ```bash
   # Импортировать атрибуты заново с дедупликацией
   python manage.py import_attributes --file-type=goods --directory=data/import_1c/propertiesGoods/
   python manage.py import_attributes --file-type=offers --directory=data/import_1c/propertiesOffers/
   ```

**Преимущества этого подхода:**

- ✅ Нет проблемы определения `source` для существующих данных
- ✅ Нет риска некорректной миграции дубликатов
- ✅ Нет конфликтов slug при объединении
- ✅ Простая и понятная миграция
- ✅ Гарантированная корректность данных после импорта

**Недостатки:**

- ⚠️ Потеря существующих атрибутов (но они будут пересозданы из 1С)
- ⚠️ Все атрибуты будут `is_active=False` (требует ручной активации)

**Migration code:**

```python
# Migration file: apps/products/migrations/00XX_attribute_deduplication.py
from __future__ import annotations

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('products', '00XX_previous_migration'),
    ]

    operations = [
        # 1. Создать таблицу Attribute1CMapping
        migrations.CreateModel(
            name='Attribute1CMapping',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True)),
                ('onec_id', models.CharField(unique=True, db_index=True, max_length=255)),
                ('onec_name', models.CharField(max_length=255)),
                ('source', models.CharField(max_length=10, choices=[('goods', 'Goods'), ('offers', 'Offers')])),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('attribute', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,
                                               related_name='onec_mappings', to='products.attribute')),
            ],
            options={
                'verbose_name': 'Маппинг атрибута 1С',
                'verbose_name_plural': 'Маппинги атрибутов 1С',
                'db_table': 'product_attribute_1c_mappings',
            },
        ),

        # 2. Добавить поля в Attribute
        migrations.AddField(
            model_name='attribute',
            name='normalized_name',
            field=models.CharField(max_length=255, unique=True, db_index=True,
                                   help_text='Нормализованное название для дедупликации'),
        ),
        migrations.AddField(
            model_name='attribute',
            name='is_active',
            field=models.BooleanField(default=False,
                                     help_text='Атрибут активен и отображается в каталоге'),
        ),

        # 3. Создать таблицу AttributeValue1CMapping
        migrations.CreateModel(
            name='AttributeValue1CMapping',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True)),
                ('onec_id', models.CharField(unique=True, db_index=True, max_length=255)),
                ('onec_value', models.CharField(max_length=255)),
                ('source', models.CharField(max_length=10, choices=[('goods', 'Goods'), ('offers', 'Offers')])),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('attribute_value', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,
                                                     related_name='onec_mappings', to='products.attributevalue')),
            ],
        ),

        # 4. Добавить normalized_value в AttributeValue
        migrations.AddField(
            model_name='attributevalue',
            name='normalized_value',
            field=models.CharField(max_length=255, db_index=True,
                                   help_text='Нормализованное значение для дедупликации'),
        ),

        # 5. Добавить unique constraint на (attribute, normalized_value)
        migrations.AddConstraint(
            model_name='attributevalue',
            constraint=models.UniqueConstraint(
                fields=['attribute', 'normalized_value'],
                name='unique_attribute_normalized_value'
            ),
        ),

        # 6. Удалить старые поля onec_id
        migrations.RemoveField(
            model_name='attribute',
            name='onec_id',
        ),
        migrations.RemoveField(
            model_name='attributevalue',
            name='onec_id',
        ),
    ]
```

### Важные ограничения

- `Attribute.name` остаётся **не уникальным** (legacy, для безопасности)
- `Attribute.normalized_name` — **уникальный** (новый механизм дедупликации)
- `Attribute.is_active` — **default=False** (требует ручной активации)
- `Attribute1CMapping.onec_id` — **уникальный** (один 1С ID = один маппинг)
- `AttributeValue1CMapping.onec_id` — **уникальный** (один 1С ID = один маппинг)
- `Attribute1CMapping.attribute` — **CASCADE** (при удалении атрибута удаляются маппинги)
- `AttributeValue1CMapping.attribute_value` — **CASCADE**

### Защита от slug conflicts

Благодаря Clean Slate подходу проблема slug conflicts решается автоматически:

1. **При миграции:** Все атрибуты удаляются, slug conflicts невозможны
2. **При импорте:** Существующий `Attribute.save()` уже содержит защиту от дубликатов slug (lines 1074-1080 в models.py)
3. **При merge:** Admin action должен обновлять slug master-атрибута если возникает конфликт

**Пример защиты в Attribute.save():**

```python
# Existing code в models.py
def save(self, *args, **kwargs):
    if not self.slug:
        # ... генерация base_slug

        # Проверка уникальности и добавление суффикса при необходимости
        slug = base_slug
        counter = 1
        while Attribute.objects.filter(slug=slug).exclude(pk=self.pk).exists():
            slug = f"{base_slug}-{counter}"
            counter += 1

        self.slug = slug

    super().save(*args, **kwargs)
```

**Дополнительная защита в merge_attributes action:**

```python
@transaction.atomic
def merge_attributes(self, request, queryset):
    # ... логика merge

    # Если slug target совпадает с одним из merged атрибутов
    target = queryset.first()
    for attr in queryset[1:]:
        if attr.slug == target.slug and attr.pk != target.pk:
            # Атрибут будет удалён, конфликт разрешится автоматически
            pass

    # ... продолжить merge
```

### Работа с is_active флагом

**Сценарий 1: Первый импорт**

```python
# Импортируется атрибут "Размер"
attribute = Attribute.objects.create(
    name="Размер",
    normalized_name="размер",
    is_active=False  # По умолчанию неактивен
)
# Администратор вручную активирует через админку
attribute.is_active = True
attribute.save()
```

**Сценарий 2: Повторный импорт**

```python
# При повторном импорте атрибут "Размер" уже существует
existing = Attribute.objects.get(normalized_name="размер")
# is_active НЕ меняется! Остаётся в том состоянии, что установил администратор
# Создаётся только новый Attribute1CMapping
```

**Сценарий 3: API каталога**

```python
# В ProductSerializer
attributes = product.attributes.filter(is_active=True)
# Клиент видит только активные атрибуты
```

### Performance Considerations

- `Attribute.normalized_name` — unique index для быстрого поиска дубликатов
- `Attribute1CMapping.onec_id` — unique index для дедупликации маппингов
- `Attribute1CMapping.attribute` — foreign key index (создаётся автоматически Django)
- Batch операции в `_save_properties()` с `@transaction.atomic` для атомарности
- Избегать N+1 queries: использовать `select_related()` и `prefetch_related()` для маппингов

### Security Considerations

1. **Admin Actions Security:**
   - `merge_attributes` требует confirmation step с preview изменений
   - Все admin actions логируются через Django `LogEntry` для audit trail
   - Используется `@transaction.atomic` для предотвращения partial updates

2. **API Parameter Security:**
   - `?include_inactive=true` доступен только для `request.user.is_staff`
   - Явная проверка прав перед применением параметра

3. **Input Validation:**
   - `normalize_attribute_name()` безопасно обрабатывает входные данные (regex, unicodedata)
   - Защита от SQL injection через Django ORM

## Dependencies

- **Story 14.1:** Модели Attribute и AttributeValue (завершена)
- **Story 14.2:** Import Attributes from 1C (завершена)
- **Epic 13:** Brand Deduplication (референсная архитектура)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Некорректная нормализация (ложные совпадения) | Добавить логирование объединений, возможность ручного разъединения через admin actions |
| Потеря связи с 1С при объединении | Маппинги сохраняют все onec_id, связь не теряется |
| Массовая неактивность атрибутов после миграции | Создать management command для массовой активации + инструкция администратору |
| Сложность отладки | Подробное логирование, admin inline для просмотра маппингов, source field |

## Definition of Done

- [ ] Все AC выполнены для всех stories
- [ ] Тесты покрывают >85% нового кода
- [ ] Code review пройден
- [ ] Документация обновлена (архитектура, API, руководство администратора)
- [ ] Интеграционное тестирование с реальными данными (458 атрибутов, 12,260 значений)
- [ ] Нет регрессий в существующем функционале импорта
- [ ] Migration план протестирован на копии production данных
- [ ] Создана инструкция по активации атрибутов после миграции
- [ ] Все type hints добавлены, mypy validation прошла

## Related Epics

- **Epic 13:** Brand Deduplication — референсная реализация аналогичного паттерна
- **Epic 14:** Product Attributes System — родительский Epic

## Estimated Effort

- **Story 14.3.1:** 5 story points (модели и утилиты)
- **Story 14.3.2:** 3 story points (модель маппинга значений)
- **Story 14.3.3:** 8 story points (логика импорта с дедупликацией)
- **Story 14.3.4:** 8 story points (admin UI с actions)
- **Story 14.3.5:** 3 story points (обновление UI импорта)
- **Story 14.3.6:** 5 story points (фильтрация в API)
- **Story 14.3.7:** 3 story points (документация и тестирование)

**Итого:** 35 story points (~3-4 спринта)

## Success Metrics

**До реализации (текущее состояние):**

- 458 атрибутов после импорта
- ~30-40% дубликатов по названиям
- Все атрибуты активны сразу
- Путаница в админке

**После реализации (целевое состояние):**

- ~280-320 уникальных атрибутов (после дедупликации)
- 0 дубликатов в каталоге
- ~50-100 атрибутов активировано администратором
- Чистый каталог с модерированными атрибутами
- Сохранена полная связь с 1С (все 458 маппингов)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Initial draft | Sarah (PO) |
| 2025-12-04 | 1.1 | Added template compliance sections, Testing details, Source Tree, Type Hints requirements, merge_attributes details | Sarah (PO) |
| 2025-12-04 | 2.0 | Story review & updates: Status Ready, Added AttributeValue deduplication (normalized_value), Added --dry-run mode, Clean Slate migration strategy, Slug conflict protection, Migration runbook task | James (Dev) |
| 2025-12-05 | 2.1 | QA Fix: Implemented merge_attributes admin action (AC 14.3.4.7) with intermediate page, transaction safety, audit logging | James (Dev) |

## Dev Agent Record

### Agent Model Used

- Gemini 2.5 Pro

### Debug Log References

- N/A

### Completion Notes List

- Implemented `merge_attributes` admin action (ADMIN-001)
- Added `MergeAttributesActionForm` in `forms.py`
- Created intermediate page template `merge_action.html`
- Added 3 integration tests in `test_admin_actions.py`

### File List

- `backend/apps/products/admin.py` — added merge_attributes action
- `backend/apps/products/forms.py` — added MergeAttributesActionForm
- `backend/templates/admin/products/attribute/merge_action.html` — NEW
- `backend/apps/products/tests/test_admin_actions.py` — added tests

## QA Results

### Review Date: 2025-12-05

### Reviewed By: Quinn (Test Architect)

### Implementation Status

**Sub-stories 14.3.1-14.3.4: РЕАЛИЗОВАНЫ ✅**
**Sub-stories 14.3.5-14.3.7: ОЖИДАЮТ РЕАЛИЗАЦИИ** ⏳

### Code Quality Assessment

Реализованные компоненты демонстрируют высокое качество:

**Модели (14.3.1, 14.3.2):**

- ✅ `Attribute1CMapping` с полями: attribute, onec_id, onec_name, source, created_at
- ✅ `AttributeValue1CMapping` с полями: attribute_value, onec_id, onec_value, source, created_at
- ✅ `normalized_name` в Attribute (unique, indexed)
- ✅ `normalized_value` в AttributeValue с UniqueConstraint на (attribute, normalized_value)
- ✅ `is_active` в Attribute (default=False)

**Сервис импорта (14.3.3):**

- ✅ `AttributeImportService._save_properties()` с дедупликацией по normalized_name
- ✅ `_save_attribute_value()` с поиском по normalized_value
- ✅ Статистика: mappings_created, values_deduplicated

**Admin UI (14.3.4):**

- ✅ `Attribute1CMappingInline` в AttributeAdmin
- ✅ `mappings_count` computed field
- ✅ `is_active` в list_display и list_filter
- ✅ `activate_attributes` / `deactivate_attributes` bulk actions
- ⚠️ `merge_attributes` action НЕ реализован (AC 14.3.4.7)

**Тесты:**

- ✅ 58 test classes/methods в `test_attribute_deduplication.py` (1122 строки)
- ✅ Unit tests для normalize_attribute_name/value
- ✅ Integration tests для моделей и сервиса

### Requirements Traceability

| Sub-story | ACs | Status |
|-----------|-----|--------|
| 14.3.1 | 1-7 | ✅ COMPLETE |
| 14.3.2 | 1-7 | ✅ COMPLETE |
| 14.3.3 | 1-9 | ✅ COMPLETE |
| 14.3.4 | 1-6, 8-12 | ✅ COMPLETE |
| 14.3.4.7 | merge_attributes | ⚠️ NOT IMPLEMENTED |
| 14.3.5 | 1-2 | ❌ NOT STARTED |
| 14.3.6 | 1-4 | ❌ NOT STARTED |
| 14.3.7 | 1-7 | ❌ NOT STARTED |

### Compliance Check

- Coding Standards: [✓] Полная типизация, docstrings, PEP8
- Project Structure: [✓] Модели в models.py, сервисы в services/, тесты структурированы
- Testing Strategy: [✓] pytest markers, Factory Boy, изоляция
- All ACs Met: [✗] 14.3.5-14.3.7 не реализованы

### Improvements Checklist

**Реализовано:**

- [x] Модель Attribute1CMapping
- [x] Модель AttributeValue1CMapping
- [x] Поля normalized_name, is_active в Attribute
- [x] Поле normalized_value в AttributeValue
- [x] Дедупликация в AttributeImportService
- [x] Admin UI с inline, filters, bulk actions
- [x] 58 тестов (1122 строки)

**Требует реализации:**

- [ ] merge_attributes admin action (14.3.4.7)
- [ ] UI импорта с информацией о дедупликации (14.3.5)
- [ ] API фильтрация по is_active (14.3.6)
- [ ] include_inactive параметр для staff (14.3.6.3)
- [ ] Документация и Migration Runbook (14.3.7)

### Security Review

- ✅ defusedxml для защиты от XXE
- ✅ CASCADE удаление маппингов при удалении атрибута
- ✅ Валидация source choices
- ✅ Уникальность onec_id предотвращает дубликаты

### Performance Considerations

- ✅ `db_index=True` на onec_id, normalized_name, normalized_value
- ✅ Composite index на (attribute, source)
- ✅ @transaction.atomic для атомарности импорта

### Files Modified During Review

Нет файлов, модифицированных во время QA review.

### Gate Status

**Gate: CONCERNS** → [docs/qa/gates/14.3-attribute-deduplication.yml](../../qa/gates/14.3-attribute-deduplication.yml)

**Quality Score:** 70/100

**Rationale:** Sub-stories 14.3.1-14.3.4 реализованы с высоким качеством (модели, сервис, admin, тесты). Однако остаются нереализованными 14.3.5 (UI импорта), 14.3.6 (API фильтрация), 14.3.7 (документация) и merge_attributes action.

### Recommended Status

**[✗ Changes Required]**

Для перевода в Done необходимо:

1. Реализовать merge_attributes admin action с intermediate page
2. Реализовать Story 14.3.5 (UI импорта)
3. Реализовать Story 14.3.6 (API фильтрация по is_active)
4. Реализовать Story 14.3.7 (документация и Migration Runbook)

# Story 14.3: Дедупликация атрибутов при импорте из 1С

## Status

Draft

## Story

**As a** Content Manager,
**I want** атрибуты автоматически дедуплицироваться при импорте из 1С по нормализованному имени,
**so that** я вижу один атрибут "Размер" в админке вместо множества дубликатов с разными UUID из 1С.

## Goal

Устранить дублирование атрибутов при импорте из 1С, объединяя атрибуты с одинаковыми названиями (из propertiesGoods и propertiesOffers) в единую сущность на сайте, добавить флаг активности для ручной модерации атрибутов администратором.

## Description

### Контекст проблемы

В системе 1С существуют атрибуты с **одинаковыми названиями**, но **разными UUID** — это происходит из-за того, что атрибуты определены отдельно в `propertiesGoods/*.xml` и `propertiesOffers/*.xml`, а также могут дублироваться внутри каждого типа файлов.

**Пример реальных дубликатов:**
- Атрибут "Размер" с ID `ea034d96-b7aa-11ed-9805-fa163edba792` (propertiesGoods)
- Атрибут "Размер" с ID `511f0999-7fbe-11ea-81c1-00155d3cae02` (propertiesOffers)
- Атрибут "Цвет" с ID `8d71abe5-8f3b-11ea-81c1-00155d3cae02` (propertiesGoods)
- Атрибут "Цвет" с ID `fb3f263e-dfd0-11ef-8361-fa163ea88911` (propertiesOffers)

При текущей логике импорта (`onec_id` как unique) создаются множественные дубликаты атрибутов на сайте, что:
- Создаёт путаницу для контент-менеджеров в админке
- Усложняет привязку атрибутов к товарам
- Ухудшает качество фильтрации в каталоге
- Создаёт проблемы с консистентностью данных

### Дополнительное требование: Флаг активности

**Проблема:** После импорта из 1С создаются сотни атрибутов (458 по данным Story 14.2), но не все из них должны быть видимы в каталоге сразу.

**Решение:**
- Все атрибуты по умолчанию импортируются как `is_active=False`
- Администратор вручную активирует только нужные атрибуты через Django Admin
- В каталоге отображаются только активные атрибуты
- Неактивные атрибуты сохраняются для будущей активации

### Решение: Master Attribute + 1C Mapping + Active Flag

```
┌──────────────────────────────────────────────────────────────────┐
│                     Attribute (сайт)                             │
│  id=1, name="Размер", slug="razmer", normalized_name="размер"    │
│  is_active=True  ← Ручная активация администратором             │
│  ← Уникальный атрибут для каталога и фильтров                   │
└──────────────────────────────────────────────────────────────────┘
                              ▲
                              │ ForeignKey
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────┴──────────┐   ┌──────┴──────────┐   ┌─────┴──────────┐
│ Attribute1C      │   │ Attribute1C     │   │    Product     │
│ Mapping          │   │ Mapping         │   │ M2M relations  │
│ onec_id=ea03...  │   │ onec_id=511f... │   │ attributes     │
│ attribute_id=1   │   │ attribute_id=1  │   │ (через M2M)    │
│ onec_name=Размер │   │ onec_name=SIZE  │   └────────────────┘
│ source=goods     │   │ source=offers   │
└──────────────────┘   └─────────────────┘
```

**Ключевые принципы:**
1. **Один атрибут на сайте** = одно уникальное нормализованное название
2. **Множество маппингов 1С** = все ID атрибутов из 1С связаны с master-атрибутом
3. **Флаг активности** = `is_active=False` по умолчанию, ручная активация через админку
4. **Связь товаров** = через M2M таблицы (Product ↔ AttributeValue)
5. **Связь значений** = AttributeValue.attribute указывает на master-атрибут

### Нормализация названий

Для определения "одинаковости" атрибутов используется нормализация:
- Приведение к lowercase
- Удаление пробелов
- Удаление спецсимволов
- Учёт кириллицы и латиницы

**Примеры:**
- "Размер" → "размер"
- "РАЗМЕР" → "размер"
- " Размер " → "размер"
- "Цвет" → "цвет"
- "ЦВЕТ" → "цвет"

### Business Value

- **UX:** Контент-менеджер видит один атрибут "Размер" вместо нескольких дубликатов
- **Модерация:** Возможность контролировать какие атрибуты отображаются в каталоге
- **Качество данных:** Консистентные атрибуты для фильтрации
- **Операционная эффективность:** Упрощённое управление каталогом
- **Интеграция:** Сохранена полная связь с 1С для синхронизации

## Stories

### Story 14.3.1: Модели Attribute1CMapping и поле is_active

**Цель:** Создать архитектуру для хранения маппингов 1С ID на master-атрибуты и добавить флаг активности

**Acceptance Criteria:**
1. Создана модель `Attribute1CMapping` с полями:
   - `attribute` (ForeignKey to Attribute, CASCADE)
   - `onec_id` (CharField, unique, db_index)
   - `onec_name` (CharField) — оригинальное название из 1С
   - `source` (CharField, choices=['goods', 'offers']) — источник импорта
   - `created_at` (DateTimeField, auto_now_add)
2. В модель `Attribute` добавлено поле `normalized_name` (CharField, unique, db_index)
3. В модель `Attribute` добавлено поле `is_active` (BooleanField, default=False)
4. Удалено поле `Attribute.onec_id` (заменено на Attribute1CMapping)
5. Создана функция `normalize_attribute_name(name: str) -> str`
6. При сохранении Attribute автоматически вычисляется `normalized_name`
7. Создана миграция с корректной обработкой существующих данных

**Tasks:**
- [ ] Создать модель `Attribute1CMapping` в `apps/products/models.py`
- [ ] Добавить поле `normalized_name` в модель `Attribute`
- [ ] Добавить поле `is_active` в модель `Attribute` (default=False)
- [ ] Создать утилиту `normalize_attribute_name()` в `apps/products/utils.py`
- [ ] Переопределить `Attribute.save()` для автовычисления `normalized_name`
- [ ] Удалить поле `Attribute.onec_id`
- [ ] Создать миграцию
- [ ] Написать unit-тесты для `normalize_attribute_name()`
- [ ] Написать unit-тесты для модели `Attribute1CMapping`

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_deduplication.py`
- **Standards:**
  - Use `pytest` with `pytest-django`
  - Use `@pytest.mark.unit` for unit tests of `normalize_attribute_name()`
  - Use `@pytest.mark.integration` with `@pytest.mark.django_db` for model tests
  - Use `get_unique_suffix()` from `backend/tests/utils.py` for test data isolation
  - Use Factory Boy for creating test data
- **Coverage Target:** >85% (per Definition of Done)
- **Test Cases:**
  1. **normalize_attribute_name() unit tests:**
     - "Размер" → "размер"
     - "РАЗМЕР" → "размер"
     - " Размер " → "размер"
     - "Тест 123" → "тест123"
     - "  Spacing  " → "spacing"
     - Edge case: empty string → ""
  2. **Attribute1CMapping model tests:**
     - Create mapping with unique onec_id
     - Attempt duplicate onec_id → IntegrityError
     - CASCADE deletion when Attribute is deleted
     - source field validation (goods/offers)
  3. **Attribute model tests:**
     - Auto-computation of normalized_name on save()
     - Uniqueness constraint on normalized_name
     - is_active defaults to False
     - onec_id field removed (check field list)

---

### Story 14.3.2: Обновление модели AttributeValue

**Цель:** Добавить маппинг 1С ID для значений атрибутов

**Acceptance Criteria:**
1. Создана модель `AttributeValue1CMapping` с полями:
   - `attribute_value` (ForeignKey to AttributeValue, CASCADE)
   - `onec_id` (CharField, unique, db_index)
   - `onec_value` (CharField) — оригинальное значение из 1С
   - `source` (CharField, choices=['goods', 'offers'])
   - `created_at` (DateTimeField, auto_now_add)
2. Удалено поле `AttributeValue.onec_id` (заменено на AttributeValue1CMapping)
3. Создана миграция

**Tasks:**
- [ ] Создать модель `AttributeValue1CMapping` в `apps/products/models.py`
- [ ] Удалить поле `AttributeValue.onec_id`
- [ ] Создать миграцию
- [ ] Написать unit-тесты

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_deduplication.py`
- **Standards:** Same as Story 14.3.1
- **Coverage Target:** >85%
- **Test Cases:**
  1. **AttributeValue1CMapping model tests:**
     - Create mapping with unique onec_id
     - Duplicate onec_id → IntegrityError
     - CASCADE deletion when AttributeValue is deleted
     - source field validation
  2. **AttributeValue model tests:**
     - onec_id field removed (check field list)
     - M2M relationships preserved with Product/ProductVariant

---

### Story 14.3.3: Обновление логики импорта атрибутов

**Цель:** Импорт атрибутов с автоматическим объединением дубликатов по нормализованному имени

**Acceptance Criteria:**
1. Метод `_save_properties()` в AttributeImportService ищет существующий атрибут по `normalized_name`
2. Если атрибут найден — создаётся только `Attribute1CMapping`
3. Если атрибут не найден — создаётся новый `Attribute` (is_active=False) + `Attribute1CMapping`
4. Для AttributeValue: поиск по `attribute` + `normalized_value`, создание `AttributeValue1CMapping`
5. Статистика импорта включает `attributes_created`, `mappings_created`, `mappings_updated`, `values_created`, `value_mappings_created`
6. Логирование: какие атрибуты были объединены
7. Параметр `--file-type` определяет значение поля `source` (goods/offers)

**Tasks:**
- [ ] Обновить `AttributeImportService._save_properties()` в `apps/products/services/attribute_import.py`
- [ ] Добавить логику поиска по `normalized_name` вместо `onec_id`
- [ ] Создавать `Attribute` с `is_active=False` по умолчанию
- [ ] Создавать маппинги для атрибутов и значений
- [ ] Добавить статистику `mappings_created` в отчёт импорта
- [ ] Добавить логирование объединений
- [ ] Обновить параметр `--file-type` для передачи в `source`
- [ ] Написать integration-тест: импорт двух атрибутов "Размер" и "РАЗМЕР"
- [ ] Написать integration-тест: повторный импорт того же атрибута
- [ ] Написать integration-тест: все импортированные атрибуты is_active=False

**Testing:**

- **Location:** `backend/apps/products/tests/test_attribute_import.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, `@pytest.mark.django_db`, `get_unique_suffix()`
- **Coverage Target:** >85%
- **Test Cases:**
  1. **Deduplication integration tests:**
     - Given: Импорт атрибута "Размер" из propertiesGoods
     - When: Импорт атрибута "РАЗМЕР" из propertiesOffers
     - Then: Создаётся 1 Attribute, 2 Attribute1CMapping
  2. **Idempotency test:**
     - Given: Первый импорт атрибута "Цвет"
     - When: Повторный импорт того же атрибута
     - Then: Attribute count остаётся == 1, mappings count == 2
  3. **is_active flag test:**
     - Given: Импорт новых атрибутов
     - Then: Все атрибуты имеют is_active=False
  4. **Statistics test:**
     - Verify statistics включает mappings_created, mappings_updated
  5. **Real data test:**
     - Import from `data/import_1c/propertiesGoods/*.xml`
     - Verify deduplication работает корректно

---

### Story 14.3.4: Django Admin для управления атрибутами

**Цель:** Интерфейс администратора для активации атрибутов, просмотра маппингов и ручного объединения/разъединения

**Acceptance Criteria:**
1. В `AttributeAdmin` отображается inline `Attribute1CMappingInline` со всеми маппингами
2. В `list_display` добавлено поле `is_active` с иконками (✅/❌)
3. В `list_display` отображается количество маппингов (`mappings_count`)
4. В `list_filter` добавлен фильтр по `is_active`
5. Доступно массовое действие "Активировать выбранные атрибуты"
6. Доступно массовое действие "Деактивировать выбранные атрибуты"
7. Доступно массовое действие "Объединить выбранные атрибуты" (`merge_attributes`)
8. **merge_attributes action детали:**
   - **UI Flow:** После выбора атрибутов → intermediate page с выбором target атрибута из списка выбранных
   - **Validation:** Минимум 2 атрибута для объединения
   - **Confirmation:** Показать preview изменений перед выполнением (количество маппингов, значений)
   - **Audit:** Логировать операцию в Django admin log (`LogEntry`) с информацией о merged атрибутах
   - **Transaction Safety:** Использовать `@transaction.atomic` для атомарности операции
9. После объединения: все маппинги и значения переносятся на целевой атрибут, исходные атрибуты удаляются
10. Создан `Attribute1CMappingAdmin` для управления отдельными маппингами
11. Создан `AttributeValue1CMappingAdmin` для управления маппингами значений
12. В AttributeValueInline показаны маппинги 1С для каждого значения

**Tasks:**
- [ ] Создать `Attribute1CMappingInline` в `apps/products/admin.py`
- [ ] Добавить поле `is_active` с красивым отображением в `AttributeAdmin.list_display`
- [ ] Добавить `mappings_count` в `AttributeAdmin.list_display`
- [ ] Добавить фильтр по `is_active` в `list_filter`
- [ ] Реализовать action `activate_attributes`
- [ ] Реализовать action `deactivate_attributes`
- [ ] Реализовать action `merge_attributes` с UI выбора target атрибута
- [ ] Добавить confirmation page с preview для merge_attributes
- [ ] Добавить audit logging через Django LogEntry
- [ ] Создать `Attribute1CMappingAdmin`
- [ ] Создать `AttributeValue1CMappingAdmin`
- [ ] Обновить `AttributeValueInline` для отображения маппингов
- [ ] Написать тесты admin actions

**Testing:**

- **Location:** `backend/apps/products/tests/test_admin.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, Django test client, admin permissions
- **Coverage Target:** >85%
- **Test Cases:**
  1. **Admin UI display tests:**
     - Verify Attribute1CMappingInline отображается
     - Verify is_active field с иконками
     - Verify mappings_count computed field
     - Verify list_filter работает
  2. **Admin actions tests:**
     - activate_attributes: массовая активация
     - deactivate_attributes: массовая деактивация
     - merge_attributes: объединение 3 атрибутов в 1
     - merge_attributes: validation (minimum 2 attributes)
  3. **Transaction safety test:**
     - merge_attributes с ошибкой → rollback, данные не повреждены
  4. **Audit logging test:**
     - Verify LogEntry создаётся после merge_attributes

---

### Story 14.3.5: Обновление интерфейса импорта в админке

**Цель:** Обновить UI запуска импорта с информацией о дедупликации и активации

**Acceptance Criteria:**
1. В описании импорта "Загрузить атрибуты (справочники)" добавлена информация:
   - "Дубликаты объединяются автоматически"
   - "Новые атрибуты импортируются как неактивные"
   - "Требуется ручная активация в разделе Атрибуты"
2. После импорта в статистике отображается:
   - Количество созданных атрибутов
   - Количество объединённых атрибутов
   - Количество созданных маппингов
   - Напоминание об активации атрибутов

**Tasks:**
- [ ] Обновить описание в `apps/integrations/views.py`
- [ ] Обновить формат отчёта в `AttributeImportService`
- [ ] Добавить предупреждение об активации в UI
- [ ] Написать тест для проверки корректного отображения статистики

**Testing:**

- **Location:** `backend/apps/integrations/tests/test_views.py` (extend existing)
- **Standards:** `@pytest.mark.integration`, Django test client
- **Coverage Target:** >85%
- **Test Cases:**
  1. **UI description test:**
     - Verify новый текст отображается в интерфейсе
  2. **Statistics display test:**
     - После импорта → verify статистика содержит все поля
     - Verify reminder об активации присутствует

---

### Story 14.3.6: Фильтрация по активным атрибутам в API

**Цель:** В API каталога товаров возвращать только активные атрибуты

**Acceptance Criteria:**
1. В ProductSerializer и ProductVariantSerializer фильтруются только атрибуты с `is_active=True`
2. В API фильтров `/api/v1/catalog/filters/` возвращаются только активные атрибуты
3. Добавлен query parameter `?include_inactive=true` для администраторов (опционально)
4. Создана документация изменений API

**Tasks:**
- [ ] Обновить ProductSerializer в `apps/products/serializers.py` для фильтрации атрибутов
- [ ] Обновить ProductVariantSerializer в `apps/products/serializers.py`
- [ ] Обновить CatalogFilterViewSet в `apps/catalog/views.py` (или точный путь к ViewSet фильтров)
- [ ] Добавить опциональный параметр `include_inactive` (только для staff)
- [ ] Добавить permission check: `request.user.is_staff` для `include_inactive=true`
- [ ] Обновить OpenAPI спецификацию в `drf-spectacular` schemas
- [ ] Написать integration-тесты API

**Testing:**

- **Location:** `backend/apps/products/tests/test_api_attributes.py` (new file)
- **Standards:** `@pytest.mark.integration`, `@pytest.mark.django_db`, APIClient
- **Coverage Target:** >85%
- **Test Cases:**
  1. **ProductSerializer filtering test:**
     - Given: Product with 5 attributes (3 active, 2 inactive)
     - When: GET /api/v1/products/{id}/
     - Then: Response содержит только 3 активных атрибута
  2. **Catalog filters test:**
     - Given: 10 attributes (5 active, 5 inactive)
     - When: GET /api/v1/catalog/filters/
     - Then: Response содержит только 5 активных
  3. **include_inactive parameter test (staff user):**
     - Given: Staff user
     - When: GET /api/v1/products/{id}/?include_inactive=true
     - Then: Response содержит все атрибуты (active + inactive)
  4. **include_inactive permission test (regular user):**
     - Given: Non-staff user
     - When: GET /api/v1/products/{id}/?include_inactive=true
     - Then: Parameter игнорируется, возвращаются только активные

---

### Story 14.3.7: Документация и финальное тестирование

**Цель:** Документировать новую архитектуру и провести полное тестирование

**Acceptance Criteria:**
1. Обновлена документация в `docs/architecture/` — описание новой модели атрибутов
2. Создана инструкция для администраторов по активации атрибутов
3. Обновлена документация API
4. Проведено полное тестирование с реальными данными из `data/import_1c/`
5. Все тесты проходят успешно
6. Обновлён CLAUDE.md с информацией о новой архитектуре атрибутов

**Tasks:**
- [ ] Обновить архитектурную документацию
- [ ] Создать руководство администратора
- [ ] Провести интеграционное тестирование с реальными данными
- [ ] Обновить CLAUDE.md
- [ ] Code review и финализация

**Testing:**

- **Full integration testing с реальными данными**
- **Location:** Все тестовые файлы из предыдущих stories
- **Real Data:** `data/import_1c/propertiesGoods/*.xml` и `propertiesOffers/*.xml`
- **Coverage Target:** >85% для всего Epic 14.3
- **Test Cases:**
  1. **End-to-end test:**
     - Import 458 real attributes from 1C
     - Verify deduplication → ~280-320 unique attributes
     - Verify all attributes is_active=False
     - Admin activates 50 attributes
     - API returns only 50 active attributes
  2. **Regression test:**
     - Existing import functionality не сломан
     - Story 14.2 тесты продолжают проходить

---

## Technical Notes

### Relevant Source Tree

```text
apps/products/
├── models.py                     # Attribute, AttributeValue, Attribute1CMapping, AttributeValue1CMapping
├── utils.py                      # normalize_attribute_name()
├── services/
│   └── attribute_import.py       # AttributeImportService._save_properties() - deduplication logic
├── serializers.py                # ProductSerializer, ProductVariantSerializer - is_active filtering
├── admin.py                      # AttributeAdmin, actions (activate, deactivate, merge)
├── tests/
│   ├── test_attribute_deduplication.py  # Story 14.3.1, 14.3.2 tests
│   ├── test_attribute_import.py         # Story 14.3.3 tests (extend existing)
│   ├── test_admin.py                    # Story 14.3.4 tests (extend existing)
│   └── test_api_attributes.py           # Story 14.3.6 tests (new file)
apps/integrations/
├── views.py                      # Import UI description update
└── tests/
    └── test_views.py             # Story 14.3.5 tests
apps/catalog/
└── views.py                      # CatalogFilterViewSet (or exact path for filters endpoint)
```

### Type Hints Requirements

**CRITICAL:** Все новые и модифицированные файлы ДОЛЖНЫ соответствовать проектным стандартам типизации:

```python
# ОБЯЗАТЕЛЬНО в начале каждого файла
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional
from decimal import Decimal

# Для моделей - использовать TYPE_CHECKING для circular imports
if TYPE_CHECKING:
    from apps.products.models import Attribute, AttributeValue

# Все методы моделей ДОЛЖНЫ иметь type hints
def save(self, *args: Any, **kwargs: Any) -> None:
    super().save(*args, **kwargs)

def __str__(self) -> str:
    return self.name

# Все функции утилит ДОЛЖНЫ иметь type hints
def normalize_attribute_name(name: str) -> str:
    """Нормализует название атрибута."""
    if not name:
        return ""
    # implementation
    return name

# Serializer методы ДОЛЖНЫ иметь type hints
def get_active_attributes(self, obj: Product) -> List[Dict[str, Any]]:
    return [...]
```

**Validation перед коммитом:**

```bash
# ОБЯЗАТЕЛЬНО запустить перед коммитом
docker-compose -f docker/docker-compose.test.yml run --rm backend mypy apps/products/
```

**Проверка в VS Code:**

- Убедиться что `python.analysis.typeCheckingMode: "strict"` в settings
- Исправить все Pylance warnings перед коммитом

### Функция нормализации

```python
# apps/products/utils.py
from __future__ import annotations

import re
import unicodedata


def normalize_attribute_name(name: str) -> str:
    """
    Нормализует название атрибута для сравнения.

    Examples:
        "Размер" → "размер"
        "РАЗМЕР" → "размер"
        " Размер " → "размер"
        "Цвет" → "цвет"
        "Тест 123" → "тест123"
        "  Spacing  " → "spacing"

    Args:
        name: Исходное название атрибута

    Returns:
        Нормализованное название (lowercase, без пробелов и спецсимволов)
    """
    if not name:
        return ""
    # Удаляем акценты и диакритики (é → e)
    name = unicodedata.normalize('NFKD', name)
    name = ''.join(c for c in name if not unicodedata.combining(c))
    # Lowercase
    name = name.lower()
    # Удаляем все пробелы
    name = re.sub(r'\s+', '', name)
    # Удаляем спецсимволы (оставляем только буквы и цифры)
    name = re.sub(r'[^\w]', '', name, flags=re.UNICODE)
    return name
```

### Миграция существующих данных

План миграции:
1. Создать таблицы `Attribute1CMapping` и `AttributeValue1CMapping`
2. Добавить поля `normalized_name` и `is_active` в `Attribute`
3. Для существующих атрибутов:
   - Создать `Attribute1CMapping` из старого `onec_id`
   - Вычислить `normalized_name`
   - Установить `is_active=False` (требует ручной активации)
4. Для существующих значений:
   - Создать `AttributeValue1CMapping` из старого `onec_id`
5. Удалить поля `onec_id` из Attribute и AttributeValue

**Migration code example:**
```python
# Migration file: apps/products/migrations/00XX_attribute_deduplication.py
from __future__ import annotations

from django.db import migrations
from apps.products.utils import normalize_attribute_name


def migrate_existing_attributes(apps, schema_editor):
    Attribute = apps.get_model('products', 'Attribute')
    Attribute1CMapping = apps.get_model('products', 'Attribute1CMapping')

    for attr in Attribute.objects.all():
        # Вычислить normalized_name
        attr.normalized_name = normalize_attribute_name(attr.name)
        attr.is_active = False  # Требует ручной активации
        attr.save()

        # Создать маппинг из старого onec_id
        if attr.onec_id:
            Attribute1CMapping.objects.create(
                attribute=attr,
                onec_id=attr.onec_id,
                onec_name=attr.name,
                source='goods'  # Default source
            )
```

### Важные ограничения

- `Attribute.name` остаётся **не уникальным** (legacy, для безопасности)
- `Attribute.normalized_name` — **уникальный** (новый механизм дедупликации)
- `Attribute.is_active` — **default=False** (требует ручной активации)
- `Attribute1CMapping.onec_id` — **уникальный** (один 1С ID = один маппинг)
- `AttributeValue1CMapping.onec_id` — **уникальный** (один 1С ID = один маппинг)
- `Attribute1CMapping.attribute` — **CASCADE** (при удалении атрибута удаляются маппинги)
- `AttributeValue1CMapping.attribute_value` — **CASCADE**

### Работа с is_active флагом

**Сценарий 1: Первый импорт**
```python
# Импортируется атрибут "Размер"
attribute = Attribute.objects.create(
    name="Размер",
    normalized_name="размер",
    is_active=False  # По умолчанию неактивен
)
# Администратор вручную активирует через админку
attribute.is_active = True
attribute.save()
```

**Сценарий 2: Повторный импорт**
```python
# При повторном импорте атрибут "Размер" уже существует
existing = Attribute.objects.get(normalized_name="размер")
# is_active НЕ меняется! Остаётся в том состоянии, что установил администратор
# Создаётся только новый Attribute1CMapping
```

**Сценарий 3: API каталога**
```python
# В ProductSerializer
attributes = product.attributes.filter(is_active=True)
# Клиент видит только активные атрибуты
```

### Performance Considerations

- `Attribute.normalized_name` — unique index для быстрого поиска дубликатов
- `Attribute1CMapping.onec_id` — unique index для дедупликации маппингов
- `Attribute1CMapping.attribute` — foreign key index (создаётся автоматически Django)
- Batch операции в `_save_properties()` с `@transaction.atomic` для атомарности
- Избегать N+1 queries: использовать `select_related()` и `prefetch_related()` для маппингов

### Security Considerations

1. **Admin Actions Security:**
   - `merge_attributes` требует confirmation step с preview изменений
   - Все admin actions логируются через Django `LogEntry` для audit trail
   - Используется `@transaction.atomic` для предотвращения partial updates

2. **API Parameter Security:**
   - `?include_inactive=true` доступен только для `request.user.is_staff`
   - Явная проверка прав перед применением параметра

3. **Input Validation:**
   - `normalize_attribute_name()` безопасно обрабатывает входные данные (regex, unicodedata)
   - Защита от SQL injection через Django ORM

## Dependencies

- **Story 14.1:** Модели Attribute и AttributeValue (завершена)
- **Story 14.2:** Import Attributes from 1C (завершена)
- **Epic 13:** Brand Deduplication (референсная архитектура)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Некорректная нормализация (ложные совпадения) | Добавить логирование объединений, возможность ручного разъединения через admin actions |
| Потеря связи с 1С при объединении | Маппинги сохраняют все onec_id, связь не теряется |
| Массовая неактивность атрибутов после миграции | Создать management command для массовой активации + инструкция администратору |
| Сложность отладки | Подробное логирование, admin inline для просмотра маппингов, source field |

## Definition of Done

- [ ] Все AC выполнены для всех stories
- [ ] Тесты покрывают >85% нового кода
- [ ] Code review пройден
- [ ] Документация обновлена (архитектура, API, руководство администратора)
- [ ] Интеграционное тестирование с реальными данными (458 атрибутов, 12,260 значений)
- [ ] Нет регрессий в существующем функционале импорта
- [ ] Migration план протестирован на копии production данных
- [ ] Создана инструкция по активации атрибутов после миграции
- [ ] Все type hints добавлены, mypy validation прошла

## Related Epics

- **Epic 13:** Brand Deduplication — референсная реализация аналогичного паттерна
- **Epic 14:** Product Attributes System — родительский Epic

## Estimated Effort

- **Story 14.3.1:** 5 story points (модели и утилиты)
- **Story 14.3.2:** 3 story points (модель маппинга значений)
- **Story 14.3.3:** 8 story points (логика импорта с дедупликацией)
- **Story 14.3.4:** 8 story points (admin UI с actions)
- **Story 14.3.5:** 3 story points (обновление UI импорта)
- **Story 14.3.6:** 5 story points (фильтрация в API)
- **Story 14.3.7:** 3 story points (документация и тестирование)

**Итого:** 35 story points (~3-4 спринта)

## Success Metrics

**До реализации (текущее состояние):**
- 458 атрибутов после импорта
- ~30-40% дубликатов по названиям
- Все атрибуты активны сразу
- Путаница в админке

**После реализации (целевое состояние):**
- ~280-320 уникальных атрибутов (после дедупликации)
- 0 дубликатов в каталоге
- ~50-100 атрибутов активировано администратором
- Чистый каталог с модерированными атрибутами
- Сохранена полная связь с 1С (все 458 маппингов)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Initial draft | Sarah (PO) |
| 2025-12-04 | 1.1 | Added template compliance sections, Testing details, Source Tree, Type Hints requirements, merge_attributes details | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

-

### Debug Log References

-

### Completion Notes List

-

### File List

-

## QA Results

-

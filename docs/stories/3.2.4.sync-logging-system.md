# Story 3.2.4: sync-logging-system

## Status
Ready for Development

## Story
**As a** системный администратор,
**I want** видеть детальные логи всех операций синхронизации,
**so that** быстро диагностировать проблемы и обеспечить compliance.

## Acceptance Criteria

1. Создана модель `CustomerSyncLog` с полными полями аудита
2. Реализован класс `CustomerSyncLogger` для специализированного логирования
3. Настроена фильтрация логов в Django Admin
4. Созданы методы для генерации отчетов синхронизации
5. Добавлены метрики для мониторинга
6. Настроена ротация логов (хранение 90 дней)
7. Интеграция с системами мониторинга

### Детальные задачи:

- [ ] Создать модель CustomerSyncLog (AC: 1)
  - [ ] Поля: operation_type, customer, customer_email, status
  - [ ] JSONB поле `details` для структурированных данных
  - [ ] Поля временных меток: created_at, updated_at
  - [ ] Индексы для быстрого поиска по дате и статусу
  - [ ] Партиционирование по дате для производительности

- [ ] Реализовать CustomerSyncLogger (AC: 2)
  - [ ] Класс в `apps/users/services/sync_logging.py`
  - [ ] Методы для каждого типа операции:
    - `log_customer_import()` 
    - `log_customer_export()`
    - `log_conflict_resolution()`
    - `log_sync_error()`
  - [ ] Структурированное логирование в JSON формате

- [ ] Настроить Django Admin (AC: 3)
  - [ ] Custom admin для `CustomerSyncLog`
  - [ ] Фильтры: operation_type, status, date range
  - [ ] Поиск по email, customer name, onec_id
  - [ ] Детальный просмотр JSONB данных
  - [ ] Export логов в CSV/Excel

- [ ] Создать отчетность (AC: 4)
  - [ ] Daily sync summary report
  - [ ] Weekly error analysis report  
  - [ ] Monthly customer activity report
  - [ ] Management command для генерации отчетов
  - [ ] Email рассылка отчетов стейкхолдерам

- [ ] Добавить метрики мониторинга (AC: 5)
  - [ ] Счетчики операций по типу и статусу
  - [ ] Время выполнения операций (avg, p95, p99)
  - [ ] Error rates и top errors
  - [ ] Queue sizes и backlog metrics
  - [ ] Integration с Prometheus/Grafana

- [ ] Настроить ротацию логов (AC: 6)
  - [ ] Management command для очистки старых логов
  - [ ] Cron job для ежедневной очистки
  - [ ] Архивирование в S3/другое холодное хранилище
  - [ ] Retention policy: 90 дней hot, 2 года cold

- [ ] Интеграция с мониторингом (AC: 7)
  - [ ] Structured logging с correlation IDs
  - [ ] Integration с ELK stack или аналогом
  - [ ] Real-time alerts через webhook
  - [ ] Dashboard для real-time мониторинга

## Definition of Done
- [ ] Все операции синхронизации логируются
- [ ] Логи доступны через Django Admin  
- [ ] Генерируются ежедневные отчеты
- [ ] Настроены алерты для критических ошибок
- [ ] Соблюдается retention policy

## Dev Notes

### Story Context
**Logging Requirements:**
- **Compliance:** Полный audit trail всех изменений данных клиентов
- **Debugging:** Детальная информация для диагностики проблем 
- **Monitoring:** Real-time метрики для операционной поддержки
- **Reporting:** Регулярные отчеты для менеджмента

### CustomerSyncLog Model
```python
class CustomerSyncLog(models.Model):
    """Детальное логирование всех операций синхронизации клиентов"""
    
    OPERATION_TYPES = [
        ('import_from_1c', 'Импорт из 1С'),
        ('export_to_1c', 'Экспорт в 1С'), 
        ('sync_changes', 'Синхронизация изменений'),
        ('conflict_resolution', 'Разрешение конфликтов'),
        ('data_validation', 'Валидация данных'),
        ('batch_operation', 'Пакетная операция'),
    ]
    
    STATUS_CHOICES = [
        ('success', 'Успешно'),
        ('error', 'Ошибка'),
        ('warning', 'Предупреждение'),
        ('skipped', 'Пропущено'),
        ('pending', 'В процессе'),
    ]
    
    # Основные поля
    operation_type = models.CharField('Тип операции', max_length=30, choices=OPERATION_TYPES)
    status = models.CharField('Статус', max_length=20, choices=STATUS_CHOICES)
    
    # Связь с клиентом (может быть null если клиент не найден)
    customer = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, related_name='sync_logs')
    customer_email = models.EmailField('Email клиента', blank=True)
    onec_id = models.CharField('ID в 1С', max_length=100, blank=True)
    
    # Детальная информация
    details = models.JSONField('Детали операции', default=dict, help_text='Структурированные данные операции')
    error_message = models.TextField('Сообщение об ошибке', blank=True)
    
    # Метаданные
    duration_ms = models.PositiveIntegerField('Длительность (мс)', null=True, blank=True)
    correlation_id = models.CharField('Correlation ID', max_length=50, blank=True, db_index=True)
    
    # Временные метки
    created_at = models.DateTimeField('Дата операции', auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField('Обновлено', auto_now=True)
    
    class Meta:
        verbose_name = 'Лог синхронизации клиентов'
        verbose_name_plural = 'Логи синхронизации клиентов' 
        db_table = 'customer_sync_logs'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['operation_type', 'status', 'created_at']),
            models.Index(fields=['customer_email']),
            models.Index(fields=['onec_id']),
        ]
```

### CustomerSyncLogger Service
```python
class CustomerSyncLogger:
    """Специализированное логирование синхронизации клиентов"""
    
    def __init__(self, correlation_id=None):
        self.correlation_id = correlation_id or self.generate_correlation_id()
    
    def log_customer_import(self, customer_data, result):
        """Логирование импорта клиента из 1С"""
        details = {
            'source': '1c_export',
            'import_timestamp': timezone.now().isoformat(),
            '1c_customer_id': customer_data.get('id'),
            'customer_type': customer_data.get('customer_type'),
            'data_fields': list(customer_data.keys()),
        }
        
        if result.success:
            details.update({
                'platform_customer_id': result.customer.id,
                'assigned_role': result.customer.role,
                'created_new': result.created,
            })
        
        CustomerSyncLog.objects.create(
            operation_type='import_from_1c',
            customer=result.customer if result.success else None,
            customer_email=customer_data.get('email'),
            onec_id=customer_data.get('id'),
            status='success' if result.success else 'error',
            details=details,
            error_message=result.error_message if not result.success else '',
            duration_ms=result.duration_ms,
            correlation_id=self.correlation_id
        )
    
    def log_customer_export(self, platform_customer, result):
        """Логирование экспорта клиента в 1С"""
        details = {
            'destination': '1c_api',
            'export_timestamp': timezone.now().isoformat(),
            'platform_customer_id': platform_customer.id,
            'customer_role': platform_customer.role,
            'export_format': result.export_format,
            'exported_fields': result.exported_fields,
        }
        
        if result.success:
            details.update({
                'assigned_1c_id': result.onec_id,
                '1c_response': result.response_data,
            })
        
        CustomerSyncLog.objects.create(
            operation_type='export_to_1c',
            customer=platform_customer,
            customer_email=platform_customer.email,
            onec_id=result.onec_id if result.success else platform_customer.onec_id,
            status='success' if result.success else 'error',
            details=details,
            error_message=result.error_message if not result.success else '',
            duration_ms=result.duration_ms,
            correlation_id=self.correlation_id
        )
    
    def log_conflict_resolution(self, conflict_data, resolution_result):
        """Логирование разрешения конфликтов"""
        CustomerSyncLog.objects.create(
            operation_type='conflict_resolution',
            customer=resolution_result.resolved_customer,
            customer_email=conflict_data.get('email'),
            status='success' if resolution_result.success else 'warning',
            details={
                'conflict_type': conflict_data.get('conflict_type'),
                'resolution_strategy': resolution_result.strategy_used,
                'conflicting_data': conflict_data.get('differences'),
                'resolution_method': resolution_result.method,
                'manual_review_required': resolution_result.requires_manual_review,
            },
            error_message=resolution_result.error_message,
            correlation_id=self.correlation_id
        )
```

### Django Admin Configuration
```python
@admin.register(CustomerSyncLog)
class CustomerSyncLogAdmin(admin.ModelAdmin):
    list_display = ['created_at', 'operation_type', 'status', 'customer_email', 'onec_id', 'duration_ms']
    list_filter = [
        'operation_type', 
        'status',
        ('created_at', admin.DateFieldListFilter),
        'customer__role',
    ]
    search_fields = ['customer_email', 'onec_id', 'correlation_id', 'error_message']
    readonly_fields = ['created_at', 'updated_at', 'correlation_id']
    date_hierarchy = 'created_at'
    actions = ['export_to_csv', 'mark_as_reviewed']
    
    fieldsets = (
        ('Основная информация', {
            'fields': ('operation_type', 'status', 'customer', 'customer_email', 'onec_id')
        }),
        ('Детали операции', {
            'fields': ('details', 'error_message', 'duration_ms', 'correlation_id'),
            'classes': ('collapse',)
        }),
        ('Временные метки', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    
    def export_to_csv(self, request, queryset):
        """Export selected logs to CSV"""
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="sync_logs.csv"'
        
        writer = csv.writer(response)
        writer.writerow(['Date', 'Operation', 'Status', 'Email', '1C ID', 'Duration', 'Error'])
        
        for log in queryset:
            writer.writerow([
                log.created_at.strftime('%Y-%m-%d %H:%M'),
                log.get_operation_type_display(),
                log.get_status_display(),
                log.customer_email,
                log.onec_id,
                log.duration_ms,
                log.error_message
            ])
        
        return response
    export_to_csv.short_description = "Export to CSV"
```

### Reporting System
```python
class SyncReportGenerator:
    """Генератор отчетов по синхронизации"""
    
    def generate_daily_summary(self, date=None):
        """Ежедневный сводный отчет"""
        date = date or timezone.now().date()
        logs = CustomerSyncLog.objects.filter(created_at__date=date)
        
        return {
            'date': date,
            'total_operations': logs.count(),
            'by_type': logs.values('operation_type').annotate(count=models.Count('id')),
            'by_status': logs.values('status').annotate(count=models.Count('id')),
            'avg_duration': logs.aggregate(avg_duration=models.Avg('duration_ms'))['avg_duration'],
            'top_errors': logs.filter(status='error').values('error_message').annotate(count=models.Count('id')).order_by('-count')[:10],
        }
    
    def generate_weekly_error_analysis(self, start_date=None):
        """Еженедельный анализ ошибок"""
        start_date = start_date or (timezone.now().date() - timedelta(days=7))
        end_date = start_date + timedelta(days=7)
        
        error_logs = CustomerSyncLog.objects.filter(
            created_at__date__gte=start_date,
            created_at__date__lt=end_date,
            status='error'
        )
        
        return {
            'period': f"{start_date} - {end_date}",
            'total_errors': error_logs.count(),
            'error_rate': self.calculate_error_rate(start_date, end_date),
            'errors_by_type': error_logs.values('operation_type').annotate(count=models.Count('id')),
            'common_errors': self.analyze_common_errors(error_logs),
            'affected_customers': error_logs.values('customer').distinct().count(),
        }
```

### Dependencies
- **Depends on:** All other 3.2 stories (import, export, conflicts)
- **Integrates with:** Django Admin, monitoring systems, reporting
- **Related:** Compliance requirements, debugging tools

## Story Points
**5** (Medium complexity - mostly configuration and reporting)

## Priority
**Medium** - Важно для операционной поддержки

## Labels
`epic-3` `logging` `audit-trail` `django-admin` `reporting` `compliance`
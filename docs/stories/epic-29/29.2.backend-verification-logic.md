# Story 29.2: Backend Verification Logic & Access Control

## Status

Draft

---

## Story

**As a** System,  
**I want** to put non-retail registrations into pending status and block their login,  
**so that** only verified business partners can access the platform.

---

## Acceptance Criteria

1. Розничный покупатель (`role='retail'`) регистрируется → получает `is_active=True`, `verification_status='verified'` → может сразу войти

2. Тренер/Оптовик/Федерация (`role != 'retail'`) регистрируется → получает `is_active=False`, `verification_status='pending'` → НЕ может войти

3. При попытке входа пользователь со статусом `pending` получает ошибку:
   - HTTP Status: `403 Forbidden`
   - Error code: `account_pending_verification`
   - Message: `"Ваша учетная запись находится на проверке"`

4. Frontend обрабатывает ошибку `403` с кодом `account_pending_verification` и показывает соответствующее сообщение

5. **API Spec Update:** Обновить `docs/api-spec.yaml` с новым error response для `/api/auth/token/`

6. **Regression:** Существующая функциональность Epic 28 (retail registration, login, password reset) продолжает работать без изменений

---

## Tasks / Subtasks

- [ ] **Task 1: Обновить UserRegistrationSerializer.create()** (AC: 1, 2)
  - [ ] 1.1 Добавить логику установки статусов на основе роли
  - [ ] 1.2 Для retail: `is_active=True`, `verification_status='verified'`
  - [ ] 1.3 Для B2B: `is_active=False`, `verification_status='pending'`
  - [ ] 1.4 Убедиться что `is_verified=False` для B2B (уже реализовано)

- [ ] **Task 2: Обновить JWT Login endpoint** (AC: 3)
  - [ ] 2.1 Найти кастомный TokenObtainPairView или создать его
  - [ ] 2.2 Добавить проверку `verification_status` перед выдачей токена
  - [ ] 2.3 Возвращать 403 с кодом `account_pending_verification` для pending users
  - [ ] 2.4 Добавить логирование попыток входа pending users

- [ ] **Task 3: Обновить Frontend обработку ошибок** (AC: 4)
  - [ ] 3.1 Обновить `LoginForm.tsx` для обработки ошибки 403
  - [ ] 3.2 Добавить проверку `error.code === 'account_pending_verification'`
  - [ ] 3.3 Показать user-friendly сообщение вместо generic error

- [ ] **Task 4: Обновить API Specification** (AC: 5)
  - [ ] 4.1 Добавить в `docs/api-spec.yaml` новый error response
  - [ ] 4.2 Документировать request body с параметром `role`
  - [ ] 4.3 Обновить `docs/architecture/03-api-specification.md`

- [ ] **Task 5: Regression тесты для Epic 28** (AC: 6)
  - [ ] 5.1 Создать `tests/regression/test_epic_28_intact.py`
  - [ ] 5.2 Тест: retail registration → redirect to `/`
  - [ ] 5.3 Тест: retail login → JWT tokens issued
  - [ ] 5.4 Тест: password reset flow works for all roles
  - [ ] 5.5 Тест: existing B2B registration flow (Epic 28) continues working

- [ ] **Task 6: Unit & Integration тесты** (AC: 1-4)
  - [ ] 6.1 Тест: retail registration → is_active=True, verification_status='verified'
  - [ ] 6.2 Тест: B2B registration → is_active=False, verification_status='pending'
  - [ ] 6.3 Тест: pending user login → 403 account_pending_verification
  - [ ] 6.4 Тест: verified B2B user login → success

---

## Dev Notes

### Existing Code Reference

> [!IMPORTANT]
> **Миграция БД НЕ требуется!** Все необходимые поля уже существуют в модели `User`.

**Существующие поля модели User (backend/apps/users/models.py):**

| Поле | Строки | Описание |
|------|--------|----------|
| `role` | L87-92 | choices: retail, wholesale_level1-3, trainer, federation_rep, admin |
| `verification_status` | L190-196 | choices: unverified, verified, pending |
| `is_active` | AbstractUser | Django built-in boolean field |
| `is_verified` | L118-122 | BooleanField (legacy, используется для display) |

[Source: backend/apps/users/models.py#L87-L196]

**Текущая реализация create() в UserRegistrationSerializer:**

```python
# backend/apps/users/serializers.py (L89-105)
def create(self, validated_data):
    """Создание нового пользователя"""
    validated_data.pop("password_confirm")
    password = validated_data.pop("password")
    user = User.objects.create_user(password=password, **validated_data)

    # B2B пользователи требуют верификации
    if user.role != "retail":
        user.is_verified = False  # <-- Уже есть, но неполная логика
        user.save()

    return user
```

[Source: backend/apps/users/serializers.py#L89-L105]

> [!WARNING]
> Нужно добавить:
> - `user.is_active = False` для B2B
> - `user.verification_status = 'pending'` для B2B
> - `user.is_active = True` и `user.verification_status = 'verified'` для retail

### Data Models

**verification_status choices (backend/apps/users/models.py:135-139):**

```python
VERIFICATION_STATUS_CHOICES = [
    ("unverified", "Не верифицирован"),
    ("verified", "Верифицирован"),
    ("pending", "Ожидает верификации"),
]
```

[Source: backend/apps/users/models.py#L135-L139]

### API Specifications

**JWT Token endpoint (POST /api/auth/token/):**

Необходимо кастомизировать `TokenObtainPairView` из `rest_framework_simplejwt`.

```python
# backend/apps/users/views/auth.py (CREATE or MODIFY)
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework.exceptions import AuthenticationFailed

class CustomTokenObtainPairView(TokenObtainPairView):
    def post(self, request, *args, **kwargs):
        # Стандартная аутентификация
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Получаем пользователя
        user = serializer.user
        
        # Проверка статуса верификации
        if user.verification_status == 'pending':
            raise AuthenticationFailed(
                detail="Ваша учетная запись находится на проверке",
                code="account_pending_verification"
            )
        
        return super().post(request, *args, **kwargs)
```

**Новый error response для docs/api-spec.yaml:**

```yaml
# POST /api/auth/token/
responses:
  403:
    description: Account pending verification
    content:
      application/json:
        schema:
          type: object
          properties:
            detail:
              type: string
              example: "Ваша учетная запись находится на проверке"
            code:
              type: string
              example: "account_pending_verification"
```

### File Locations

| Файл | Путь | Действие |
|------|------|----------|
| UserRegistrationSerializer | `backend/apps/users/serializers.py` | MODIFY |
| CustomTokenObtainPairView | `backend/apps/users/views/auth.py` | CREATE or MODIFY |
| URLs | `backend/apps/users/urls.py` | MODIFY (use custom view) |
| LoginForm | `frontend/src/components/auth/LoginForm.tsx` | MODIFY |
| API Spec | `docs/api-spec.yaml` | MODIFY |
| Arch API Doc | `docs/architecture/03-api-specification.md` | MODIFY |
| Regression Tests | `backend/tests/regression/test_epic_28_intact.py` | CREATE |
| Unit Tests | `backend/tests/unit/test_user_verification.py` | CREATE |
| Integration Tests | `backend/tests/integration/test_verification_workflow.py` | CREATE |

### Technical Constraints

**Обратная совместимость:**
- Существующие retail users (Epic 28) должны продолжать работать
- API endpoint `/api/auth/register/` остается тем же
- Только добавляется логика на основе роли

**SimpleJWT integration:**
- Используется `rest_framework_simplejwt` для JWT токенов
- Нужно кастомизировать `TokenObtainPairView` или добавить проверку в serializer

### B2B Verification Workflow Reference

[Source: docs/architecture/18-b2b-verification-workflow.md]

Документ описывает полный workflow верификации:
1. Регистрация → `is_verified=False` (уже реализовано)
2. Ограничения для неверифицированных (цены, количество, оплата)
3. Верификация через Django Admin

Эта история добавляет:
- Блокировку входа (`is_active=False`)
- Явный статус `verification_status='pending'`

---

## Testing

### Test File Location

- `backend/tests/unit/test_user_verification.py`
- `backend/tests/integration/test_verification_workflow.py`
- `backend/tests/regression/test_epic_28_intact.py`

### Test Standards

- **Framework:** Pytest + pytest-django
- **Markers:** `@pytest.mark.unit`, `@pytest.mark.integration`
- **Data Generation:** Factory Boy
- **Coverage:** ≥ 90% для auth модуля

[Source: docs/architecture/10-testing-strategy.md]

### Test Cases

```python
# tests/unit/test_user_verification.py
import pytest
from apps.users.models import User
from apps.users.serializers import UserRegistrationSerializer

@pytest.mark.unit
class TestUserRegistrationVerification:
    """Unit тесты для логики верификации при регистрации"""
    
    def test_retail_registration_sets_active_and_verified(self, db):
        """Retail пользователь получает is_active=True, verification_status='verified'"""
        data = {
            'email': 'retail@example.com',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!',
            'first_name': 'Test',
            'role': 'retail'
        }
        serializer = UserRegistrationSerializer(data=data)
        assert serializer.is_valid(), serializer.errors
        user = serializer.save()
        
        assert user.is_active is True
        assert user.verification_status == 'verified'
    
    def test_b2b_registration_sets_pending_and_inactive(self, db):
        """B2B пользователь получает is_active=False, verification_status='pending'"""
        data = {
            'email': 'b2b@example.com',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!',
            'first_name': 'Test',
            'role': 'trainer',
            'company_name': 'Test Company'
        }
        serializer = UserRegistrationSerializer(data=data)
        assert serializer.is_valid(), serializer.errors
        user = serializer.save()
        
        assert user.is_active is False
        assert user.verification_status == 'pending'
        assert user.is_verified is False


# tests/integration/test_verification_workflow.py
import pytest
from rest_framework import status
from rest_framework.test import APIClient
from apps.users.factories import UserFactory

@pytest.mark.integration
@pytest.mark.django_db
class TestLoginVerificationBlocking:
    """Integration тесты для блокировки входа pending users"""
    
    def setup_method(self):
        self.client = APIClient()
    
    def test_pending_user_login_returns_403(self):
        """Pending пользователь получает 403 при попытке входа"""
        user = UserFactory(
            email='pending@example.com',
            role='trainer',
            is_active=False,
            verification_status='pending'
        )
        user.set_password('TestPass123!')
        user.save()
        
        response = self.client.post('/api/auth/token/', {
            'email': 'pending@example.com',
            'password': 'TestPass123!'
        })
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
        assert response.data['code'] == 'account_pending_verification'
    
    def test_verified_b2b_user_can_login(self):
        """Верифицированный B2B пользователь может войти"""
        user = UserFactory(
            email='verified_b2b@example.com',
            role='trainer',
            is_active=True,
            verification_status='verified',
            is_verified=True
        )
        user.set_password('TestPass123!')
        user.save()
        
        response = self.client.post('/api/auth/token/', {
            'email': 'verified_b2b@example.com',
            'password': 'TestPass123!'
        })
        
        assert response.status_code == status.HTTP_200_OK
        assert 'access' in response.data
        assert 'refresh' in response.data


# tests/regression/test_epic_28_intact.py
import pytest
from rest_framework import status
from rest_framework.test import APIClient
from apps.users.factories import UserFactory

@pytest.mark.integration
@pytest.mark.django_db
class TestEpic28Regression:
    """Regression тесты для Epic 28 функциональности"""
    
    def setup_method(self):
        self.client = APIClient()
    
    def test_retail_registration_still_works(self):
        """Retail регистрация из Epic 28 продолжает работать"""
        response = self.client.post('/api/auth/register/', {
            'email': 'newretail@example.com',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!',
            'first_name': 'New',
            'role': 'retail'
        })
        
        assert response.status_code == status.HTTP_201_CREATED
        # Проверяем что пользователь может войти
        login_response = self.client.post('/api/auth/token/', {
            'email': 'newretail@example.com',
            'password': 'SecurePass123!'
        })
        assert login_response.status_code == status.HTTP_200_OK
    
    def test_retail_login_still_works(self):
        """Retail вход из Epic 28 продолжает работать"""
        user = UserFactory(
            email='retailuser@example.com',
            role='retail',
            is_active=True,
            verification_status='verified'
        )
        user.set_password('TestPass123!')
        user.save()
        
        response = self.client.post('/api/auth/token/', {
            'email': 'retailuser@example.com',
            'password': 'TestPass123!'
        })
        
        assert response.status_code == status.HTTP_200_OK
```

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-12 | 1.0 | Initial story draft | Bob (SM) |

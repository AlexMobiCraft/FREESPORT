# История 28.4: Защищенные маршруты и управление сессиями

**Эпик**: [28: Реализация системы аутентификации](../../epics/epic-28/epic-28-authentication.md)
**Статус**: Черновик
**Приоритет**: Высокий

## Пользовательская история (User Story)

**Как** разработчик,
**Я хочу** защитить маршруты и глобально управлять сессиями,
**Чтобы** неавторизованные пользователи не могли получить доступ к ограниченным страницам, а сессии автоматически обновлялись при истечении токенов.

## Контекст истории

**Интеграция с существующей системой:**

- **Существующий код (ИСПОЛЬЗУЕТСЯ БЕЗ ИЗМЕНЕНИЙ):**
  - `src/stores/authStore.ts` - УЖЕ СУЩЕСТВУЕТ с методами `setTokens()`, `setUser()`, `logout()`, `getRefreshToken()`
  - `src/services/authService.ts` - УЖЕ СУЩЕСТВУЕТ с методами `login()`, `register()`, `refreshToken()`
  - `src/services/api-client.ts` - **УЖЕ РЕАЛИЗОВАН** полностью с Axios Interceptors и Refresh Token flow

- **Что НЕОБХОДИМО СОЗДАТЬ в этой истории:**
  - `src/middleware.ts` - Next.js Middleware для защиты маршрутов
  - `src/providers/AuthProvider.tsx` - Provider для инициализации сессии при загрузке приложения
  - Тесты для middleware

- **Технологии**: Next.js 15.4.6 App Router, TypeScript, Zustand, Axios (УЖЕ настроен)

- **ВАЖНОЕ ОТКРЫТИЕ:**
  - ✅ **Axios Interceptors УЖЕ ПОЛНОСТЬЮ РЕАЛИЗОВАНЫ** в `src/services/api-client.ts`
  - ✅ Refresh Token flow УЖЕ работает (включая очередь concurrent requests и exponential backoff)
  - ✅ JWT Storage архитектура: **Access token in memory (Zustand)**, **Refresh token in localStorage**
  - ⚠️ **Основная задача этой истории - добавить Next.js Middleware и AuthProvider**

## Критерии приемки (Acceptance Criteria)

### Функциональные требования

1. **Защита маршрутов через Next.js Middleware:**
   - 1.1. Middleware проверяет protected routes: `/profile/*`, `/orders/*`, `/b2b-dashboard/*`
   - 1.2. Public routes (`/`, `/catalog/*`, `/product/*`, `/login`, `/register`, `/password-reset`) НЕ защищены
   - 1.3. При попытке доступа к protected route без токена происходит redirect на `/login?next=/original/path`
   - 1.4. После успешного login происходит redirect на сохраненный `next` URL (если есть) или на `/`

2. **Инициализация сессии при загрузке приложения:**
   - 2.1. AuthProvider проверяет наличие refresh token в localStorage при монтировании
   - 2.2. Если refresh token найден, вызывается endpoint `/auth/me/` для получения данных пользователя
   - 2.3. При успехе `authStore` обновляется (`setUser()`, `setTokens()`)
   - 2.4. При ошибке (401, 403) происходит logout (очистка localStorage и authStore)

3. **Автоматическое обновление токенов (УЖЕ РЕАЛИЗОВАНО в api-client.ts):**
   - 3.1. ✅ Response interceptor ловит 401 ошибки
   - 3.2. ✅ Вызывается `/auth/refresh/` с refresh token
   - 3.3. ✅ При успехе обновляется access token и повторяется оригинальный запрос
   - 3.4. ✅ При ошибке refresh происходит logout
   - 3.5. ✅ Concurrent requests queue предотвращает race conditions

### Требования к интеграции

4. **Middleware совместим с Edge Runtime:**
   - 4.1. Middleware НЕ использует Node.js API (только Web APIs)
   - 4.2. Использует `next/server` для работы с cookies и headers
   - 4.3. Matcher config определяет protected routes через regex

5. **Предотвращение бесконечных циклов редиректа:**
   - 5.1. Middleware НЕ редиректит на `/login`, если пользователь уже на `/login`
   - 5.2. Middleware НЕ редиректит на `/login` с `next=/login` параметром

### Требования к качеству

1. **Отсутствие "мелькания неавторизованного контента":**
   - 1.1. Protected pages показывают loading state до проверки аутентификации
   - 1.2. AuthProvider гидрирует authStore перед первым рендером приложения

2. **Unit/Integration тесты:**
   - 2.1. Тесты для middleware logic (protected/public routes, redirects)
   - 2.2. Тесты для AuthProvider (session initialization, token refresh, logout on error)
   - 2.3. Coverage >= 80% для новых компонентов

## Tasks / Subtasks

### Phase 1: Next.js Middleware Setup (AC: 1, 4, 5)

- [ ] **Task 1.1**: Создать Next.js Middleware для защиты маршрутов
  - [ ] Создать файл `src/middleware.ts`
  - [ ] Определить protected routes matcher через `config.matcher`
  - [ ] Реализовать логику проверки токена из authStore (через cookies fallback)
  - [ ] Добавить redirect на `/login?next=/original/path` для unauthorized
  - [ ] Предотвратить бесконечные циклы (не редиректить на `/login`, если уже на `/login`)
  - [ ] Тестировать в Edge Runtime (НЕ использовать Node.js APIs)

- [ ] **Task 1.2**: Обновить layout.tsx для обработки `?next=` параметра после login
  - [ ] В Login page читать query param `next`
  - [ ] После успешного login редиректить на `next` URL или `/`

### Phase 2: AuthProvider для инициализации сессии (AC: 2, 6)

- [ ] **Task 2.1**: Создать AuthProvider компонент
  - [ ] Создать файл `src/providers/AuthProvider.tsx`
  - [ ] Проверить наличие refresh token в localStorage при mount
  - [ ] Если найден - вызвать `/auth/me/` endpoint (использовать api-client)
  - [ ] При успехе обновить authStore (`setUser()`, `setTokens()`)
  - [ ] При ошибке вызвать `authStore.logout()`
  - [ ] Показывать loading state во время инициализации
  - [ ] Передавать `isInitialized` флаг через Context

- [ ] **Task 2.2**: Интегрировать AuthProvider в root layout
  - [ ] Обновить `src/app/layout.tsx`
  - [ ] Обернуть children в `<AuthProvider>`
  - [ ] Убедиться, что Provider монтируется до любого роута

- [ ] **Task 2.3**: Создать useAuth hook для доступа к AuthProvider context
  - [ ] Создать файл `src/hooks/useAuth.ts`
  - [ ] Экспортировать `isInitialized`, `isAuthenticated`, `user` из context
  - [ ] Добавить типизацию для TypeScript

### Phase 3: Обработка edge cases и UX improvements (AC: 5, 6)

- [ ] **Task 3.1**: Добавить loading states для protected pages
  - [ ] Создать компонент `ProtectedRoute` wrapper (опционально)
  - [ ] Protected pages показывают `<Spinner />` до завершения `isInitialized`
  - [ ] Предотвратить "мелькание" unauthorized контента

- [ ] **Task 3.2**: Обработать специальные случаи
  - [ ] Если refresh token истек - показать сообщение "Сессия истекла, войдите снова"
  - [ ] Если пользователь открывает приложение после долгого перерыва - автоматический logout
  - [ ] Добавить retry logic в AuthProvider при network errors (использовать exponential backoff)

### Phase 4: Testing (AC: 7)

- [ ] **Task 4.1**: Unit-тесты для middleware
  - [ ] Создать файл `src/__tests__/middleware.test.ts`
  - [ ] Тест: protected route без токена редиректит на `/login?next=...`
  - [ ] Тест: public route доступен без токена
  - [ ] Тест: предотвращение бесконечного редиректа на `/login`
  - [ ] Тест: корректный формат `next` параметра

- [ ] **Task 4.2**: Integration тесты для AuthProvider
  - [ ] Создать файл `src/providers/__tests__/AuthProvider.test.tsx`
  - [ ] Тест: успешная инициализация с валидным refresh token
  - [ ] Тест: logout при истекшем refresh token (401/403)
  - [ ] Тест: loading state во время инициализации
  - [ ] Тест: обработка network errors (retry logic)
  - [ ] Mock `/auth/me/` endpoint через MSW

- [ ] **Task 4.3**: E2E сценарии (опционально, для полного покрытия)
  - [ ] Playwright тест: попытка доступа к `/profile` без login → редирект → login → возврат на `/profile`
  - [ ] Playwright тест: истечение access token → автоматический refresh → продолжение работы
  - [ ] Playwright тест: истечение refresh token → logout → редирект на `/login`

### Phase 5: Documentation & Review (Definition of Done)

- [ ] **Task 5.1**: Обновить Definition of Done чеклист
  - [ ] Middleware реализован и тестирован
  - [ ] AuthProvider интегрирован в root layout
  - [ ] Session initialization работает корректно
  - [ ] Нет "мелькания" unauthorized контента
  - [ ] Все тесты проходят (coverage >= 80%)
  - [ ] Code review завершен
  - [ ] Документация обновлена (если требуется)

## Dev Notes

### Relevant Source Tree

**ВАЖНО:** Большая часть функциональности УЖЕ РЕАЛИЗОВАНА. Эта история фокусируется на middleware и session initialization.

```plaintext
frontend/src/
├── middleware.ts                           # CREATE - Next.js Middleware для защиты маршрутов
├── providers/
│   ├── AuthProvider.tsx                   # CREATE - Session initialization provider
│   └── __tests__/
│       └── AuthProvider.test.tsx          # CREATE - Integration тесты
├── hooks/
│   └── useAuth.ts                         # CREATE - Hook для доступа к auth context
├── app/
│   ├── layout.tsx                         # UPDATE - Добавить AuthProvider wrapper
│   └── (auth)/
│       └── login/
│           └── page.tsx                   # UPDATE - Обработка ?next= redirect
├── services/
│   ├── api-client.ts                      # EXISTS - ✅ УЖЕ РЕАЛИЗОВАН полностью
│   │                                      #   - Request interceptor (добавляет JWT)
│   │                                      #   - Response interceptor (401 handling)
│   │                                      #   - Refresh token flow с queue
│   │                                      #   - Exponential backoff retry
│   └── authService.ts                     # EXISTS - УЖЕ РЕАЛИЗОВАН
│                                          #   - login(), register(), refreshToken()
├── stores/
│   └── authStore.ts                       # EXISTS - УЖЕ РЕАЛИЗОВАН
│                                          #   - setTokens(), setUser(), logout()
│                                          #   - getRefreshToken()
│                                          #   - JWT Storage: access in memory, refresh in localStorage
└── __tests__/
    └── middleware.test.ts                 # CREATE - Unit тесты для middleware
```

### Existing Code Context (НЕ ИЗМЕНЯТЬ В ЭТОЙ ИСТОРИИ)

#### authStore.ts (УЖЕ РЕАЛИЗОВАН)

```typescript
// src/stores/authStore.ts
interface AuthState {
  accessToken: string | null;
  user: User | null;
  isAuthenticated: boolean;
  setTokens: (access: string, refresh: string) => void;
  setUser: (user: User) => void;
  logout: () => void;
  getRefreshToken: () => string | null;
}

// JWT Storage:
// - Access token: ТОЛЬКО в memory (Zustand state)
// - Refresh token: localStorage для persistence
```

#### authService.ts (УЖЕ РЕАЛИЗОВАН)

```typescript
// src/services/authService.ts
class AuthService {
  async login(credentials: LoginRequest): Promise<LoginResponse>;
  async register(userData: RegisterRequest): Promise<RegisterResponse>;
  async refreshToken(): Promise<RefreshTokenResponse>; // ✅ УЖЕ РЕАЛИЗОВАН
  logout(): void;
}
```

#### api-client.ts (✅ УЖЕ ПОЛНОСТЬЮ РЕАЛИЗОВАН)

**КРИТИЧНО:** Эта история НЕ требует изменений в `api-client.ts`, т.к. Axios Interceptors УЖЕ настроены!

```typescript
// src/services/api-client.ts

// ✅ УЖЕ РЕАЛИЗОВАНО:
// - Request interceptor: добавляет Bearer token из authStore
// - Response interceptor: ловит 401, вызывает refresh, повторяет запрос
// - Очередь concurrent requests (предотвращает race conditions)
// - Exponential backoff для network/server errors
// - Автоматический logout при ошибке refresh token

// Пример Response Interceptor (УЖЕ СУЩЕСТВУЕТ):
apiClient.interceptors.response.use(
  response => response,
  async (error: AxiosError) => {
    if (error.response?.status === 401 && !originalRequest._retry) {
      // Refresh token logic
      const refreshToken = useAuthStore.getState().getRefreshToken();
      const response = await axios.post('/auth/refresh/', { refresh: refreshToken });
      useAuthStore.getState().setTokens(response.data.access, refreshToken);
      // Retry original request
    }
  }
);
```

### API Endpoints Specifications

#### GET /auth/me/

**Назначение:** Получить данные текущего аутентифицированного пользователя

**Request:**

```http
GET /auth/me/
Authorization: Bearer {access_token}
```

**Success Response (200):**

```json
{
  "id": 1,
  "email": "user@example.com",
  "first_name": "John",
  "last_name": "Doe",
  "role": "retail",
  "is_verified": true,
  "company_name": null
}
```

**Error Responses:**

- **401 Unauthorized**: `{ "detail": "Invalid token" }`
- **403 Forbidden**: `{ "detail": "Token expired" }`

**Использование в коде:**

```typescript
// AuthProvider.tsx
const response = await apiClient.get<User>('/auth/me/');
authStore.setUser(response.data);
```

#### POST /auth/refresh/ (УЖЕ ИСПОЛЬЗУЕТСЯ)

**Назначение:** Обновить access token через refresh token

**Request:**

```json
{
  "refresh": "eyJ0eXAiOiJKV1QiLCJhbGc..."
}
```

**Success Response (200):**

```json
{
  "access": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "refresh": "eyJ0eXAiOiJKV1QiLCJhbGc..." // Опционально (если rotation включена)
}
```

**Error Responses:**

- **401 Unauthorized**: `{ "detail": "Token is invalid or expired" }`

### Implementation Details

#### 1. Next.js Middleware (src/middleware.ts)

**Требования:**

- Совместим с **Edge Runtime** (НЕ использовать Node.js APIs)
- Использовать `next/server` для работы с requests/responses
- Определить protected routes через `config.matcher`

**Пример реализации:**

```typescript
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Проверка наличия refresh token в localStorage (через cookie fallback)
  // ВАЖНО: В Edge Runtime нет доступа к localStorage, используем cookie
  const refreshToken = request.cookies.get('refreshToken')?.value;

  // Если нет токена и это protected route - редирект на login
  if (!refreshToken && isProtectedRoute(pathname)) {
    // Предотвратить бесконечный редирект
    if (pathname === '/login') {
      return NextResponse.next();
    }

    const url = request.nextUrl.clone();
    url.pathname = '/login';
    url.searchParams.set('next', pathname);
    return NextResponse.redirect(url);
  }

  return NextResponse.next();
}

function isProtectedRoute(pathname: string): boolean {
  const protectedPaths = ['/profile', '/orders', '/b2b-dashboard'];
  return protectedPaths.some(path => pathname.startsWith(path));
}

// Matcher config (применяется к protected routes)
export const config = {
  matcher: [
    '/profile/:path*',
    '/orders/:path*',
    '/b2b-dashboard/:path*',
  ],
};
```

**ПРОБЛЕМА:** Edge Runtime НЕ имеет доступа к localStorage!

**РЕШЕНИЕ:** Использовать cookies для Middleware проверки. AuthProvider может синхронизировать refresh token между localStorage и cookies.

**Альтернативное решение:**

```typescript
// Middleware проверяет только наличие флага в cookie
// Реальная проверка токена происходит в AuthProvider на клиенте

export function middleware(request: NextRequest) {
  const isAuthenticated = request.cookies.get('isAuthenticated')?.value === 'true';

  if (!isAuthenticated && isProtectedRoute(pathname)) {
    // Redirect to login
  }
}
```

#### 2. AuthProvider для инициализации сессии

**Назначение:**

- Гидратировать authStore из localStorage при загрузке приложения
- Вызвать `/auth/me/` для проверки валидности токена
- Показывать loading state до завершения инициализации

**Пример реализации:**

```typescript
// src/providers/AuthProvider.tsx
'use client';

import { useEffect, useState, createContext, useContext } from 'react';
import { useAuthStore } from '@/stores/authStore';
import apiClient from '@/services/api-client';
import type { User } from '@/types/api';

interface AuthContextValue {
  isInitialized: boolean;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextValue>({
  isInitialized: false,
  isLoading: true,
});

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { setUser, setTokens, logout, getRefreshToken } = useAuthStore();

  useEffect(() => {
    async function initializeAuth() {
      const refreshToken = getRefreshToken();

      if (!refreshToken) {
        setIsLoading(false);
        setIsInitialized(true);
        return;
      }

      try {
        // Вызвать /auth/me/ для проверки токена и получения user данных
        const response = await apiClient.get<User>('/auth/me/');
        setUser(response.data);

        // Токен валиден, установить флаг аутентификации
        // (api-client автоматически добавит Bearer token)
        setIsInitialized(true);
      } catch (error) {
        // Токен истек или невалиден - logout
        console.error('Session initialization failed:', error);
        logout();
      } finally {
        setIsLoading(false);
        setIsInitialized(true);
      }
    }

    initializeAuth();
  }, []);

  // Показывать loading до завершения инициализации
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  return (
    <AuthContext.Provider value={{ isInitialized, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => useContext(AuthContext);
```

#### 3. Обновление root layout

```typescript
// src/app/layout.tsx
import { AuthProvider } from '@/providers/AuthProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ru">
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
```

#### 4. Обработка ?next= параметра в Login page

```typescript
// src/app/(auth)/login/page.tsx
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import authService from '@/services/authService';

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const next = searchParams.get('next') || '/';

  const handleLogin = async (credentials: LoginRequest) => {
    await authService.login(credentials);

    // Redirect на сохраненный URL или на главную
    router.push(next);
  };

  return <LoginForm onSubmit={handleLogin} />;
}
```

### Testing

**Testing Framework:** Vitest 2.1.5 + React Testing Library 16.3.0 + MSW 2.12.2

**Test File Locations:**

- Middleware tests: `src/__tests__/middleware.test.ts`
- AuthProvider tests: `src/providers/__tests__/AuthProvider.test.tsx`
- MSW handlers: `src/__mocks__/handlers.ts` (UPDATE с `/auth/me/` endpoint)

**Testing Standards:**

1. **Naming Convention**: `ComponentName.test.tsx` или `functionName.test.ts`
2. **Structure**: `describe` блоки для группировки, `test` для каждого сценария
3. **Coverage Target**: >= 80% для новых компонентов
4. **Mocking**: MSW для API endpoints, vi.mock() для modules

**Example Test - Middleware:**

```typescript
// src/__tests__/middleware.test.ts
import { describe, test, expect, vi } from 'vitest';
import { NextRequest, NextResponse } from 'next/server';
import { middleware } from '../middleware';

describe('Middleware - Protected Routes', () => {
  test('redirects to /login for protected route without token', () => {
    const request = new NextRequest(new URL('http://localhost:3000/profile'));
    // Mock: no refreshToken cookie

    const response = middleware(request);

    expect(response.status).toBe(307); // Redirect
    expect(response.headers.get('location')).toBe('/login?next=/profile');
  });

  test('allows access to public routes without token', () => {
    const request = new NextRequest(new URL('http://localhost:3000/catalog'));

    const response = middleware(request);

    expect(response.status).toBe(200); // Next()
  });

  test('prevents infinite redirect loop on /login', () => {
    const request = new NextRequest(new URL('http://localhost:3000/login'));

    const response = middleware(request);

    expect(response.status).toBe(200); // Не редиректит
  });
});
```

**Example Test - AuthProvider:**

```typescript
// src/providers/__tests__/AuthProvider.test.tsx
import { describe, test, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { AuthProvider } from '../AuthProvider';
import { useAuthStore } from '@/stores/authStore';
import { server } from '@/__mocks__/server';
import { http, HttpResponse } from 'msw';

describe('AuthProvider - Session Initialization', () => {
  test('initializes session with valid refresh token', async () => {
    // Mock localStorage
    localStorage.setItem('refreshToken', 'valid-refresh-token');

    // Mock /auth/me/ response
    server.use(
      http.get('/auth/me/', () => {
        return HttpResponse.json({
          id: 1,
          email: 'user@example.com',
          first_name: 'John',
          role: 'retail',
          is_verified: true,
        });
      })
    );

    render(
      <AuthProvider>
        <div>App Content</div>
      </AuthProvider>
    );

    // Loading state initially
    expect(screen.queryByText('App Content')).not.toBeInTheDocument();

    // After initialization
    await waitFor(() => {
      expect(screen.getByText('App Content')).toBeInTheDocument();
    });

    // Check authStore was updated
    const { user } = useAuthStore.getState();
    expect(user?.email).toBe('user@example.com');
  });

  test('logs out on expired refresh token (401)', async () => {
    localStorage.setItem('refreshToken', 'expired-token');

    server.use(
      http.get('/auth/me/', () => {
        return HttpResponse.json({ detail: 'Invalid token' }, { status: 401 });
      })
    );

    render(
      <AuthProvider>
        <div>App Content</div>
      </AuthProvider>
    );

    await waitFor(() => {
      expect(screen.getByText('App Content')).toBeInTheDocument();
    });

    // Check logout was called
    const { isAuthenticated } = useAuthStore.getState();
    expect(isAuthenticated).toBe(false);
    expect(localStorage.getItem('refreshToken')).toBeNull();
  });
});
```

**MSW Handlers Update:**

```typescript
// src/__mocks__/handlers.ts
import { http, HttpResponse } from 'msw';

export const authHandlers = [
  // Existing handlers: login, register, refresh

  // NEW: /auth/me/ endpoint
  http.get('/auth/me/', ({ request }) => {
    const authHeader = request.headers.get('Authorization');

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return HttpResponse.json({ detail: 'Invalid token' }, { status: 401 });
    }

    return HttpResponse.json({
      id: 1,
      email: 'test@example.com',
      first_name: 'Test',
      last_name: 'User',
      role: 'retail',
      is_verified: true,
    });
  }),
];

export const handlers = [...authHandlers];
```

### Security Considerations

#### 1. Token Storage Security

**✅ УЖЕ РЕАЛИЗОВАНО в authStore.ts:**

- **Access Token**: Хранится ТОЛЬКО в memory (Zustand state) - НЕ доступен для XSS атак
- **Refresh Token**: localStorage - персистентность между сессиями
- **Logout**: Очищает оба токена (localStorage + Zustand state)

**Риски:**

- ⚠️ **localStorage подвержен XSS** - если злоумышленник внедрит скрипт, он может украсть refresh token
- ✅ **Mitigations:**
  - React автоматически экранирует пользовательские данные (защита от XSS)
  - CSP (Content Security Policy) headers блокируют inline scripts
  - Refresh token имеет ограниченное время жизни (обычно 7-30 дней)

**Альтернатива (для будущего):**

- Использовать **HttpOnly Cookies** для refresh token (НЕ доступны для JavaScript)
- Требует изменений на backend (Django) для set-cookie headers

#### 2. Middleware Security

**Риски:**

- Edge Runtime НЕ имеет доступа к localStorage
- Middleware может только проверять cookies (легко подделать на клиенте)

**Решение:**

- Middleware делает **первичную проверку** (redirect unauthorized users)
- **Реальная валидация** происходит на backend при каждом API request
- AuthProvider делает **дополнительную проверку** через `/auth/me/` endpoint

**ВАЖНО:** Middleware - это **UX improvement**, а НЕ security boundary!

#### 3. CSRF Protection

**✅ УЖЕ ОБРАБОТАНО:**

- JWT токены в Authorization header **НЕ подвержены CSRF** (в отличие от cookies)
- Django CSRF tokens не требуются для JWT API endpoints

#### 4. XSS Prevention

**✅ УЖЕ ОБРАБОТАНО:**

- React автоматически экранирует все пользовательские данные
- Next.js CSP headers блокируют inline scripts (если настроены)

#### 5. Rate Limiting

**Обрабатывается на backend:**

- Django middleware ограничивает частоту запросов к `/auth/*` endpoints
- Frontend НЕ реализует rate limiting

### Edge Cases и Troubleshooting

#### 1. Что если refresh token истек?

**Поведение:**

- `/auth/refresh/` вернет 401
- api-client interceptor вызовет `logout()`
- AuthProvider также вызовет `logout()` при `/auth/me/` ошибке
- Пользователь будет разлогинен и увидит сообщение "Сессия истекла"

**Решение:**

```typescript
// AuthProvider.tsx
catch (error) {
  if (error.response?.status === 401) {
    // Показать toast: "Ваша сессия истекла, войдите снова"
    toast.error('Ваша сессия истекла, пожалуйста, войдите снова');
  }
  logout();
}
```

#### 2. Race Condition при множественных 401 ошибках

**✅ УЖЕ ОБРАБОТАНО в api-client.ts:**

- Используется `isRefreshing` flag
- Concurrent requests добавляются в `failedQueue`
- После успешного refresh все запросы из очереди повторяются

#### 3. Network errors при инициализации

**Решение в AuthProvider:**

```typescript
// Retry logic с exponential backoff
async function initializeAuthWithRetry(retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      await apiClient.get('/auth/me/');
      return;
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
}
```

#### 4. Синхронизация между вкладками

**Текущее поведение:**

- Logout в одной вкладке НЕ влияет на другие вкладки
- Каждая вкладка имеет свой Zustand store (in-memory)

**Решение (опционально для будущего):**

```typescript
// Использовать localStorage events для синхронизации
window.addEventListener('storage', (e) => {
  if (e.key === 'refreshToken' && !e.newValue) {
    // Refresh token был удален в другой вкладке - logout
    logout();
  }
});
```

### Coding Standards

**TypeScript:**

- Строгая типизация всех props, state, functions
- Использовать `interface` для public API компонентов
- Избегать `any`, использовать `unknown` если тип неизвестен

**React Patterns:**

- Использовать `'use client'` директиву для client components
- Server Components по умолчанию (НЕ используют hooks)
- Middleware - **НЕ использовать Node.js APIs** (только Web APIs)

**Error Handling:**

```typescript
try {
  await apiClient.get('/auth/me/');
} catch (error) {
  if (axios.isAxiosError(error)) {
    if (error.response?.status === 401) {
      // Handle unauthorized
    }
  }
  console.error('Auth initialization failed:', error);
}
```

## Критерии готовности (Definition of Done)

- [ ] Next.js Middleware создан и защищает маршруты
- [ ] AuthProvider создан и интегрирован в root layout
- [ ] Session initialization работает корректно (вызывает `/auth/me/`)
- [ ] Logout происходит при истекшем refresh token
- [ ] Redirect с параметром `?next=` работает
- [ ] Нет "мелькания" unauthorized контента на protected routes
- [ ] Все unit/integration тесты проходят (coverage >= 80%)
- [ ] Code review завершен
- [ ] Проверена совместимость middleware с Edge Runtime

## Change Log

| Date       | Version | Description                                   | Author        |
|------------|---------|-----------------------------------------------|---------------|
| 2025-12-10 | 1.0     | Initial story draft from Epic 28              | John (PM)     |
| 2025-12-10 | 2.0     | Complete rewrite by PO: Added Tasks/Subtasks, Dev Notes with detailed Source Tree, API Specs, Testing standards, Security Considerations, Code Examples. Fixed contradictions (JWT storage now verified as localStorage for refresh, memory for access). Clarified that api-client.ts interceptors ALREADY EXIST. Main focus: Middleware + AuthProvider. | Sarah (PO)    |

## Dev Agent Record

### Agent Model Used

To be filled by Dev Agent during implementation

### Debug Log References

To be filled by Dev Agent during implementation

### Completion Notes List

To be filled by Dev Agent during implementation

### File List

To be filled by Dev Agent during implementation

## QA Results

To be filled by QA Agent after implementation review

# Story 13.5b: Интеграция ProductOptions с реальным API

## Status
Draft

## Story
**Как** Frontend разработчик,
**Я хочу** интегрировать ProductOptions с реальным API `/products/{slug}/`,
**Чтобы** отображать актуальные варианты товара и разблокировать Story 12.2.

## Acceptance Criteria

1. ProductOptions использует реальные данные из API вместо MSW mock
2. Типы обновлены из `api.generated.ts` после регенерации OpenAPI
3. При выборе цвета обновляется основное изображение в ProductGallery (FR10, AC4)
4. При выборе опций обновляется информация о наличии и цене в ProductSummary
5. Интеграция с ProductSummary: передаётся `selectedVariant` через props
6. Валидация обязательных опций перед "Добавить в корзину" (FR10, AC7)
7. Написаны integration тесты с реальным API

## Integration Verification
- IV1: Компонент корректно работает с API данными (нет ошибок типов)
- IV2: ProductGallery обновляет изображение при смене цвета
- IV3: ProductSummary показывает цену выбранного варианта

## Tasks / Subtasks

- [ ] Обновить типы из api.generated.ts (AC: 2)
  - [ ] Запустить `npm run generate:types` после обновления OpenAPI
  - [ ] Заменить локальные типы `ProductVariant` на `import { ProductVariant } from '@/types/api.generated'`
  - [ ] Обновить `ProductDetail` с полем `variants: ProductVariant[]`
  - [ ] Проверить что типы соответствуют API schema

- [ ] Заменить MSW mock на реальный API (AC: 1)
  - [ ] Удалить MSW mock для `/products/{slug}/` (или оставить только для тестов)
  - [ ] Использовать реальный fetch к `/api/products/{slug}/`
  - [ ] Обработать loading state пока данные загружаются
  - [ ] Обработать error state если API недоступен

- [ ] Интеграция с ProductGallery (AC: 3, IV2)
  - [ ] При выборе цвета вызвать callback `onColorChange(color: string)`
  - [ ] ProductGallery получает callback и находит variant с этим цветом
  - [ ] Обновить основное изображение: `setMainImage(variant.main_image)`
  - [ ] Обновить галерею: `setGalleryImages(variant.gallery_images)`

- [ ] Интеграция с ProductSummary (AC: 4, 5, IV3)
  - [ ] ProductSummary получает `selectedOptions` через props
  - [ ] Найти выбранный variant по color + size:
    ```typescript
    const selectedVariant = variants.find(
      v => v.color_name === selectedOptions.color &&
           v.size_value === selectedOptions.size
    );
    ```
  - [ ] Передать `selectedVariant` в ProductSummary
  - [ ] Обновить цену: `selectedVariant?.current_price`
  - [ ] Обновить наличие: `selectedVariant?.is_in_stock`
  - [ ] Обновить доступное количество: `selectedVariant?.available_quantity`

- [ ] Валидация обязательных опций (AC: 6)
  - [ ] Создать функцию `validateOptions(selectedOptions, variants)`:
    ```typescript
    function validateOptions(
      selectedOptions: SelectedOptions,
      variants: ProductVariant[]
    ): { valid: boolean; message?: string } {
      const sizes = [...new Set(variants.map(v => v.size_value).filter(Boolean))];
      const colors = [...new Set(variants.map(v => v.color_name).filter(Boolean))];

      if (sizes.length > 0 && !selectedOptions.size) {
        return { valid: false, message: 'Пожалуйста, выберите размер' };
      }

      if (colors.length > 0 && !selectedOptions.color) {
        return { valid: false, message: 'Пожалуйста, выберите цвет' };
      }

      return { valid: true };
    }
    ```
  - [ ] Вызвать валидацию перед "Добавить в корзину" в ProductSummary
  - [ ] Показать error message если валидация не прошла
  - [ ] Заблокировать кнопку "Добавить в корзину" если опции не выбраны

- [ ] Обновить ProductSummary компонент (AC: 4, 5, 6)
  - [ ] Добавить props:
    ```typescript
    interface ProductSummaryProps {
      product: ProductDetail;
      selectedVariant: ProductVariant | null;
      onAddToCart: (variantId: number) => void;
    }
    ```
  - [ ] Отобразить цену выбранного варианта: `selectedVariant?.current_price || 'Выберите опции'`
  - [ ] Отобразить наличие: `selectedVariant?.is_in_stock ? 'В наличии' : 'Нет в наличии'`
  - [ ] Кнопка "Добавить в корзину" disabled если `!selectedVariant || !selectedVariant.is_in_stock`

- [ ] Написать integration тесты с реальным API (AC: 7)
  - [ ] Тест: ProductOptions загружает variants из API
  - [ ] Тест: выбор цвета обновляет ProductGallery изображение
  - [ ] Тест: выбор size/color обновляет ProductSummary цену
  - [ ] Тест: валидация показывает error если опции не выбраны
  - [ ] Тест: кнопка "Добавить в корзину" disabled если нет selectedVariant
  - [ ] Тест: выбор всех опций разблокирует кнопку "Добавить в корзину"

- [ ] Проверка Integration Verification (IV1, IV2, IV3)
  - [ ] IV1: Нет TypeScript ошибок при использовании ProductVariant из api.generated.ts
  - [ ] IV2: ProductGallery меняет изображение при смене цвета
  - [ ] IV3: ProductSummary показывает цену выбранного варианта

## Dev Notes

### Relevant Source Tree
```
frontend/src/
├── components/
│   └── product/
│       ├── ProductOptions.tsx       (UPDATE - использовать api.generated types)
│       ├── ProductSummary.tsx       (UPDATE - интеграция с selectedVariant)
│       ├── ProductGallery.tsx       (UPDATE - обновление изображения)
│       └── __tests__/
│           ├── ProductOptions.test.tsx     (UPDATE - integration тесты)
│           └── ProductSummary.test.tsx     (UPDATE)
├── types/
│   └── api.generated.ts             (READ - после npm run generate:types)
└── services/
    └── productsService.ts           (READ - fetch API)
```

### ProductPage Integration

**Родительский компонент страницы товара:**

```typescript
// app/catalog/[category]/[slug]/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { ProductOptions, SelectedOptions } from '@/components/product/ProductOptions';
import { ProductSummary } from '@/components/product/ProductSummary';
import { ProductGallery } from '@/components/product/ProductGallery';
import { ProductDetail, ProductVariant } from '@/types/api.generated';

export default function ProductPage({ params }: { params: { slug: string } }) {
  const [product, setProduct] = useState<ProductDetail | null>(null);
  const [selectedOptions, setSelectedOptions] = useState<SelectedOptions>({});
  const [selectedVariant, setSelectedVariant] = useState<ProductVariant | null>(null);

  // Fetch product data
  useEffect(() => {
    fetch(`/api/products/${params.slug}/`)
      .then(res => res.json())
      .then(data => setProduct(data));
  }, [params.slug]);

  // Найти выбранный variant при изменении опций
  useEffect(() => {
    if (!product || !selectedOptions.color || !selectedOptions.size) {
      setSelectedVariant(null);
      return;
    }

    const variant = product.variants.find(
      v => v.color_name === selectedOptions.color &&
           v.size_value === selectedOptions.size
    );

    setSelectedVariant(variant || null);
  }, [selectedOptions, product]);

  if (!product) return <div>Loading...</div>;

  return (
    <div className="container mx-auto">
      <div className="grid grid-cols-2 gap-8">
        {/* Gallery */}
        <ProductGallery
          product={product}
          selectedVariant={selectedVariant}
        />

        {/* Summary + Options */}
        <div className="space-y-6">
          <ProductSummary
            product={product}
            selectedVariant={selectedVariant}
          />

          <ProductOptions
            variants={product.variants}
            selectedOptions={selectedOptions}
            onSelectionChange={setSelectedOptions}
          />
        </div>
      </div>
    </div>
  );
}
```

### ProductGallery Update

**Обновление изображения при смене цвета:**

```typescript
// src/components/product/ProductGallery.tsx
'use client';

import { useState, useEffect } from 'react';
import { ProductDetail, ProductVariant } from '@/types/api.generated';

export interface ProductGalleryProps {
  product: ProductDetail;
  selectedVariant: ProductVariant | null;
}

export const ProductGallery: React.FC<ProductGalleryProps> = ({
  product,
  selectedVariant,
}) => {
  const [mainImage, setMainImage] = useState<string>('');
  const [galleryImages, setGalleryImages] = useState<string[]>([]);

  // Обновить изображения при смене selectedVariant
  useEffect(() => {
    if (selectedVariant?.main_image) {
      setMainImage(selectedVariant.main_image);
      setGalleryImages(selectedVariant.gallery_images || []);
    } else if (product.variants.length > 0) {
      // Fallback на первый variant
      const firstVariant = product.variants[0];
      setMainImage(firstVariant.main_image || '');
      setGalleryImages(firstVariant.gallery_images || []);
    }
  }, [selectedVariant, product.variants]);

  return (
    <div className="space-y-4">
      {/* Main image */}
      <div className="aspect-square overflow-hidden rounded-lg">
        <img
          src={mainImage}
          alt={product.name}
          className="w-full h-full object-cover"
        />
      </div>

      {/* Gallery */}
      <div className="grid grid-cols-4 gap-2">
        {galleryImages.map((image, index) => (
          <img
            key={index}
            src={image}
            alt={`${product.name} ${index + 1}`}
            className="aspect-square rounded cursor-pointer hover:opacity-75"
            onClick={() => setMainImage(image)}
          />
        ))}
      </div>
    </div>
  );
};
```

### ProductSummary Update

**Отображение цены и наличия выбранного варианта:**

```typescript
// src/components/product/ProductSummary.tsx
'use client';

import { useState } from 'react';
import { ProductDetail, ProductVariant } from '@/types/api.generated';
import { validateOptions } from '@/utils/productValidation';

export interface ProductSummaryProps {
  product: ProductDetail;
  selectedVariant: ProductVariant | null;
}

export const ProductSummary: React.FC<ProductSummaryProps> = ({
  product,
  selectedVariant,
}) => {
  const [error, setError] = useState<string>('');

  const handleAddToCart = () => {
    if (!selectedVariant) {
      setError('Пожалуйста, выберите все опции товара');
      return;
    }

    if (!selectedVariant.is_in_stock) {
      setError('Выбранный вариант недоступен');
      return;
    }

    // Добавить в корзину
    // ...

    setError('');
  };

  const isAddToCartDisabled = !selectedVariant || !selectedVariant.is_in_stock;

  return (
    <div className="space-y-4">
      <h1 className="text-3xl font-bold">{product.name}</h1>

      {/* Цена */}
      <div className="text-2xl font-semibold">
        {selectedVariant ? (
          <span>{selectedVariant.current_price} ₽</span>
        ) : (
          <span className="text-neutral-500">Выберите опции</span>
        )}
      </div>

      {/* Наличие */}
      <div>
        {selectedVariant ? (
          selectedVariant.is_in_stock ? (
            <span className="text-success">В наличии: {selectedVariant.available_quantity} шт.</span>
          ) : (
            <span className="text-error">Нет в наличии</span>
          )
        ) : (
          <span className="text-neutral-500">Выберите размер и цвет</span>
        )}
      </div>

      {/* Error message */}
      {error && (
        <div className="text-error text-sm">{error}</div>
      )}

      {/* Кнопка */}
      <button
        onClick={handleAddToCart}
        disabled={isAddToCartDisabled}
        className="btn btn-primary w-full disabled:opacity-50 disabled:cursor-not-allowed"
      >
        Добавить в корзину
      </button>
    </div>
  );
};
```

### Validation Utility

**src/utils/productValidation.ts:**

```typescript
import { ProductVariant, SelectedOptions } from '@/types/api.generated';

export interface ValidationResult {
  valid: boolean;
  message?: string;
}

export function validateOptions(
  selectedOptions: SelectedOptions,
  variants: ProductVariant[]
): ValidationResult {
  // Извлечь уникальные опции
  const sizes = [...new Set(variants.map(v => v.size_value).filter(Boolean))];
  const colors = [...new Set(variants.map(v => v.color_name).filter(Boolean))];

  // Проверить обязательные опции
  if (sizes.length > 0 && !selectedOptions.size) {
    return {
      valid: false,
      message: 'Пожалуйста, выберите размер',
    };
  }

  if (colors.length > 0 && !selectedOptions.color) {
    return {
      valid: false,
      message: 'Пожалуйста, выберите цвет',
    };
  }

  return { valid: true };
}
```

### Integration Tests

**src/components/product/__tests__/ProductOptions.integration.test.tsx:**

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import ProductPage from '@/app/catalog/[category]/[slug]/page';
import { server } from '@/mocks/server';
import { http, HttpResponse } from 'msw';

describe('ProductOptions Integration', () => {
  beforeEach(() => {
    // Setup MSW handler для тестов
    server.use(
      http.get('/api/products/:slug/', () => {
        return HttpResponse.json({
          id: 1,
          name: 'Nike Air Max',
          slug: 'nike-air-max',
          variants: [
            {
              id: 1,
              sku: 'NIKE-AM-RED-42',
              color_name: 'Красный',
              color_hex: '#FF0000',
              size_value: '42',
              current_price: '5990.00',
              is_in_stock: true,
              available_quantity: 15,
              main_image: '/media/nike-red.jpg',
            },
            {
              id: 2,
              sku: 'NIKE-AM-BLUE-42',
              color_name: 'Синий',
              color_hex: '#0000FF',
              size_value: '42',
              current_price: '5990.00',
              is_in_stock: true,
              available_quantity: 10,
              main_image: '/media/nike-blue.jpg',
            },
          ],
        });
      })
    );
  });

  it('updates ProductGallery image when color changes', async () => {
    render(<ProductPage params={{ slug: 'nike-air-max' }} />);

    await waitFor(() => {
      expect(screen.getByAltText('Nike Air Max')).toBeInTheDocument();
    });

    // Выбрать цвет "Синий"
    const blueChip = screen.getByText('Синий');
    fireEvent.click(blueChip);

    // Проверить что изображение обновилось
    const mainImage = screen.getByAltText('Nike Air Max') as HTMLImageElement;
    expect(mainImage.src).toContain('/media/nike-blue.jpg');
  });

  it('updates ProductSummary price when variant selected', async () => {
    render(<ProductPage params={{ slug: 'nike-air-max' }} />);

    await waitFor(() => {
      expect(screen.getByText('Выберите опции')).toBeInTheDocument();
    });

    // Выбрать размер и цвет
    fireEvent.click(screen.getByText('42'));
    fireEvent.click(screen.getByText('Красный'));

    // Проверить что цена отображается
    await waitFor(() => {
      expect(screen.getByText('5990.00 ₽')).toBeInTheDocument();
    });
  });

  it('validates required options before add to cart', async () => {
    render(<ProductPage params={{ slug: 'nike-air-max' }} />);

    await waitFor(() => {
      expect(screen.getByText('Добавить в корзину')).toBeInTheDocument();
    });

    // Кнопка disabled пока опции не выбраны
    const addToCartBtn = screen.getByText('Добавить в корзину');
    expect(addToCartBtn).toBeDisabled();

    // Выбрать опции
    fireEvent.click(screen.getByText('42'));
    fireEvent.click(screen.getByText('Красный'));

    // Кнопка enabled
    await waitFor(() => {
      expect(addToCartBtn).not.toBeDisabled();
    });
  });
});
```

### Testing Standards

**Из CLAUDE.md Section: Frontend тестирование:**

#### Test file location
- `frontend/src/components/product/__tests__/ProductOptions.integration.test.tsx`

#### Test frameworks
- **Framework:** Vitest 2.1.5
- **UI Testing:** React Testing Library 16.3.0
- **API Mocking:** MSW 2.12.2

#### Coverage requirements
- **Minimum coverage:** >= 80% для интеграции компонентов
- **Command:** `npm run test:coverage`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-30 | 1.0 | Создание Story 13.5b на основе Epic 13 PRD | Sarah (PO) |

## Dev Agent Record
(Заполняется dev-агентом)

## QA Results
(Заполняется QA-агентом)

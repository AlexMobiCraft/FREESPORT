# Story 13.2: Рефакторинг импорта из 1С для ProductVariant

## Status
Draft

## Story
**Как** Backend разработчик,
**Я хочу** обновить импорт из 1С для создания Product + ProductVariant,
**Чтобы** корректно импортировать товары с вариантами из CommerceML 3.1.

## Acceptance Criteria

1. Парсер `goods.xml` создаёт один `Product` из `<Товар>` с базовой информацией
2. Парсер `offers.xml` создаёт `ProductVariant` из каждого `<Предложение>` с маппингом parent_id#variant_id (FR4)
3. Обрабатываются некорректные данные: пропуск `<Предложение>` без parent с логированием warning (FR4a)
4. Характеристики (цвет, размер) из `<ХарактеристикиТовара>` записываются в `color_name`, `size_value`
5. Товары без вариантов автоматически создают один ProductVariant (FR10a)
6. Изображения из `<Картинка>` записываются в `ProductVariant.main_image` и `gallery_images`
7. Цены из `prices.xml` обновляют соответствующие поля ProductVariant
8. Остатки из `rests.xml` обновляют `ProductVariant.stock_quantity`
9. Batch processing по 500 записей для контроля памяти (NFR4)

## Integration Verification
- IV1: Существующий импорт брендов и категорий остался без изменений
- IV2: Интеграция с 1С остаётся совместимой с CommerceML 3.1 (CR4)
- IV3: Логи импорта содержат информацию о пропущенных записях и ошибках (NFR8)

## Tasks / Subtasks

- [ ] Рефакторинг парсера goods.xml (AC: 1)
  - [ ] Обновить `parse_goods_xml()` для создания только базовой информации Product
  - [ ] Удалить логику записи цен/остатков в Product
  - [ ] Сохранить импорт полей: name, slug, brand, category, description, short_description, specifications
  - [ ] Сохранить импорт SEO полей: meta_title, meta_description, meta_keywords
  - [ ] Убедиться что onec_id сохраняется в Product для маппинга с variants

- [ ] Создать парсер offers.xml для ProductVariant (AC: 2, 3, 4)
  - [ ] Создать функцию `parse_offers_xml()`
  - [ ] Парсить `<Предложение>` элементы из offers.xml
  - [ ] Извлекать `<Ид>` в формате `parent_id#variant_id` и разделять на parts
  - [ ] Найти parent Product по `onec_id = parent_id`
  - [ ] Если parent не найден: логировать warning и пропустить `<Предложение>` (AC3)
  - [ ] Извлекать `<Артикул>` в `ProductVariant.sku`
  - [ ] Парсить `<ХарактеристикиТовара>` для извлечения color_name, size_value (AC4)
  - [ ] Создать ProductVariant с полями: product, sku, onec_id, color_name, size_value

- [ ] Обработка товаров без вариантов (AC: 5)
  - [ ] После парсинга offers.xml проверить Products без variants
  - [ ] Для каждого Product без variants создать один ProductVariant:
    - sku = Product.onec_id (fallback)
    - onec_id = Product.onec_id
    - color_name = '', size_value = ''
    - Все цены = 0 (будут обновлены из prices.xml)
  - [ ] Логировать создание default variants: INFO level

- [ ] Импорт изображений в ProductVariant (AC: 6)
  - [ ] Обновить парсер `<Картинка>` для записи в ProductVariant вместо Product
  - [ ] Маппинг: первое `<Картинка>` → ProductVariant.main_image
  - [ ] Остальные `<Картинка>` → ProductVariant.gallery_images (JSONField array)
  - [ ] Обработка путей: `goods/import_files/XY/filename.jpg`
  - [ ] Копирование файлов в `media/products/variants/`

- [ ] Рефакторинг парсера prices.xml (AC: 7)
  - [ ] Обновить `parse_prices_xml()` для обновления ProductVariant вместо Product
  - [ ] Найти ProductVariant по `onec_id`
  - [ ] Обновить поля: retail_price, opt1_price, opt2_price, opt3_price, trainer_price, federation_price
  - [ ] Логировать отсутствие ProductVariant по onec_id: WARNING level

- [ ] Рефакторинг парсера rests.xml (AC: 8)
  - [ ] Обновить `parse_rests_xml()` для обновления ProductVariant.stock_quantity
  - [ ] Найти ProductVariant по `onec_id`
  - [ ] Обновить `stock_quantity` из `<Количество>`
  - [ ] Логировать отсутствие ProductVariant: WARNING level

- [ ] Реализация batch processing (AC: 9, NFR4)
  - [ ] Разделить импорт на batch'и по 500 записей
  - [ ] Использовать `bulk_create()` для создания ProductVariant (оптимизация)
  - [ ] Использовать `bulk_update()` для обновления цен/остатков
  - [ ] Коммитить транзакцию после каждого batch'а
  - [ ] Логировать progress: "Processed 500/10000 variants"

- [ ] Обновление management команд (AC: 1-9)
  - [ ] Обновить `import_products_from_1c` команду для нового workflow
  - [ ] Последовательность: goods.xml → offers.xml → default variants → prices.xml → rests.xml
  - [ ] Добавить опцию `--batch-size` (default 500)
  - [ ] Добавить опцию `--dry-run` для тестирования без сохранения

- [ ] Настройка логирования (IV3, NFR8)
  - [ ] Создать отдельный logger для импорта: `import_products`
  - [ ] Логировать в файл: `logs/import_products.log`
  - [ ] WARNING level: пропущенные <Предложение> без parent
  - [ ] WARNING level: отсутствие ProductVariant при обновлении цен/остатков
  - [ ] INFO level: статистика импорта (количество Product, ProductVariant)
  - [ ] ERROR level: критические ошибки парсинга XML

- [ ] Написать integration тесты с реальными XML (Coverage >= 90%)
  - [ ] Тест импорта goods.xml → создание Product без цен/остатков
  - [ ] Тест импорта offers.xml → создание ProductVariant с характеристиками
  - [ ] Тест обработки <Предложение> без parent (пропуск + warning)
  - [ ] Тест создания default ProductVariant для товаров без вариантов
  - [ ] Тест импорта изображений в ProductVariant
  - [ ] Тест обновления цен из prices.xml
  - [ ] Тест обновления остатков из rests.xml
  - [ ] Тест batch processing (проверка 500 записей/batch)
  - [ ] Использовать реальные XML из `data/import_1c/` для тестов

- [ ] Проверка Integration Verification (IV1, IV2, IV3)
  - [ ] IV1: Импорт брендов/категорий работает без изменений
  - [ ] IV2: Проверить совместимость с CommerceML 3.1 (структура XML не изменена)
  - [ ] IV3: Проверить логи содержат warnings для пропущенных записей

## Dev Notes

### Relevant Source Tree
```
backend/apps/integrations/
├── management/commands/
│   └── import_products_from_1c.py  (UPDATE - новый workflow)
├── services/
│   ├── commerceml_parser.py        (UPDATE - рефакторинг парсеров)
│   └── import_processor.py         (UPDATE - batch processing)
└── tests/
    └── test_import_products.py     (UPDATE - integration тесты)

data/import_1c/
├── goods/
│   ├── goods.xml                   (READ - базовая информация Product)
│   └── import_files/               (READ - изображения)
├── offers/
│   └── offers.xml                  (READ - варианты ProductVariant)
├── prices/
│   └── prices.xml                  (READ - цены ProductVariant)
└── rests/
    └── rests.xml                   (READ - остатки ProductVariant)
```

### CommerceML 3.1 Structure Reference

**Из product-variant-proposal.md и docs/architecture/20-1c-integration.md:**

#### goods.xml - Базовый товар (Product)
```xml
<Товар>
  <Ид>12345678-abcd-1234-5678-1234567890ab</Ид>
  <Наименование>Кроссовки Nike Air Max</Наименование>
  <БазоваяЕдиница>шт</БазоваяЕдиница>
  <Описание>Описание товара</Описание>
  <Группы>
    <Ид>category-uuid</Ид>
  </Группы>
  <Картинка>goods/import_files/12/front.jpg</Картинка>
  <Картинка>goods/import_files/12/back.jpg</Картинка>
</Товар>
```

#### offers.xml - Варианты товара (ProductVariant)
```xml
<Предложение>
  <Ид>parent-uuid#variant-uuid</Ид>
  <Наименование>Кроссовки Nike Air Max (Красный, 42)</Наименование>
  <Артикул>NIKE-AM-RED-42</Артикул>
  <ХарактеристикиТовара>
    <Характеристика>
      <Наименование>Цвет</Наименование>
      <Значение>Красный</Значение>
    </Характеристика>
    <Характеристика>
      <Наименование>Размер</Наименование>
      <Значение>42</Значение>
    </Характеристика>
  </ХарактеристикиТовара>
</Предложение>
```

#### prices.xml - Цены вариантов
```xml
<Предложение>
  <Ид>parent-uuid#variant-uuid</Ид>
  <Цены>
    <Цена>
      <ИдТипаЦены>retail</ИдТипаЦены>
      <ЦенаЗаЕдиницу>5990</ЦенаЗаЕдиницу>
    </Цена>
    <Цена>
      <ИдТипаЦены>opt1</ИдТипаЦены>
      <ЦенаЗаЕдиницу>4990</ЦенаЗаЕдиницу>
    </Цена>
  </Цены>
</Предложение>
```

#### rests.xml - Остатки вариантов
```xml
<Предложение>
  <Ид>parent-uuid#variant-uuid</Ид>
  <Остатки>
    <Остаток>
      <Склад>Основной склад</Склад>
      <Количество>15</Количество>
    </Остаток>
  </Остатки>
</Предложение>
```

### Import Workflow Sequence

**КРИТИЧНО: Последовательность импорта:**

1. **goods.xml** → Создание базовых Product (name, description, category, brand)
2. **offers.xml** → Создание ProductVariant из <Предложение> (sku, color, size)
3. **Default Variants** → Создание дефолтных ProductVariant для товаров без вариантов
4. **prices.xml** → Обновление цен ProductVariant
5. **rests.xml** → Обновление остатков ProductVariant

**Зависимости:**
- offers.xml требует готовые Product из goods.xml
- prices.xml/rests.xml требуют готовые ProductVariant из offers.xml

### Parsing onec_id Format

**parent_id#variant_id** формат:

```python
def parse_onec_id(onec_id: str) -> tuple[str, str]:
    """
    Парсинг составного onec_id из offers.xml

    Args:
        onec_id: Строка вида "parent-uuid#variant-uuid"

    Returns:
        Tuple (parent_id, variant_id)

    Example:
        >>> parse_onec_id("12345678-abcd#87654321-dcba")
        ("12345678-abcd", "87654321-dcba")
    """
    parts = onec_id.split('#')
    if len(parts) != 2:
        raise ValueError(f"Invalid onec_id format: {onec_id}")
    return parts[0], parts[1]
```

### Характеристики Товара (ХарактеристикиТовара)

**Извлечение color_name и size_value:**

```python
def parse_characteristics(xml_element) -> dict[str, str]:
    """
    Парсинг <ХарактеристикиТовара> из offers.xml

    Returns:
        Dict с ключами 'color_name', 'size_value'
    """
    characteristics = {}
    for char in xml_element.findall('.//Характеристика'):
        name = char.find('Наименование').text
        value = char.find('Значение').text

        if name == 'Цвет':
            characteristics['color_name'] = value
        elif name == 'Размер':
            characteristics['size_value'] = value

    return {
        'color_name': characteristics.get('color_name', ''),
        'size_value': characteristics.get('size_value', ''),
    }
```

### Default Variants Workflow (AC5 - SPEC-001)

#### КРИТИЧНО: Создание дефолтных ProductVariant для товаров без вариантов

**Когда выполняется:**

- Шаг 3 workflow: ПОСЛЕ `parse_offers_xml()` и ДО `parse_prices_xml()`

**Алгоритм:**

```python
from __future__ import annotations
from decimal import Decimal
from typing import TYPE_CHECKING
import logging

if TYPE_CHECKING:
    from apps.products.models import Product, ProductVariant

logger = logging.getLogger('import_products')

def create_default_variants() -> None:
    """
    Создание дефолтных ProductVariant для товаров без вариантов

    Выполняется ПОСЛЕ parse_offers_xml() и ДО parse_prices_xml()

    Логика:
    1. Найти все Products без ProductVariant (variants__isnull=True)
    2. Для каждого Product создать один ProductVariant:
       - sku = Product.onec_id (fallback)
       - onec_id = Product.onec_id (для маппинга с prices.xml)
       - color_name = '', size_value = '' (пустые характеристики)
       - is_active = True (активен сразу, цены обновятся из prices.xml)
       - Все цены = 0 (будут обновлены из prices.xml)
       - stock_quantity = 0 (будет обновлен из rests.xml)
    3. Bulk create для производительности
    4. Логировать INFO для каждого созданного default variant
    """
    # Найти все Products без ProductVariant
    products_without_variants = Product.objects.filter(
        variants__isnull=True,
        is_active=True  # Только активные товары
    )

    count = products_without_variants.count()
    logger.info(f"Found {count} products without variants")

    if count == 0:
        logger.info("No products without variants found, skipping default variant creation")
        return

    default_variants: list[ProductVariant] = []
    for product in products_without_variants:
        variant = ProductVariant(
            product=product,
            sku=product.onec_id,  # fallback: используем onec_id Product
            onec_id=product.onec_id,  # для маппинга с prices.xml/rests.xml
            color_name='',  # пустые характеристики
            size_value='',
            is_active=True,  # Активен сразу, цены обновятся из prices.xml
            # Цены по умолчанию = 0, будут обновлены из prices.xml
            retail_price=Decimal('0'),
            opt1_price=Decimal('0'),
            opt2_price=Decimal('0'),
            opt3_price=Decimal('0'),
            trainer_price=Decimal('0'),
            federation_price=Decimal('0'),
            stock_quantity=0  # Будет обновлен из rests.xml
        )
        default_variants.append(variant)
        logger.info(
            f"Creating default variant for product: {product.name} "
            f"(onec_id={product.onec_id}, sku={product.onec_id})"
        )

    # Bulk create для производительности
    if default_variants:
        ProductVariant.objects.bulk_create(default_variants)
        logger.info(f"Successfully created {len(default_variants)} default variants")
```

**Обоснование решений:**

- **is_active=True:** Товар должен быть виден в каталоге сразу, даже если цены еще не обновлены (frontend может показать "Цена по запросу")
- **sku=Product.onec_id:** Fallback для товаров без артикула в 1С (будет обновлен если придет offers.xml в будущем)
- **onec_id=Product.onec_id:** Критично для маппинга с prices.xml/rests.xml на следующих шагах workflow

### Image Import Strategy (AC6 - SPEC-002)

#### КРИТИЧНО: Выбор стратегии импорта изображений

**Выбранная стратегия: Вариант A (Hybrid Approach) - РЕКОМЕНДУЕТСЯ**

#### Обоснование выбора

1. **Соответствие Epic 13 PRD:** FR10b явно указывает на Hybrid approach
2. **Практичность:** В реальных данных из 1С могут быть:
   - `goods.xml` с общими изображениями модели
   - `offers.xml` с изображениями конкретных цветовых вариантов
   - Или только базовые изображения без специфичных для вариантов
3. **UX:** Лучше показать общие изображения, чем оставить товар без картинок

#### Алгоритм Hybrid Approach

##### Шаг 1: Парсинг goods.xml → Product.base_images

```python
def parse_goods_xml_images(xml_element, product: Product) -> None:
    """
    Импорт базовых изображений из goods.xml в Product.base_images

    Args:
        xml_element: <Товар> element из goods.xml
        product: Product instance

    Сохраняет все <Картинка> из goods.xml в Product.base_images (JSONField list)
    Эти изображения используются как fallback для ProductVariant без собственных картинок
    """
    images = []
    for img_elem in xml_element.findall('.//Картинка'):
        img_path = img_elem.text.strip()
        if img_path:
            # Путь вида: goods/import_files/XY/filename.jpg
            # Копировать в: media/products/base/{product.onec_id}/filename.jpg
            target_path = copy_image_to_media(
                source_path=img_path,
                destination_dir=f'products/base/{product.onec_id}/'
            )
            images.append(target_path)

    product.base_images = images  # JSONField list
    product.save(update_fields=['base_images'])
    logger.info(f"Imported {len(images)} base images for product {product.name}")
```

##### Шаг 2: Парсинг offers.xml → ProductVariant.main_image + gallery_images

```python
def parse_offers_xml_images(xml_element, variant: ProductVariant) -> None:
    """
    Импорт изображений варианта из offers.xml

    Args:
        xml_element: <Предложение> element из offers.xml
        variant: ProductVariant instance

    Логика:
    - Первое <Картинка> → ProductVariant.main_image
    - Остальные <Картинка> → ProductVariant.gallery_images (JSONField array)
    - Если <Картинка> отсутствуют → оставить поля пустыми (frontend использует Product.base_images)
    """
    images = []
    for img_elem in xml_element.findall('.//Картинка'):
        img_path = img_elem.text.strip()
        if img_path:
            # Путь вида: goods/import_files/XY/filename.jpg
            # Копировать в: media/products/variants/{variant.onec_id}/filename.jpg
            target_path = copy_image_to_media(
                source_path=img_path,
                destination_dir=f'products/variants/{variant.onec_id}/'
            )
            images.append(target_path)

    if images:
        variant.main_image = images[0]  # Первое изображение
        variant.gallery_images = images[1:] if len(images) > 1 else []  # Остальные
        variant.save(update_fields=['main_image', 'gallery_images'])
        logger.info(
            f"Imported {len(images)} images for variant {variant.sku} "
            f"(main={variant.main_image}, gallery={len(variant.gallery_images)})"
        )
    else:
        # Нет специфичных изображений для варианта
        # Frontend будет использовать Product.base_images через effective_images()
        logger.info(
            f"No specific images for variant {variant.sku}, "
            f"will use Product.base_images as fallback"
        )
```

##### Шаг 3: Frontend - метод effective_images() (НЕ часть Story 13.2, см. Story 13.3+)

```python
# backend/apps/products/models.py
class ProductVariant(models.Model):
    # ... existing fields ...

    @property
    def effective_images(self) -> list[str]:
        """
        Возвращает изображения варианта ИЛИ fallback на Product.base_images

        Returns:
            List[str]: Пути к изображениям для отображения на frontend
        """
        if self.main_image:
            # Вариант имеет собственные изображения
            result = [self.main_image]
            if self.gallery_images:
                result.extend(self.gallery_images)
            return result

        # Fallback на базовые изображения продукта
        return self.product.base_images if self.product.base_images else []
```

#### Сравнение с Вариант B (Simplified)

**Вариант B (НЕ рекомендуется):**

- goods.xml `<Картинка>` → игнорировать
- offers.xml `<Картинка>` → ProductVariant.main_image/gallery_images

**Риски Варианта B:**

- ❌ Товары без специфичных изображений вариантов останутся БЕЗ картинок
- ❌ Не соответствует FR10b из Epic 13 PRD
- ❌ Плохой UX для товаров где 1С не экспортирует изображения для каждого варианта

**Вывод:** Используем Вариант A (Hybrid)

### Batch Processing Implementation

**На основе NFR4 (до 10,000 SKU без превышения памяти):**

```python
from django.db import transaction
from typing import List

def import_variants_batch(variants_data: List[dict], batch_size: int = 500) -> None:
    """
    Импорт ProductVariant с batch processing

    Args:
        variants_data: Список словарей с данными вариантов
        batch_size: Размер batch (default 500)
    """
    total = len(variants_data)

    for i in range(0, total, batch_size):
        batch = variants_data[i:i+batch_size]

        with transaction.atomic():
            # Создание объектов без сохранения
            variants_to_create = [
                ProductVariant(**data) for data in batch
            ]

            # Bulk create для оптимизации
            ProductVariant.objects.bulk_create(variants_to_create)

        logger.info(f"Processed {min(i+batch_size, total)}/{total} variants")
```

### Logging Configuration

**Из NFR8 (логирование ошибок импорта):**

```python
import logging

# settings.py
LOGGING = {
    'version': 1,
    'handlers': {
        'import_file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': 'logs/import_products.log',
            'formatter': 'detailed',
        },
    },
    'loggers': {
        'import_products': {
            'handlers': ['import_file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
    'formatters': {
        'detailed': {
            'format': '[{asctime}] {levelname} {name} {message}',
            'style': '{',
        },
    },
}

# Использование в коде
logger = logging.getLogger('import_products')

# WARNING: пропущенные записи
logger.warning(f"Skipping <Предложение> {onec_id}: parent Product not found")

# INFO: статистика
logger.info(f"Imported {products_count} Products, {variants_count} ProductVariants")

# ERROR: критические ошибки
logger.error(f"Failed to parse offers.xml: {error}")
```

### Testing with Real XML Data

**Из CLAUDE.md: Реальные данные из 1С для тестирования**

**КРИТИЧНО:** Для тестирования используются ТОЛЬКО реальные данные из `data/import_1c/`

```python
# test_import_products.py
import pytest
from pathlib import Path

BASE_PATH = Path(__file__).parent.parent.parent.parent / 'data' / 'import_1c'

@pytest.mark.django_db
class TestImportProductsFrom1C:
    def test_import_goods_xml_creates_products(self):
        """Импорт goods.xml создает Products без цен/остатков"""
        goods_xml = BASE_PATH / 'goods' / 'goods_1_1_27c08306-a0aa-453b-b436-f9b494ceb889.xml'

        # Импорт
        parse_goods_xml(goods_xml)

        # Проверка: Product создан, нет полей цен/остатков
        assert Product.objects.count() > 0
        product = Product.objects.first()
        assert hasattr(product, 'name')
        assert not hasattr(product, 'retail_price')  # Удалено в рефакторинге

    def test_import_offers_xml_creates_variants(self):
        """Импорт offers.xml создает ProductVariant с характеристиками"""
        # Prerequisites: import goods.xml first
        goods_xml = BASE_PATH / 'goods' / 'goods_1_1_27c08306-a0aa-453b-b436-f9b494ceb889.xml'
        parse_goods_xml(goods_xml)

        offers_xml = BASE_PATH / 'offers' / 'offers.xml'
        parse_offers_xml(offers_xml)

        # Проверка: ProductVariant создан с color_name, size_value
        assert ProductVariant.objects.count() > 0
        variant = ProductVariant.objects.first()
        assert variant.sku
        assert variant.product  # ForeignKey связь

    def test_skip_offer_without_parent_product(self):
        """<Предложение> без parent Product пропускается с warning"""
        # Создать offers.xml с невалидным parent_id
        # Проверить: variant не создан, warning в логах
        pass
```

### Testing Standards

**Из CLAUDE.md Section: Стратегия тестирования:**

#### Test file location
- `backend/apps/integrations/tests/test_import_products.py`

#### Test frameworks
- **Framework:** Pytest 7.4.3 + pytest-django 4.7.0
- **Factory:** Factory Boy 3.3.0
- **Real Data:** XML файлы из `data/import_1c/`

#### Coverage requirements
- **Minimum coverage:** >= 90% для рефакторированных парсеров
- **Command:** `pytest --cov=apps.integrations.services --cov-report=html`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-30 | 1.0 | Создание Story 13.2 на основе Epic 13 PRD | Sarah (PO) |
| 2025-12-01 | 1.1 | Уточнение SPEC-001 (Default Variants Workflow AC5): добавлен детальный алгоритм `create_default_variants()` с обоснованием решений (is_active=True, sku fallback, onec_id маппинг) | Sarah (PO) |
| 2025-12-01 | 1.2 | Определение SPEC-002 (Image Import Strategy AC6): выбран Вариант A (Hybrid Approach) с полными алгоритмами для goods.xml → Product.base_images и offers.xml → ProductVariant images, включая метод effective_images() | Sarah (PO) |

## Dev Agent Record
(Заполняется dev-агентом)

## QA Results

### Review Date: 2025-12-01

### Reviewed By: Quinn (Test Architect)

### Review Type: Pre-Implementation Specification Review

**Story Status:** Draft (не реализована)

**Review Scope:** Комплексный анализ спецификации требований, архитектурной совместимости с существующей 1С интеграцией, оценка рисков и зависимостей перед началом разработки.

---

### ❌ КРИТИЧЕСКАЯ БЛОКИРОВКА: Story НЕ готова к разработке

**Gate Status:** **FAIL** → [docs/qa/gates/13.2-refactor-1c-import-productvariant.yml](../../qa/gates/13.2-refactor-1c-import-productvariant.yml)

**Причина:** Блокирующая зависимость — Story 13.1 (ProductVariant модели) не реализована.

**Quality Score:** 40/100

---

### Архитектурный анализ

#### ✅ Сильные стороны спецификации:

1. **Детальная документация CommerceML 3.1:**
   - Все XML структуры (`goods.xml`, `offers.xml`, `prices.xml`, `rests.xml`) полностью задокументированы
   - Примеры parsing кода для onec_id, характеристик, batch processing
   - Корректная ссылка на существующую архитектуру ([docs/architecture/20-1c-integration.md](../../architecture/20-1c-integration.md))

2. **Последовательность импорта четко определена (AC1-9):**
   - Шаг 1: goods.xml → Product (базовая информация)
   - Шаг 2: offers.xml → ProductVariant (SKU, характеристики)
   - Шаг 3: Default variants для товаров без вариантов
   - Шаг 4-5: prices.xml/rests.xml → обновление ProductVariant

3. **Batch processing задокументирован (AC9, NFR4):**
   - Размер batch: 500 записей (соответствует NFR4: до 10,000 SKU)
   - Использование `bulk_create()` и `bulk_update()`
   - Commit транзакции после каждого batch

4. **Logging configuration детализирован (NFR8):**
   - Отдельный logger: `import_products`
   - Уровни: WARNING для пропущенных записей, INFO для статистики, ERROR для критических ошибок
   - Файл логов: `logs/import_products.log`

5. **Integration Verification (IV1-IV3):**
   - IV1: Существующий импорт брендов/категорий остается без изменений
   - IV2: Совместимость с CommerceML 3.1
   - IV3: Логи содержат информацию о пропущенных записях

#### ⚠️ КРИТИЧЕСКИЕ ПРОБЛЕМЫ (блокирующие разработку):

**DEP-001 [CRITICAL - БЛОКИРУЮЩЕЕ]:** Блокирующая зависимость — Story 13.1 не реализована
- **Проблема:** Story 13.2 рефакторирует импорт для создания ProductVariant, но модель ProductVariant еще не существует (Story 13.1 в статусе "Ready", не "Done")
- **Текущее состояние кода:** `backend/apps/products/models.py` содержит только модель `Product` с полями цен/остатков (retail_price, opt1_price, stock_quantity и т.д.)
- **Риск:** Невозможно начать рефакторинг импорта без целевых моделей
- **ОБЯЗАТЕЛЬНОЕ действие:** Выполнить Story 13.1 ДО начала Story 13.2:
  1. Создать модель ProductVariant с полями из FR1
  2. Создать модель ColorMapping (FR6)
  3. Рефакторировать модель Product (удалить price/stock поля)
  4. Выполнить и протестировать Django миграции
  5. Только ПОСЛЕ завершения Story 13.1 начинать Story 13.2

**SPEC-001 [MEDIUM]:** Workflow default variants (AC5) недостаточно детализирован
- **Проблема:** AC5 описывает "товары без вариантов автоматически создают один ProductVariant", но алгоритм неполон:
  - Когда выполняется проверка "Products без variants"? (после парсинга offers.xml?)
  - Какой sku использовать для default variant? (Product.onec_id — корректный fallback?)
  - Должны ли default variants быть is_active=False до импорта цен?
- **Рекомендация PO:** Добавить в Dev Notes детальный алгоритм:
  ```python
  # После парсинга offers.xml:
  products_without_variants = Product.objects.filter(variants__isnull=True)
  for product in products_without_variants:
      ProductVariant.objects.create(
          product=product,
          sku=product.onec_id,  # fallback
          onec_id=product.onec_id,
          color_name='',
          size_value='',
          retail_price=0  # будет обновлено из prices.xml
      )
      logger.info(f"Created default variant for product {product.name}")
  ```

**SPEC-002 [MEDIUM]:** Hybrid подход к изображениям (FR10b) недостаточно задокументирован
- **Проблема:** Story ссылается на Hybrid approach (ProductVariant.effective_images() с fallback на Product.base_images), но детали отсутствуют:
  - Когда `<Картинка>` из goods.xml записываются в Product.base_images?
  - Когда `<Картинка>` из offers.xml записываются в ProductVariant.main_image/gallery_images?
  - Что делать если offers.xml НЕ содержит `<Картинка>` для варианта?
- **Рекомендация PO:** Выбрать стратегию:
  - **Вариант A (рекомендуемый):**
    - goods.xml `<Картинка>` → Product.base_images (JSONField list)
    - offers.xml `<Картинка>` (если есть) → ProductVariant.main_image/gallery_images
    - Frontend: variant.effective_images() возвращает variant images ИЛИ product.base_images
  - **Вариант B (упрощенный):**
    - goods.xml `<Картинка>` → игнорировать
    - offers.xml `<Картинка>` → ProductVariant.main_image/gallery_images
    - **Риск:** товары без специфичных изображений вариантов останутся без картинок

#### ⚠️ Другие выявленные проблемы:

**ARCH-001 [MEDIUM]:** Потенциальный конфликт с существующей структурой импорта
- **Проблема:** Текущий импорт ([backend/apps/products/management/commands/import_catalog_from_1c.py](../../backend/apps/products/management/commands/import_catalog_from_1c.py)) использует двухэтапный подход для единой модели Product:
  - Шаг 1 (строка 301-329): `parse_goods_xml()` → создание заготовок Product с `parent_onec_id`
  - Шаг 2 (строка 332-353): `parse_offers_xml()` → обогащение Product с `onec_id` (составной ID `parent_id#variant_id`)
- **После рефакторинга:** goods.xml → Product, offers.xml → ProductVariant
- **Риск:** Неполная миграция приведет к дублированию данных (старые Product со старыми полями + новые ProductVariant)
- **Рекомендация:**
  1. Задокументировать стратегию миграции существующих данных
  2. Создать migration script для очистки старых Product records
  3. Использовать флаг `--clear-existing` (уже реализован в import_catalog_from_1c.py:68) для полной очистки перед импортом
  4. Протестировать полный цикл импорта на тестовых данных из `data/import_1c/`

**TEST-001 [MEDIUM]:** Отсутствуют integration тесты для batch processing (AC9, NFR4)
- **Проблема:** AC9 и NFR4 требуют batch processing по 500 записей для обработки до 10,000 SKU, но тесты (строки 96-105) не включают:
  - Тест batch size=500 (проверка что batch не превышает лимит)
  - Тест memory usage (профилирование памяти при импорте 10,000 SKU)
  - Тест использования `bulk_create()` вместо individual saves
  - Тест `bulk_update()` для prices/rests
  - Тест atomic transactions per batch
- **Рекомендация:** Добавить integration тесты:
  ```python
  @pytest.mark.django_db
  def test_batch_processing_500_variants():
      """Batch processing разбивает импорт на пакеты по 500"""
      # Создать 1000 mock <Предложение>
      # Импортировать через parse_offers_xml()
      # Проверить: ProductVariant.objects.count() == 1000
      # Проверить логи: "Processed 500/1000", "Processed 1000/1000"

  @pytest.mark.django_db
  def test_batch_processing_uses_bulk_create():
      """Batch processing использует bulk_create для оптимизации"""
      # Mock ProductVariant.objects.bulk_create()
      # Импортировать 600 variants
      # Проверить: bulk_create called 2 times (500 + 100)
  ```

**LOG-001 [LOW]:** Logging configuration требует создания отдельного logger
- **Проблема:** NFR8 требует отдельный logger `import_products`, но неясно как интегрировать с существующим Django logging config
- **Рекомендация:**
  1. Обновить `backend/freesport/settings/base.py`: добавить logger `import_products`
  2. Создать `logs/` директорию в корне проекта
  3. Добавить `.gitignore` для `logs/*.log`
  4. Протестировать ротацию логов (для production)

---

### Requirements Traceability (Given-When-Then)

**AC1: Парсер goods.xml создает один Product из <Товар> с базовой информацией**

- **Given:** XML файл goods.xml содержит <Товар> с полями <Наименование>, <Описание>, <Группы>
- **When:** Выполняется parse_goods_xml()
- **Then:**
  - Создается Product с name, description, category
  - Сохраняется onec_id для маппинга с variants
  - НЕ записываются цены/остатки (перенесены в ProductVariant)
- **Test Coverage:** ✅ `test_import_goods_xml_creates_products()` (строка 367)
- **Gap:** ❌ Отсутствует тест проверки что цены/остатки НЕ записываются в Product

**AC2: Парсер offers.xml создает ProductVariant из <Предложение> с маппингом parent_id#variant_id**

- **Given:** XML файл offers.xml содержит <Предложение> с <Ид> вида "parent-uuid#variant-uuid"
- **When:** Выполняется parse_offers_xml()
- **Then:**
  - Разделяется onec_id на parent_id и variant_id
  - Находится parent Product по parent_id
  - Создается ProductVariant с product FK, sku, onec_id
- **Test Coverage:** ✅ `test_import_offers_xml_creates_variants()` (строка 379)
- **Gap:** ❌ Отсутствует тест для edge case: onec_id без '#' разделителя

**AC3: Обрабатываются некорректные данные: пропуск <Предложение> без parent с логированием warning**

- **Given:** offers.xml содержит <Предложение> с parent_id который не существует в Product
- **When:** Выполняется parse_offers_xml()
- **Then:**
  - <Предложение> пропускается (не создается ProductVariant)
  - Логируется WARNING: "Skipping <Предложение> {onec_id}: parent Product not found"
- **Test Coverage:** ✅ `test_skip_offer_without_parent_product()` (строка 394)
- **Gap:** ❌ Тест требует реализацию (placeholder "pass")

**AC4: Характеристики (цвет, размер) из <ХарактеристикиТовара> записываются в color_name, size_value**

- **Given:** <Предложение> содержит <ХарактеристикиТовара> с "Цвет" и "Размер"
- **When:** Парсится <Характеристика>
- **Then:**
  - Извлекается <Наименование> == "Цвет" → ProductVariant.color_name
  - Извлекается <Наименование> == "Размер" → ProductVariant.size_value
- **Test Coverage:** ✅ Документирован в Dev Notes (строки 244-270)
- **Gap:** ❌ Отсутствует integration тест `test_parse_characteristics_color_and_size()`

**AC5: Товары без вариантов автоматически создают один ProductVariant**

- **Given:** Product создан из goods.xml, но не имеет соответствующих <Предложение> в offers.xml
- **When:** После парсинга offers.xml выполняется проверка Products без variants
- **Then:**
  - Создается ProductVariant с sku=Product.onec_id, color_name='', size_value=''
  - Логируется INFO: "Created default variant for product {name}"
- **Test Coverage:** ✅ `test_import_offers_xml_creates_variants()` (строка 379) — но неполный
- **Gap:** ❌ Требуется dedicated тест для default variants без характеристик (**SPEC-001 блокирует**)

**AC6: Изображения из <Картинка> записываются в ProductVariant.main_image и gallery_images**

- **Given:** goods.xml или offers.xml содержат <Картинка> с путями к изображениям
- **When:** Парсятся <Картинка> элементы
- **Then:**
  - Первое <Картинка> → ProductVariant.main_image
  - Остальные <Картинка> → ProductVariant.gallery_images (JSONField array)
  - Файлы копируются из `goods/import_files/XY/` в `media/products/variants/`
- **Test Coverage:** ✅ `test_import_of_images_into_productvariant()` (строка 385)
- **Gap:** ❌ Отсутствует спецификация Hybrid approach (**SPEC-002 блокирует**)

**AC7: Цены из prices.xml обновляют соответствующие поля ProductVariant**

- **Given:** prices.xml содержит <Предложение> с <Цены> для onec_id
- **When:** Выполняется parse_prices_xml()
- **Then:**
  - Находится ProductVariant по onec_id
  - Обновляются retail_price, opt1_price, opt2_price, opt3_price, trainer_price, federation_price
  - Если ProductVariant не найден → WARNING log
- **Test Coverage:** ✅ `test_update_prices_from_prices_xml()` (строка 402)
- **Gap:** ❌ Отсутствует тест для множественных типов цен (6 ролей)

**AC8: Остатки из rests.xml обновляют ProductVariant.stock_quantity**

- **Given:** rests.xml содержит <Предложение> с <Остатки><Количество>
- **When:** Выполняется parse_rests_xml()
- **Then:**
  - Находится ProductVariant по onec_id
  - Обновляется stock_quantity из <Количество>
  - Если ProductVariant не найден → WARNING log
- **Test Coverage:** ✅ `test_update_stocks_from_rests_xml()` (строка 407)

**AC9: Batch processing по 500 записей для контроля памяти (NFR4)**

- **Given:** offers.xml содержит 10,000 <Предложение>
- **When:** Выполняется импорт с batch_size=500
- **Then:**
  - Импорт разбивается на 20 batch'ей
  - Используется `bulk_create()` для ProductVariant
  - Commit транзакции после каждого batch
  - Логируется progress: "Processed 500/10000", "Processed 1000/10000", ...
- **Test Coverage:** ✅ `test_batch_processing_500_records_per_batch()` (строка 408)
- **Gap:** ❌ Отсутствует реализация теста (**TEST-001**)

---

### Non-Functional Requirements Validation

| NFR | Требование | Статус | Примечания |
|-----|-----------|--------|------------|
| **NFR4** | Batch processing: до 10,000 SKU без превышения памяти | ⚠️ CONCERNS | Спецификация корректна (batch_size=500), но отсутствуют integration тесты для подтверждения (TEST-001) |
| **NFR8** | Логирование ошибок импорта | ✅ PASS | Logger `import_products` задокументирован, уровни WARNING/INFO/ERROR определены (LOG-001 — minor) |

---

### Integration Verification Status

| Verification | Требование | Статус | Примечания |
|--------------|-----------|--------|------------|
| **IV1** | Существующий импорт брендов/категорий остался без изменений | ✅ PASS | AC подтверждает: импорт брендов/категорий (Шаг 0.5-0.6) не затрагивается |
| **IV2** | Интеграция с 1С остаётся совместимой с CommerceML 3.1 | ✅ PASS | Структура XML не изменяется, только изменяется целевая модель (Product → ProductVariant) |
| **IV3** | Логи импорта содержат информацию о пропущенных записях и ошибках | ✅ PASS | NFR8 logging configuration покрывает требование |

---

### Compliance Check

| Стандарт | Статус | Примечания |
|----------|--------|------------|
| **Coding Standards** | ✅ PASS | Dev Notes содержат примеры с полной типизацией (type hints, from __future__ import annotations) |
| **Project Structure** | ✅ PASS | Файловая структура корректна (apps/integrations/services/, management/commands/) |
| **Testing Strategy** | ⚠️ CONCERNS | Coverage >= 90% задокументирован, но тесты для batch processing, default variants, hybrid images отсутствуют |
| **All ACs Met** | ❌ FAIL | AC5, AC6 требуют уточнений (SPEC-001, SPEC-002) |

---

### Security Review

**Оценка:** ✅ PASS (нет новых security рисков)

- Рефакторинг не вносит изменений в валидацию XML данных
- Существующая защита от XML injection сохраняется
- Logging не раскрывает sensitive данные

---

### Performance Considerations

**Оценка:** ⚠️ CONCERNS (требуется подтверждение тестами)

**Позитивные аспекты:**
- Batch processing по 500 записей соответствует NFR4
- Использование `bulk_create()` и `bulk_update()` задокументировано

**Риски:**
- Отсутствуют integration тесты для подтверждения memory usage при 10,000 SKU (TEST-001)
- Не задокументирован query optimization для поиска parent Product по parent_onec_id (требуется db_index на parent_onec_id — уже есть в текущей модели Product:508)

**Рекомендация:**
- Добавить memory profiling тесты для подтверждения NFR4
- Рассмотреть `select_related('product')` при загрузке ProductVariant для оптимизации joins

---

### Blocking Issues Summary

**Story НЕ может быть начата до устранения следующих блокеров:**

1. ❌ **DEP-001 [CRITICAL]:** Завершить Story 13.1 (ProductVariant модели) — **P0 БЛОКИРУЮЩЕЕ**
2. ⚠️ **SPEC-001 [MEDIUM]:** Уточнить с PO workflow default variants (AC5) — **P1 КРИТИЧНОЕ**
3. ⚠️ **SPEC-002 [MEDIUM]:** Определить с PO Image Import Strategy (AC6) — **P1 КРИТИЧНОЕ**

**Рекомендуемые улучшения (НЕ блокирующие, но важные):**

4. ⚠️ **ARCH-001 [MEDIUM]:** Документировать migration strategy существующих данных — **P2 ВАЖНОЕ**
5. ⚠️ **TEST-001 [MEDIUM]:** Добавить integration тесты для batch processing — **P2 ВАЖНОЕ**
6. **LOG-001 [LOW]:** Создать logging configuration в settings.py — **P3 ЖЕЛАТЕЛЬНОЕ**

---

### Gate Status

**Gate:** FAIL → [docs/qa/gates/13.2-refactor-1c-import-productvariant.yml](../../qa/gates/13.2-refactor-1c-import-productvariant.yml)

**Quality Score:** 40/100

**Status Reason:** Критическая блокирующая зависимость: Story 13.1 (ProductVariant модели) не реализована. Story 13.2 требует существования модели ProductVariant перед началом рефакторинга.

**Updated:** 2025-12-01T14:00:00Z
**Expires:** 2025-12-31

---

### Recommended Status

**❌ NOT Ready for Development** - Story заблокирована до завершения Story 13.1 и уточнения SPEC-001, SPEC-002 с PO.

**Обязательные действия перед началом разработки:**

1. **DEV:** Завершить Story 13.1 (ProductVariant модели и миграции) — см. [docs/qa/gates/13.1-backend-models-productvariant.yml](../../qa/gates/13.1-backend-models-productvariant.yml)
2. **PO:** Уточнить workflow default variants (AC5) — добавить детальный алгоритм в Dev Notes
3. **PO:** Определить Image Import Strategy (AC6) — выбрать между Вариантом A (Hybrid) и Вариантом B (Simplified)
4. **DEV:** Документировать migration strategy существующих данных
5. **DEV:** Добавить integration тесты для batch processing с memory profiling

**После устранения блокеров:**

- Story может быть переведена в статус "Ready"
- Провести повторный QA review для подтверждения готовности
- Обновить gate status с FAIL на CONCERNS или PASS

# Story 13.1: Backend модели ProductVariant и ColorMapping

## Status
Draft

## Story
**Как** Backend разработчик,
**Я хочу** создать модели ProductVariant и ColorMapping с полной типизацией,
**Чтобы** хранить SKU-варианты товаров с ценами, остатками и характеристиками.

## Acceptance Criteria

1. Модель `ProductVariant` создана в `apps/products/models.py` со всеми полями из FR1
2. Модель `ColorMapping` создана для маппинга цветов на hex-коды (FR6)
3. Модель `Product` рефакторирована: удалены поля цен/остатков, добавлен related field `variants`
4. Все модели имеют полную типизацию Python (type hints) с проверкой mypy
5. Созданы индексы на `ProductVariant.sku`, `onec_id`, `product_id`, `is_active` (NFR2)
6. Реализованы computed properties: `is_in_stock`, `available_quantity` (FR8)
7. Реализован метод `get_price_for_user(user)` для роле-ориентированного ценообразования (FR9)
8. Django миграция создана и протестирована на dev окружении
9. Предзагружено 20 базовых цветов в ColorMapping через data migration

## Integration Verification
- IV1: Существующие модели `Brand`, `Category` остались без изменений
- IV2: Foreign key `Product.brand` и `Product.category` работают корректно
- IV3: Миграция выполняется без ошибок на пустой БД

## Tasks / Subtasks

- [ ] Создать модель ProductVariant (AC: 1, 4, 5, 6, 7)
  - [ ] Добавить поле `product = ForeignKey(Product, related_name='variants')`
  - [ ] Добавить поля идентификации: `sku`, `onec_id` (unique=True)
  - [ ] Добавить поля характеристик: `color_name`, `size_value` (blank=True)
  - [ ] Добавить поля цен: `retail_price`, `opt1_price`, `opt2_price`, `opt3_price`, `trainer_price`, `federation_price`
  - [ ] Добавить поля остатков: `stock_quantity`, `reserved_quantity`
  - [ ] Добавить поля изображений: `main_image` (ImageField, **null=True, blank=True**), `gallery_images` (JSONField, **default=list, blank=True**) - опциональные для Hybrid подхода
  - [ ] Добавить поля статуса: `is_active`, `last_sync_at`, `created_at`, `updated_at`
  - [ ] Настроить Meta: `db_table='product_variants'`, `ordering=['color_name', 'size_value']`
  - [ ] Создать индексы на `sku`, `onec_id`, `product_id`, `is_active`, `color_name`, `size_value`, `stock_quantity`
  - [ ] Добавить полную типизацию всех полей и методов (type hints)

- [ ] Реализовать computed properties ProductVariant (AC: 6)
  - [ ] `is_in_stock() -> bool`: проверка `stock_quantity > 0`
  - [ ] `available_quantity() -> int`: возвращает `max(0, stock_quantity - reserved_quantity)`
  - [ ] **`effective_images() -> list[str]`**: Hybrid подход - вернуть собственные изображения если есть, иначе fallback на `product.base_images`

- [ ] Реализовать метод get_price_for_user (AC: 7)
  - [ ] `get_price_for_user(user: User) -> Decimal`: логика аналогична Product.get_price_for_user
  - [ ] Маппинг ролей: retail → retail_price, wholesale_level1 → opt1_price, и т.д.
  - [ ] Добавить type hints для параметров и возвращаемого значения

- [ ] Создать модель ColorMapping (AC: 2, 4)
  - [ ] Поле `name` (CharField, unique=True) - название цвета из 1С
  - [ ] Поле `hex_code` (CharField, max_length=7) - hex-код (#FF0000)
  - [ ] Поле `swatch_image` (ImageField, blank=True) - для градиентов/паттернов
  - [ ] Meta: `db_table='color_mappings'`, `verbose_name='Маппинг цвета'`
  - [ ] Добавить полную типизацию

- [ ] Рефакторинг модели Product (AC: 3)
  - [ ] Удалить поля цен: `retail_price`, `opt1_price`, `opt2_price`, `opt3_price`, `trainer_price`, `federation_price`
  - [ ] Удалить поля остатков: `stock_quantity`, `reserved_quantity`
  - [ ] Удалить старые поля изображений: `main_image`, `gallery_images`
  - [ ] **Добавить поле `base_images` (JSONField, default=list, blank=True)** - общие изображения из 1С для Hybrid подхода
  - [ ] Оставить базовые поля: `name`, `slug`, `brand`, `category`, `description`, `short_description`, `specifications`, SEO-поля
  - [ ] Убедиться что `related_name='variants'` доступен через `product.variants.all()`
  - [ ] Обновить типизацию Product с учетом удаленных/добавленных полей

- [ ] Создать Django миграции (AC: 8)
  - [ ] Сгенерировать миграцию: `python manage.py makemigrations`
  - [ ] Проверить SQL миграции: `python manage.py sqlmigrate products XXXX`
  - [ ] Протестировать миграцию на dev БД: `python manage.py migrate`
  - [ ] Убедиться что миграция выполняется без ошибок

- [ ] Создать data migration для ColorMapping (AC: 9)
  - [ ] Создать пустую миграцию: `python manage.py makemigrations --empty products`
  - [ ] Реализовать функцию `load_basic_colors()` с 20 базовыми цветами:
    - Белый #FFFFFF, Черный #000000, Красный #FF0000, Синий #0000FF
    - Зеленый #00FF00, Желтый #FFFF00, Серый #808080, Розовый #FFC0CB
    - Оранжевый #FFA500, Фиолетовый #800080, Коричневый #A52A2A, Бежевый #F5F5DC
    - Бордовый #800000, Голубой #87CEEB, Салатовый #7FFF00, Сиреневый #C8A2C8
    - Тёмно-синий #00008B, Тёмно-серый #A9A9A9, Светло-серый #D3D3D3, Золотой #FFD700
  - [ ] Использовать `operations = [migrations.RunPython(load_basic_colors)]`
  - [ ] Протестировать data migration на dev БД

- [ ] Написать unit тесты для моделей (Coverage >= 90%)
  - [ ] Тест создания ProductVariant с валидными данными
  - [ ] Тест computed property `is_in_stock` (True/False случаи)
  - [ ] Тест computed property `available_quantity` (с резервом и без)
  - [ ] Тест метода `get_price_for_user()` для всех ролей (retail, opt1-3, trainer, federation)
  - [ ] Тест ForeignKey связи `ProductVariant.product`
  - [ ] Тест unique constraints на `sku` и `onec_id`
  - [ ] Тест создания ColorMapping
  - [ ] Тест рефакторинга Product (отсутствие старых полей цен/остатков)

- [ ] Проверка типизации mypy (AC: 4)
  - [ ] Запустить `mypy apps/products/models.py`
  - [ ] Исправить все ошибки типизации (0 errors)
  - [ ] Убедиться что все методы имеют type hints для параметров и return

- [ ] Проверка Integration Verification (IV1, IV2, IV3)
  - [ ] IV1: Убедиться что модели Brand, Category не изменены
  - [ ] IV2: Протестировать `Product.brand` и `Product.category` работают корректно
  - [ ] IV3: Создать тестовую пустую БД и выполнить `python manage.py migrate` без ошибок

## Dev Notes

### Relevant Source Tree
```
backend/apps/products/
├── models.py              # ProductVariant, ColorMapping (NEW), Product (REFACTORED)
├── factories.py           # ProductVariantFactory (создать в следующей Story)
├── migrations/
│   ├── 00XX_add_productvariant_colorMapping.py  (NEW)
│   └── 00XX_load_basic_colors.py               (DATA MIGRATION)
└── tests/
    ├── test_models.py     # Unit тесты для моделей (UPDATE)
    └── test_migrations.py # Тесты миграций (NEW)
```

### ProductVariant Model Fields Reference

**На основе PRD Section 2.1 FR1:**

```python
class ProductVariant(models.Model):
    # ForeignKey
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='variants')

    # Идентификация
    sku = models.CharField(max_length=100, unique=True)
    onec_id = models.CharField(max_length=100, unique=True, help_text='parent_id#variant_id')

    # Характеристики
    color_name = models.CharField(max_length=100, blank=True)
    size_value = models.CharField(max_length=50, blank=True)

    # Цены (6 типов)
    retail_price = models.DecimalField(max_digits=10, decimal_places=2)
    opt1_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    opt2_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    opt3_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    trainer_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    federation_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)

    # Остатки
    stock_quantity = models.PositiveIntegerField(default=0)
    reserved_quantity = models.PositiveIntegerField(default=0)

    # Изображения (Hybrid подход - опциональные)
    main_image = models.ImageField(upload_to='products/variants/', null=True, blank=True)
    gallery_images = models.JSONField(default=list, blank=True)

    @property
    def effective_images(self) -> list[str]:
        """
        Hybrid подход: вернуть собственные изображения варианта,
        если отсутствуют - fallback на Product.base_images
        """
        if self.main_image:
            images = [self.main_image.url]
            if self.gallery_images:
                images.extend(self.gallery_images)
            return images
        return self.product.base_images if self.product.base_images else []

    # Статус
    is_active = models.BooleanField(default=True)
    last_sync_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

### ColorMapping Model Reference

**На основе PRD Section 2.1 FR6:**

```python
class ColorMapping(models.Model):
    name = models.CharField(max_length=100, unique=True, verbose_name='Название цвета')
    hex_code = models.CharField(max_length=7, verbose_name='Hex-код')
    swatch_image = models.ImageField(upload_to='colors/', blank=True)

    class Meta:
        db_table = 'color_mappings'
        verbose_name = 'Маппинг цвета'
        verbose_name_plural = 'Маппинг цветов'
```

### Product Model Refactoring

**Поля для удаления:**
- ❌ `retail_price`, `opt1_price`, `opt2_price`, `opt3_price`, `trainer_price`, `federation_price`
- ❌ `stock_quantity`, `reserved_quantity`
- ❌ `main_image`, `gallery_images` (старые поля изображений)

**Поля для добавления (Hybrid подход):**
- ✅ **`base_images`** (JSONField, default=list, blank=True) - общие изображения из 1С для fallback в ProductVariant.effective_images

**Поля для сохранения:**
- ✅ `name`, `slug`, `brand`, `category`
- ✅ `description`, `short_description`, `specifications`
- ✅ SEO поля: `meta_title`, `meta_description`, `meta_keywords`
- ✅ `is_active`, `created_at`, `updated_at`

**Пример структуры:**
```python
class Product(models.Model):
    # Базовая информация
    name = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)
    brand = models.ForeignKey(Brand, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)

    # Контент
    description = models.TextField()
    short_description = models.TextField(blank=True)
    specifications = models.JSONField(default=dict)

    # Изображения (Hybrid подход)
    base_images = models.JSONField(default=list, blank=True)  # NEW

    # SEO
    meta_title = models.CharField(max_length=255, blank=True)
    meta_description = models.TextField(blank=True)
    meta_keywords = models.CharField(max_length=500, blank=True)

    # Статус
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

### Coding Standards

**Из CLAUDE.md Section: Стандарты качества кода и типизации:**

1. **Обязательные импорты типизации:**
```python
from __future__ import annotations
from typing import TYPE_CHECKING
from decimal import Decimal

if TYPE_CHECKING:
    from apps.users.models import User
```

2. **Типизация методов моделей:**
```python
def save(self, *args, **kwargs) -> None:
    super().save(*args, **kwargs)

def __str__(self) -> str:
    return self.sku

@property
def is_in_stock(self) -> bool:
    return self.stock_quantity > 0

@property
def available_quantity(self) -> int:
    return max(0, self.stock_quantity - self.reserved_quantity)

def get_price_for_user(self, user: User) -> Decimal:
    # implementation
    pass
```

3. **Meta класс:**
```python
class Meta:
    verbose_name = 'Вариант товара'
    verbose_name_plural = 'Варианты товаров'
    db_table = 'product_variants'
    ordering = ['color_name', 'size_value']
    indexes = [
        models.Index(fields=['product', 'is_active']),
        models.Index(fields=['sku']),
        models.Index(fields=['onec_id']),
        models.Index(fields=['color_name']),
        models.Index(fields=['size_value']),
        models.Index(fields=['stock_quantity']),
    ]
```

### Price Mapping Logic (get_price_for_user)

**На основе существующей логики в Product модели:**

```python
def get_price_for_user(self, user: User) -> Decimal:
    """Получить цену для конкретного пользователя в зависимости от его роли"""
    if not user.is_authenticated:
        return self.retail_price

    role_price_map = {
        'retail': self.retail_price,
        'wholesale_level1': self.opt1_price or self.retail_price,
        'wholesale_level2': self.opt2_price or self.retail_price,
        'wholesale_level3': self.opt3_price or self.retail_price,
        'trainer': self.trainer_price or self.retail_price,
        'federation_rep': self.federation_price or self.retail_price,
    }

    return role_price_map.get(user.role, self.retail_price)
```

### Testing

**Testing Standards из CLAUDE.md:**

#### Test file location
- `backend/apps/products/tests/test_models.py`
- `backend/apps/products/tests/test_migrations.py`

#### Test frameworks
- **Framework:** Pytest 7.4.3 + pytest-django 4.7.0
- **Factory:** Factory Boy 3.3.0 для генерации тестовых данных
- **Coverage:** pytest-cov 4.1.0 (минимум 90% для новых моделей)

#### Test standards
- Использовать Factory Boy для создания тестовых объектов
- Использовать `pytest.mark.django_db` для тестов с БД
- Проверять все edge cases (пустые значения, null, граничные условия)
- Тестировать типизацию через mypy в CI/CD

#### Required test cases

```python
# test_models.py
import pytest
from decimal import Decimal
from apps.products.models import ProductVariant, ColorMapping, Product
from apps.products.factories import ProductFactory
from apps.users.factories import UserFactory

@pytest.mark.django_db
class TestProductVariant:
    def test_create_variant_with_valid_data(self):
        """Создание ProductVariant с валидными данными"""
        pass

    def test_is_in_stock_true_when_stock_positive(self):
        """is_in_stock возвращает True когда stock_quantity > 0"""
        pass

    def test_is_in_stock_false_when_stock_zero(self):
        """is_in_stock возвращает False когда stock_quantity = 0"""
        pass

    def test_available_quantity_with_reserve(self):
        """available_quantity учитывает reserved_quantity"""
        pass

    def test_available_quantity_never_negative(self):
        """available_quantity не может быть отрицательным"""
        pass

    def test_get_price_for_retail_user(self):
        """get_price_for_user возвращает retail_price для retail пользователя"""
        pass

    def test_get_price_for_wholesale_level1(self):
        """get_price_for_user возвращает opt1_price для wholesale_level1"""
        pass

    # ... тесты для других ролей

    def test_sku_unique_constraint(self):
        """SKU должен быть уникальным"""
        pass

    def test_onec_id_unique_constraint(self):
        """onec_id должен быть уникальным"""
        pass

    def test_foreign_key_cascade_delete(self):
        """При удалении Product удаляются все его variants"""
        pass

@pytest.mark.django_db
class TestColorMapping:
    def test_create_color_mapping(self):
        """Создание ColorMapping с названием и hex-кодом"""
        pass

    def test_name_unique_constraint(self):
        """Название цвета должно быть уникальным"""
        pass

@pytest.mark.django_db
class TestProductRefactoring:
    def test_product_has_no_price_fields(self):
        """Product не должен иметь полей цен после рефакторинга"""
        pass

    def test_product_has_no_stock_fields(self):
        """Product не должен иметь полей остатков"""
        pass

    def test_product_variants_related_name(self):
        """product.variants.all() возвращает QuerySet[ProductVariant]"""
        pass
```

#### Migration tests

```python
# test_migrations.py
import pytest
from django.db import connection

@pytest.mark.django_db
class TestProductVariantMigration:
    def test_migration_creates_tables(self):
        """Миграция создает таблицы product_variants и color_mappings"""
        with connection.cursor() as cursor:
            cursor.execute("SELECT to_regclass('product_variants')")
            assert cursor.fetchone()[0] is not None

    def test_basic_colors_loaded(self):
        """Data migration загружает 20 базовых цветов"""
        from apps.products.models import ColorMapping
        assert ColorMapping.objects.count() == 20
        assert ColorMapping.objects.filter(name='Белый', hex_code='#FFFFFF').exists()
```

#### Coverage requirements
- **Minimum coverage:** >= 90% для новых моделей ProductVariant, ColorMapping
- **Command:** `pytest --cov=apps.products.models --cov-report=html`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-30 | 1.0 | Создание Story 13.1 на основе Epic 13 PRD | Sarah (PO) |

## Dev Agent Record
(Заполняется dev-агентом)

## QA Results
(Заполняется QA-агентом)

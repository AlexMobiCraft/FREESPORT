# Story 13.4: Обновление импорта товаров

## Status

Draft  
> Story зависит от завершения Stories 13.1–13.3, чтобы таблица `Brand1CMapping`, поле `Product.onec_brand_id` и обновлённый импорт брендов уже работали.

## Story

**As a** интеграционный инженер 1С,
**I want** чтобы импорт товаров находил master-бренд через маппинг и сохранял `onec_brand_id` по каждому SKU,
**so that** каталог оставался консистентным после дедупликации брендов, а заказы и обратная синхронизация продолжали ссылаться на исходный 1С идентификатор бренда.

## Acceptance Criteria

1. Метод `create_product_placeholder()` ищет бренд через `Brand1CMapping.objects.filter(onec_id=brand_id)`.
2. Если маппинг найден — используется связанный `Brand`.
3. Если маппинг не найден — создаётся "No Brand" (fallback).
4. `Product.onec_brand_id` заполняется из данных 1С.
5. Логирование: если маппинг не найден.

## Tasks / Subtasks

- [ ] **Task 1: Поиск бренда через Brand1CMapping в `create_product_placeholder()`** (AC: 1, 2)
  - [ ] В `backend/apps/products/services/processor.py` заменить строки 177-188 (текущий поиск по `Brand.onec_id`) на поиск через `Brand1CMapping.objects.filter(onec_id=brand_id).select_related('brand').first()`, подставляя связанный `Brand` перед созданием/обновлением товара. [Source: epics/epic-13/epic-13.brand-deduplication.md#story-133]
  - [ ] Удалить устаревший код `Brand.objects.filter(onec_id=brand_id).first()` (строка 181), так как после Story 13.1 поле `Brand.onec_id` больше не существует. [Source: docs/architecture/02-data-models.md#модели-каталога-товаров]
  - [ ] Убедиться, что повторный импорт корректно обрабатывает существующие placeholders и не теряет связь с найденным master-брендом через проверку `if product.brand != mapping.brand`. [Source: docs/architecture/20-1c-integration.md#6-воркфлоу-импорта-каталога]

- [ ] **Task 2: Fallback бренд и логирование отсутствующих маппингов** (AC: 3, 5)
  - [ ] При отсутствии `Brand1CMapping` создавать/использовать бренд "No Brand" и логировать событие уровня WARNING с подробностями (`brand_id`, `product_id`, session). [Source: docs/architecture/12-error-handling.md#1-архитектура-обработки-ошибок]
  - [ ] Добавить метрику/счётчик (например, `stats["brand_fallbacks"]`) для отчётов импорта, чтобы QA могла увидеть количество fallback-сценариев. [Source: docs/architecture/20-1c-integration.md#6-воркфлоу-импорта-каталога]
  - [ ] Обновить CLI-команду `import_catalog_from_1c` и итоговый отчёт, чтобы эти случаи отображались и в логах, и в `ImportLog.summary_report`. [Source: docs/architecture/source-tree.md#backend]

- [ ] **Task 3: Заполнение `Product.onec_brand_id`** (AC: 4)
  - [ ] Перед сохранением placeholder сохранять `goods_data["brand_id"]` в `Product.onec_brand_id` (CharField max_length=100), даже если master-бренд найден. Если `brand_id` отсутствует в `goods_data` — оставить поле `None` без логирования (это валидный кейс для товаров без бренда). [Source: docs/architecture/02-data-models.md#модели-каталога-товаров]
  - [ ] При повторном импорте не перезаписывать поле пустыми значениями; добавить проверку `if brand_id and (not product.onec_brand_id or product.onec_brand_id != brand_id)`. [Source: docs/architecture/20-1c-integration.md#2-архитектурные-принципы]
  - [ ] Убедиться, что `goods_data["brand_id"]` (тип: str | None) корректно передаётся из parser в processor; при необходимости обновить `backend/apps/products/services/parser.py` для извлечения `<Производитель><Ид>` из CommerceML. [Source: docs/architecture/source-tree.md#backend]

- [ ] **Task 4: Интеграционные тесты для импорта товаров с брендами** (AC: 1-5)
  - [ ] Добавить тест `test_create_product_placeholder_uses_brand_mapping` в `backend/tests/integration/import/test_product_import.py`, эмулирующий наличие `Brand1CMapping` и проверяющий связь товара с master-брендом и заполнение `onec_brand_id`. [Source: docs/architecture/10-testing-strategy.md#backend-tests---детальная-структура]
  - [ ] Добавить тест `test_create_product_placeholder_fallbacks_when_mapping_missing`, подтверждающий создание бренда "No Brand" и запись предупреждения в лог. [Source: docs/architecture/12-error-handling.md#1-архитектура-обработки-ошибок]
  - [ ] Покрыть сценарий повторного импорта, где `Brand1CMapping` появляется позже: товар должен обновиться с master-брендом, а поле `onec_brand_id` остаться прежним. [Source: docs/architecture/20-1c-integration.md#6-воркфлоу-импорта-каталога]

## Dev Notes

### Previous Story Insights

- Story 13.1 создала модель `Brand1CMapping`, добавила `Brand.normalized_name` и устранила `Brand.onec_id`, поэтому текущий импорт обязан работать только через маппинги и нормализованные master-бренды. [Source: epics/epic-13/epic-13.brand-deduplication.md#story-131]
- Story 13.2 добавила `Product.onec_brand_id` и тестовые требования для его заполнения и отображения в admin, значит текущая история должна сохранить связь SKU ↔ исходный 1С бренд. [Source: docs/stories/epic-13/13.2.story.md]
- Story 13.3 изменила `process_brands()`, чтобы все brand-дубликаты сливались до импорта товаров, поэтому placeholders больше не должны привязываться напрямую к `Brand.onec_id`. [Source: docs/stories/epic-13/13.3.story.md]

### Data Models & Entities

- `Product` хранит master-бренд через FK `brand` и исходный `onec_brand_id`, что обеспечивает целостность каталога и обратную синхронизацию с 1С. [Source: docs/architecture/02-data-models.md#модели-каталога-товаров]
- `Brand1CMapping` содержит уникальные `onec_id` и `onec_name`, связывая несколько записей 1С с единым master-брендом; поле `brand` удаляется каскадно только при устранении master-бренда. [Source: epics/epic-13/epic-13.brand-deduplication.md#technical-notes]

### Import Workflow & File Locations

- Импорт каталога реализован в `backend/apps/products/services/processor.py` и управляется командами из `backend/apps/products/management/commands/import_catalog_from_1c.py`; шаг 2 создаёт placeholders из `goods.xml`, а шаг 3 обогащает их данными из `offers.xml`. [Source: docs/architecture/20-1c-integration.md#6-воркфлоу-импорта-каталога]
- Структура файлов и расположение сервисов описаны в `docs/architecture/source-tree.md#backend`, поэтому изменения должны оставаться внутри `apps/products/services` и связанных тестовых директорий.

**Файлы для изменения:**

- [ ] `backend/apps/products/services/processor.py` — метод `create_product_placeholder()` (строки 177-188)
- [ ] `backend/apps/products/services/parser.py` — извлечение `brand_id` из CommerceML (если требуется)
- [ ] `backend/apps/products/management/commands/import_catalog_from_1c.py` — обновление отчётов статистики
- [ ] `backend/tests/integration/import/test_product_import.py` — новые интеграционные тесты

**Текущая реализация поиска бренда (processor.py:177-188):**

```python
# Получаем бренд из данных товара или используем "No Brand"
brand = None
brand_id = goods_data.get("brand_id")
if brand_id:
    brand = Brand.objects.filter(onec_id=brand_id).first()  # ← УСТАРЕЛО после Story 13.1
# Если бренд не найден, используем "No Brand"
if brand is None:
    brand, _ = Brand.objects.get_or_create(
        name="No Brand", defaults={"slug": "no-brand", "is_active": True}
    )
```

**Новая реализация (требуется):**

```python
# Поиск бренда через Brand1CMapping
brand = None
brand_id = goods_data.get("brand_id")  # str | None из CommerceML <Производитель><Ид>
if brand_id:
    mapping = Brand1CMapping.objects.filter(onec_id=brand_id).select_related('brand').first()
    if mapping:
        brand = mapping.brand
    else:
        # Fallback: маппинг не найден
        logger.warning(
            f"Brand1CMapping not found for onec_id={brand_id}, "
            f"product={parent_id}, using 'No Brand' fallback"
        )
        self.stats["brand_fallbacks"] = self.stats.get("brand_fallbacks", 0) + 1

if brand is None:
    brand, _ = Brand.objects.get_or_create(
        name="No Brand", defaults={"slug": "no-brand", "is_active": True}
    )

# Заполнение Product.onec_brand_id
product.onec_brand_id = brand_id  # Сохраняем оригинальный 1С ID
```

**Data Flow Diagram:**

```text
CommerceML goods.xml → parser.py (extract brand_id: str | None)
                            ↓
                    processor.create_product_placeholder()
                            ↓
                Brand1CMapping.objects.filter(onec_id=brand_id)
                            ↓
                    ┌───────┴───────┐
                    ↓               ↓
            mapping found    mapping NOT found
                    ↓               ↓
            brand = mapping.brand   logger.warning() + stats["brand_fallbacks"]++
                    ↓               ↓
                    └───────┬───────┘
                            ↓
                    Product.brand = brand (master)
                    Product.onec_brand_id = brand_id (original 1C ID)
                            ↓
                        product.save()
```

### Logging & Metrics

- Логирование должно следовать структуре из документа по обработке ошибок: предупреждения фиксируются через стандартный logger с указанием контекста (session, brand_id, product). [Source: docs/architecture/12-error-handling.md#1-архитектура-обработки-ошибок]
- Импортный отчёт (`ImportLog.summary_report`) должен включать новые счётчики (fallback брендов), чтобы команда могла мониторить качество данных 1С. [Source: docs/architecture/20-1c-integration.md#6-воркфлоу-импорта-каталога]

**Пример логирования fallback-сценария:**

```python
logger.warning(
    f"Brand1CMapping not found for onec_id={brand_id}, "
    f"product={parent_id}, session={self.session_id}, "
    f"using 'No Brand' fallback"
)
```

**Обновление статистики:**

```python
# В ProductDataProcessor.__init__() или reset_stats()
self.stats = {
    "created": 0,
    "updated": 0,
    "errors": 0,
    "brand_fallbacks": 0,  # ← новый счётчик
    # ... остальные счётчики
}

# В итоговом отчёте команды import_catalog_from_1c
self.stdout.write(
    f"Brand fallbacks (no mapping): {processor.stats['brand_fallbacks']}"
)
```

### Testing Requirements

- Использовать `pytest` + `pytest-django`, размещая новые интеграционные тесты в `backend/tests/integration/import/`, помечая их `@pytest.mark.integration`. [Source: docs/architecture/10-testing-strategy.md#backend-tests---детальная-структура]
- Тесты должны придерживаться AAA-паттерна, использовать factoryboy-фикстуры и обеспечивать ≥90% покрытия для критичных путей импорта. [Source: docs/architecture/10-testing-strategy.md#требования-к-покрытию]

### Technical Constraints & Project Structure Notes

- Соблюдать стандарты кодирования (типизация, `from __future__ import annotations`, Black/isort) для файлов `processor.py`, `models.py` и тестов. [Source: docs/architecture/coding-standards.md#backend-django]
- Импортный пайплайн обязан оставаться идемпотентным: повторный запуск не должен дублировать бренды или переписывать `onec_brand_id` пустыми значениями. [Source: docs/architecture/20-1c-integration.md#2-архитектурные-принципы]
- Все изменения ограничиваются каталогами `apps/products` и `backend/tests`, как указано в `source-tree.md`, чтобы не нарушать общую структуру проекта. [Source: docs/architecture/source-tree.md#backend]

## Testing

### Test Coverage Matrix

| AC | Test File | Test Name | Test Description |
|---|---|---|---|
| AC1 | `test_product_import.py` | `test_create_product_placeholder_uses_brand_mapping` | Проверяет поиск бренда через `Brand1CMapping.objects.filter(onec_id=...)` |
| AC2 | `test_product_import.py` | `test_create_product_placeholder_uses_brand_mapping` | Проверяет использование связанного `mapping.brand` |
| AC3 | `test_product_import.py` | `test_create_product_placeholder_fallbacks_when_mapping_missing` | Проверяет создание "No Brand" при отсутствии маппинга |
| AC4 | `test_product_import.py` | `test_create_product_placeholder_sets_onec_brand_id` | Проверяет заполнение `Product.onec_brand_id` из `goods_data["brand_id"]` |
| AC5 | `test_product_import.py` | `test_create_product_placeholder_fallbacks_when_mapping_missing` | Проверяет логирование WARNING при отсутствии маппинга |
| Idempotency | `test_product_import.py` | `test_reimport_updates_brand_without_overwriting_onec_brand_id` | Проверяет, что повторный импорт не перезаписывает `onec_brand_id` |

### Test Scenarios

**Test 1: `test_create_product_placeholder_uses_brand_mapping`**

- **Arrange:** Создать `Brand` ("Nike", normalized_name="nike") + `Brand1CMapping` (onec_id="1C-NIKE-001")
- **Act:** Вызвать `create_product_placeholder(goods_data={"brand_id": "1C-NIKE-001", ...})`
- **Assert:**
  - `product.brand == nike_brand`
  - `product.onec_brand_id == "1C-NIKE-001"`
  - `stats["brand_fallbacks"] == 0`

**Test 2: `test_create_product_placeholder_fallbacks_when_mapping_missing`**

- **Arrange:** НЕ создавать `Brand1CMapping` для onec_id="UNKNOWN-BRAND"
- **Act:** Вызвать `create_product_placeholder(goods_data={"brand_id": "UNKNOWN-BRAND", ...})`
- **Assert:**
  - `product.brand.name == "No Brand"`
  - `product.onec_brand_id == "UNKNOWN-BRAND"`
  - `stats["brand_fallbacks"] == 1`
  - Лог содержит WARNING с текстом "Brand1CMapping not found for onec_id=UNKNOWN-BRAND"

**Test 3: `test_reimport_updates_brand_without_overwriting_onec_brand_id`**

- **Arrange:**
  - Создать товар с `onec_brand_id="1C-ADIDAS-001"`, `brand=no_brand`
  - Создать `Brand1CMapping` (onec_id="1C-ADIDAS-001", brand=adidas_brand)
- **Act:** Повторно импортировать товар с тем же `brand_id`
- **Assert:**
  - `product.brand == adidas_brand` (обновился)
  - `product.onec_brand_id == "1C-ADIDAS-001"` (не изменился)

### Test Commands

```bash
# Все тесты истории
docker compose run --rm backend pytest backend/tests/integration/import/test_product_import.py -k brand -v

# По отдельности
docker compose run --rm backend pytest backend/tests/integration/import/test_product_import.py::test_create_product_placeholder_uses_brand_mapping -v
docker compose run --rm backend pytest backend/tests/integration/import/test_product_import.py::test_create_product_placeholder_fallbacks_when_mapping_missing -v
docker compose run --rm backend pytest backend/tests/integration/import/test_product_import.py::test_reimport_updates_brand_without_overwriting_onec_brand_id -v
```

**Testing Standards:**
- Использовать `pytest` + `pytest-django`, маркировать тесты `@pytest.mark.integration`
- Использовать factoryboy fixtures для создания `Brand`, `Brand1CMapping`, `Product`
- Проверять логи через `caplog` fixture
- Обеспечить ≥90% покрытия для `create_product_placeholder()` метода

[Source: docs/architecture/10-testing-strategy.md#backend-tests---детальная-структура]

## Change Log

| Date | Version | Description | Author |
|---|---|---|---|
| 2025-11-23 | 0.1 | Initial draft for Story 13.4 (product import brand mapping) | SM Agent |
| 2025-11-23 | 0.2 | Fixed validation issues: added Dev Agent Record, file checklist, code snippets, Test Coverage Matrix, data flow diagram, logging examples | SM Agent |

## Dev Agent Record

### Agent Model Used

Заполняется Dev Agent при реализации

### Debug Log References

Заполняется Dev Agent: ссылки на debug-логи, если возникали проблемы

### Completion Notes List

Заполняется Dev Agent:

- [ ] Все задачи выполнены
- [ ] Код изменён согласно спецификации
- [ ] Тесты проходят (≥90% coverage)
- [ ] Логирование и статистика работают
- [ ] Code review пройден
- [ ] Миграции не требуются (поле `onec_brand_id` добавлено в Story 13.2)

### File List

Заполняется Dev Agent: список всех изменённых/созданных файлов с кратким описанием изменений

| File | Change Type | Description |
|---|---|---|
| `processor.py` | Modified | Заменён поиск бренда на Brand1CMapping lookup |
| `parser.py` | Modified | Извлечение brand_id из CommerceML (если требуется) |
| `import_catalog_from_1c.py` | Modified | Обновлены отчёты статистики |
| `test_product_import.py` | Modified | Добавлены интеграционные тесты |
| ... | ... | ... |

## QA Results

Заполняется QA Agent после тестирования

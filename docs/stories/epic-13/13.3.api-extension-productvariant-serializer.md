# Story 13.3: API расширение с ProductVariantSerializer

## Status
Draft

## Story
**Как** Backend разработчик,
**Я хочу** расширить API `/products/{slug}/` полем `variants[]`,
**Чтобы** frontend мог получить все SKU-варианты товара с ценами и остатками.

## Acceptance Criteria

1. Создан `ProductVariantSerializer` в `apps/products/serializers.py`
2. `ProductDetailSerializer` расширен полем `variants = ProductVariantSerializer(many=True, read_only=True)`
3. API endpoint `/products/{slug}/` возвращает массив variants с ценами, остатками, изображениями (FR5)
4. Цены в variants рассчитываются роле-ориентированно через `get_price_for_user(user)`
5. `ProductViewSet.retrieve()` использует `prefetch_related('variants')` для оптимизации
6. OpenAPI спецификация обновлена: `docs/api-spec.yaml` содержит `ProductVariantSchema`
7. Response time <= 500ms для товаров с <= 100 вариантами (NFR1)
8. Написаны API тесты для новых endpoints

## Integration Verification
- IV1: Существующий endpoint `/products/` не изменён (CR1)
- IV2: Endpoint `/categories/` не изменён (CR1)
- IV3: Serializer использует те же роли пользователей

## Tasks / Subtasks

- [ ] Создать ProductVariantSerializer (AC: 1)
  - [ ] Создать класс в `apps/products/serializers.py`
  - [ ] Добавить поля: `id`, `sku`, `color_name`, `size_value`, `stock_quantity`, `is_in_stock`, `available_quantity`
  - [ ] Добавить поля изображений: `main_image`, `gallery_images`
  - [ ] Добавить SerializerMethodField для `current_price` (роле-ориентированная цена)
  - [ ] Добавить SerializerMethodField для `color_hex` (маппинг через ColorMapping)
  - [ ] Пометить поля read_only=True (variants не изменяются через API)

- [ ] Реализовать метод get_current_price (AC: 4)
  - [ ] `get_current_price(self, obj: ProductVariant) -> str`
  - [ ] Получить request.user из context
  - [ ] Вызвать `obj.get_price_for_user(user)`
  - [ ] Вернуть цену как строку (сериализация Decimal)

- [ ] Реализовать метод get_color_hex (AC: 1)
  - [ ] `get_color_hex(self, obj: ProductVariant) -> str | None`
  - [ ] Попытаться найти ColorMapping.objects.get(name=obj.color_name)
  - [ ] Вернуть hex_code если найден, иначе None
  - [ ] Обработать DoesNotExist exception (fallback на None)

- [ ] Расширить ProductDetailSerializer (AC: 2, 3)
  - [ ] Добавить поле `variants = ProductVariantSerializer(many=True, read_only=True)`
  - [ ] Убедиться что variants сериализуются в response `/products/{slug}/`
  - [ ] Проверить вложенную структуру JSON (product.variants[])

- [ ] Оптимизация ProductViewSet.retrieve() (AC: 5, 7)
  - [ ] Обновить метод `retrieve()` в `ProductViewSet`
  - [ ] Добавить `prefetch_related('variants')` к queryset
  - [ ] Также prefetch ColorMapping если используется (избежать N+1 queries)
  - [ ] Протестировать количество SQL queries (должно быть ~3-4 вместо N+1)

- [ ] Обновить OpenAPI спецификацию (AC: 6)
  - [ ] Открыть `docs/api-spec.yaml`
  - [ ] Добавить schema `ProductVariantSchema`:
    ```yaml
    ProductVariantSchema:
      type: object
      properties:
        id: {type: integer}
        sku: {type: string}
        color_name: {type: string}
        size_value: {type: string}
        current_price: {type: string, format: decimal}
        color_hex: {type: string, nullable: true}
        stock_quantity: {type: integer}
        is_in_stock: {type: boolean}
        available_quantity: {type: integer}
        main_image: {type: string, format: uri}
        gallery_images: {type: array, items: {type: string}}
    ```
  - [ ] Обновить `ProductDetailSchema` с полем `variants`:
    ```yaml
    variants:
      type: array
      items:
        $ref: '#/components/schemas/ProductVariantSchema'
    ```
  - [ ] Проверить что спецификация валидна: `docker-compose exec backend python manage.py spectacular --validate`

- [ ] Регенерация TypeScript типов для frontend (AC: 6)
  - [ ] Запустить `npm run generate:types` в frontend/
  - [ ] Проверить что `ProductDetail` включает поле `variants: ProductVariant[]`
  - [ ] Commit обновленный `frontend/src/types/api.generated.ts`

- [ ] Написать API тесты (AC: 8, Coverage >= 90%)
  - [ ] Тест GET `/products/{slug}/` возвращает variants массив
  - [ ] Тест variants содержат корректные поля (sku, color, size, price, stock)
  - [ ] Тест current_price рассчитывается роле-ориентированно (retail vs opt1)
  - [ ] Тест color_hex возвращается из ColorMapping
  - [ ] Тест color_hex = null если ColorMapping не найден
  - [ ] Тест is_in_stock = true/false в зависимости от stock_quantity
  - [ ] Тест prefetch_related используется (количество queries ~3-4)
  - [ ] Тест response time <= 500ms для товара с 100 вариантами (NFR1)

- [ ] Performance тестирование (AC: 7, NFR1)
  - [ ] Создать тестовый Product с 100 ProductVariant через Factory
  - [ ] Измерить response time GET `/products/{slug}/`
  - [ ] Убедиться что время <= 500ms
  - [ ] Проверить количество SQL queries (должно быть O(1), не O(N))
  - [ ] Использовать Django Debug Toolbar или pytest-django `django_assert_num_queries`

- [ ] Проверка Integration Verification (IV1, IV2, IV3)
  - [ ] IV1: GET `/products/` response schema не изменена (list endpoint)
  - [ ] IV2: GET `/categories/` response schema не изменена
  - [ ] IV3: Проверить что current_price использует те же роли (retail, opt1-3, trainer, federation)

## Dev Notes

### Relevant Source Tree
```
backend/apps/products/
├── serializers.py         # ProductVariantSerializer (NEW), ProductDetailSerializer (UPDATE)
├── viewsets.py            # ProductViewSet.retrieve() (UPDATE - prefetch_related)
└── tests/
    ├── test_api_products.py       # API тесты (UPDATE)
    └── test_serializers.py        # Serializer тесты (NEW)

docs/
└── api-spec.yaml          # OpenAPI спецификация (UPDATE)

frontend/
└── src/types/
    └── api.generated.ts   # TypeScript типы (REGENERATE)
```

### ProductVariantSerializer Implementation

**На основе PRD Section 4.2 (API Integration):**

```python
from rest_framework import serializers
from apps.products.models import ProductVariant, ColorMapping
from decimal import Decimal

class ProductVariantSerializer(serializers.ModelSerializer):
    """
    Serializer для ProductVariant с роле-ориентированной ценой
    """
    current_price = serializers.SerializerMethodField()
    color_hex = serializers.SerializerMethodField()
    is_in_stock = serializers.BooleanField(read_only=True)
    available_quantity = serializers.IntegerField(read_only=True)

    class Meta:
        model = ProductVariant
        fields = [
            'id',
            'sku',
            'color_name',
            'size_value',
            'current_price',
            'color_hex',
            'stock_quantity',
            'is_in_stock',
            'available_quantity',
            'main_image',
            'gallery_images',
        ]
        read_only_fields = fields  # Все поля read-only

    def get_current_price(self, obj: ProductVariant) -> str:
        """Получить роле-ориентированную цену для текущего пользователя"""
        request = self.context.get('request')
        user = request.user if request else None

        price = obj.get_price_for_user(user)
        return str(price)  # Сериализация Decimal → str

    def get_color_hex(self, obj: ProductVariant) -> str | None:
        """Получить hex-код цвета из ColorMapping"""
        if not obj.color_name:
            return None

        try:
            mapping = ColorMapping.objects.get(name=obj.color_name)
            return mapping.hex_code
        except ColorMapping.DoesNotExist:
            return None  # Fallback на None (frontend покажет текст)
```

### ProductDetailSerializer Update

**Расширение с полем variants:**

```python
class ProductDetailSerializer(serializers.ModelSerializer):
    """
    Serializer для детальной информации о товаре с вариантами
    """
    variants = ProductVariantSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = [
            'id',
            'name',
            'slug',
            'description',
            'short_description',
            'brand',
            'category',
            'specifications',
            'variants',  # NEW field
            # ... остальные поля
        ]
```

### ProductViewSet Optimization

**prefetch_related для избежания N+1 queries:**

```python
from rest_framework import viewsets
from django.db.models import Prefetch

class ProductViewSet(viewsets.ReadOnlyModelViewSet):
    """
    ViewSet для товаров
    """
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    lookup_field = 'slug'

    def get_serializer_class(self):
        if self.action == 'retrieve':
            return ProductDetailSerializer
        return ProductSerializer

    def retrieve(self, request, *args, **kwargs):
        """
        Retrieve с prefetch variants для оптимизации
        """
        # Optimization: prefetch variants + color mappings
        queryset = Product.objects.prefetch_related(
            Prefetch(
                'variants',
                queryset=ProductVariant.objects.select_related('product')
            )
        )

        self.queryset = queryset
        return super().retrieve(request, *args, **kwargs)
```

### OpenAPI Schema Example

**ProductVariantSchema в api-spec.yaml:**

```yaml
components:
  schemas:
    ProductVariantSchema:
      type: object
      required:
        - id
        - sku
        - current_price
        - stock_quantity
        - is_in_stock
        - available_quantity
      properties:
        id:
          type: integer
          description: ID варианта товара
        sku:
          type: string
          description: Артикул SKU
          example: "NIKE-AM-RED-42"
        color_name:
          type: string
          description: Название цвета
          example: "Красный"
        size_value:
          type: string
          description: Размер
          example: "42"
        current_price:
          type: string
          format: decimal
          description: Цена для текущего пользователя
          example: "5990.00"
        color_hex:
          type: string
          nullable: true
          description: Hex-код цвета (если доступен)
          example: "#FF0000"
        stock_quantity:
          type: integer
          description: Количество на складе
          example: 15
        is_in_stock:
          type: boolean
          description: Доступен для заказа
          example: true
        available_quantity:
          type: integer
          description: Доступное количество (с учетом резерва)
          example: 15
        main_image:
          type: string
          format: uri
          nullable: true
          description: Основное изображение варианта
          example: "/media/products/variants/nike-am-red.jpg"
        gallery_images:
          type: array
          items:
            type: string
            format: uri
          description: Галерея изображений варианта
          example: ["/media/products/variants/nike-am-red-side.jpg"]

    ProductDetailSchema:
      allOf:
        - $ref: '#/components/schemas/ProductSchema'
        - type: object
          properties:
            variants:
              type: array
              items:
                $ref: '#/components/schemas/ProductVariantSchema'
              description: Варианты товара (цвет, размер, цены)
```

### TypeScript Types (api.generated.ts)

**После регенерации:**

```typescript
export interface ProductVariant {
  id: number;
  sku: string;
  color_name?: string;
  size_value?: string;
  current_price: string;  // Decimal as string
  color_hex?: string | null;
  stock_quantity: number;
  is_in_stock: boolean;
  available_quantity: number;
  main_image?: string;
  gallery_images: string[];
}

export interface ProductDetail {
  id: number;
  name: string;
  slug: string;
  description: string;
  // ... other fields
  variants: ProductVariant[];  // NEW field
}
```

### Performance Testing with pytest-django

**Измерение response time и SQL queries:**

```python
import pytest
from django.test import Client
from django.utils import timezone
import time

@pytest.mark.django_db
class TestProductAPIPerformance:
    def test_retrieve_product_with_100_variants_under_500ms(self):
        """
        Response time <= 500ms для товара с 100 вариантами (NFR1)
        """
        # Создать Product с 100 ProductVariant через Factory
        product = ProductFactory()
        ProductVariantFactory.create_batch(100, product=product)

        client = Client()

        # Измерить response time
        start_time = time.time()
        response = client.get(f'/api/products/{product.slug}/')
        elapsed_time = (time.time() - start_time) * 1000  # ms

        assert response.status_code == 200
        assert elapsed_time <= 500, f"Response time {elapsed_time}ms exceeds 500ms"

        # Проверить что variants в response
        data = response.json()
        assert len(data['variants']) == 100

    def test_retrieve_uses_prefetch_related(self, django_assert_num_queries):
        """
        prefetch_related используется (количество queries ~3-4)
        """
        product = ProductFactory()
        ProductVariantFactory.create_batch(10, product=product)

        client = Client()

        # Должно быть ~3-4 queries вместо 11+ (N+1)
        with django_assert_num_queries(4):  # 1 Product + 1 prefetch variants + 2 auth
            response = client.get(f'/api/products/{product.slug}/')

        assert response.status_code == 200
```

### Testing Standards

**Из CLAUDE.md Section: Стратегия тестирования:**

#### Test file location
- `backend/apps/products/tests/test_api_products.py`
- `backend/apps/products/tests/test_serializers.py`

#### Test frameworks
- **Framework:** Pytest 7.4.3 + pytest-django 4.7.0
- **API Client:** Django REST Framework APIClient
- **Factory:** Factory Boy 3.3.0
- **Performance:** pytest-django `django_assert_num_queries`

#### Coverage requirements
- **Minimum coverage:** >= 90% для ProductVariantSerializer и API endpoints
- **Command:** `pytest --cov=apps.products.serializers --cov=apps.products.viewsets`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-30 | 1.0 | Создание Story 13.3 на основе Epic 13 PRD | Sarah (PO) |

## Dev Agent Record
(Заполняется dev-агентом)

## QA Results
(Заполняется QA-агентом)

# Story 18.4: Интеграция поиска в Каталог

## Status

Done

## Story

**As a** пользователь,  
**I want** использовать поиск на странице каталога,  
**so that** находить товары в текущей категории.

## Acceptance Criteria

1. - [x] Поле поиска на странице каталога (под хлебными крошками)
2. - [x] Поиск фильтрует товары текущей категории
3. - [x] URL обновляется: `/catalog/shoes?search=nike`
4. - [x] Совместимость с существующими фильтрами
5. - [x] Очистка поиска сбрасывает фильтр

## Tasks / Subtasks

- [x] **Task 1: Добавление SearchField в CatalogPage** (AC: 1)
  - [x] 1.1. Импортировать `SearchField` из `src/components/ui/SearchField/SearchField.tsx`
  - [x] 1.2. Добавить состояние `searchQuery` в `CatalogContent` компонент
  - [x] 1.3. Разместить `SearchField` под хлебными крошками и перед заголовком категории
  - [x] 1.4. Настроить `minLength={2}` и `debounceMs={300}` для SearchField
  - [x] 1.5. Добавить placeholder="Поиск в каталоге..."

- [x] **Task 2: Интеграция параметра search в ProductFilters** (AC: 2, 4)
  - [x] 2.1. Добавить `search?: string` в интерфейс `ProductFilters` в `productsService.ts`
  - [x] 2.2. Обновить `fetchProducts` callback в `CatalogContent` для передачи `search` параметра
  - [x] 2.3. Обеспечить совместную работу поиска с существующими фильтрами (категория, бренд, цена, наличие)
  - [x] 2.4. При изменении поискового запроса сбрасывать страницу на первую (`setPage(1)`)

- [x] **Task 3: Обновление URL без перезагрузки страницы** (AC: 3)
  - [x] 3.1. Импортировать `useRouter` из `next/navigation`
  - [x] 3.2. Реализовать функцию `updateSearchParams` для обновления query-параметров URL
  - [x] 3.3. Формат URL: `/catalog?category={slug}&search={query}`
  - [x] 3.4. При пустом поисковом запросе удалять параметр `search` из URL

- [x] **Task 4: Чтение параметра search из URL** (AC: 3)
  - [x] 4.1. Добавить чтение `searchParams.get('search')` в `useEffect` при инициализации
  - [x] 4.2. Установить начальное значение `searchQuery` из URL
  - [x] 4.3. Синхронизировать состояние UI с URL при обновлении страницы

- [x] **Task 5: Реализация очистки поиска** (AC: 5)
  - [x] 5.1. Использовать встроенную кнопку очистки в SearchField (уже реализована)
  - [x] 5.2. При очистке (`searchQuery === ''`) удалять параметр `search` из URL
  - [x] 5.3. Обновлять список товаров после очистки поиска
  - [x] 5.4. Добавить кнопку "Сбросить поиск" возле SearchField для лучшего UX

- [x] **Task 6: Обновление handleResetFilters** (AC: 5)
  - [x] 6.1. Добавить сброс `searchQuery` в существующую функцию `handleResetFilters`
  - [x] 6.2. Удалять параметр `search` из URL при сбросе всех фильтров

- [x] **Task 7: UI индикация активного поиска** (AC: 2, 5)
  - [x] 7.1. Добавить индикатор количества найденных товаров рядом с полем поиска
  - [x] 7.2. Показывать сообщение "Найдено N товаров по запросу «X»" при активном поиске
  - [x] 7.3. Стилизовать индикатор согласно Design System v2.0

- [x] **Task 8: Unit-тесты** (AC: 1-5)
  - [x] 8.1. Обновить или создать `src/app/catalog/__tests__/CatalogPage.test.tsx`
  - [x] 8.2. Тест: SearchField отображается на странице каталога
  - [x] 8.3. Тест: Ввод запроса обновляет URL с параметром `search`
  - [x] 8.4. Тест: Поиск комбинируется с существующими фильтрами
  - [x] 8.5. Тест: Очистка поиска удаляет параметр `search` из URL
  - [x] 8.6. Тест: Сброс фильтров сбрасывает и поисковый запрос

---

## Dev Notes

> [!IMPORTANT]
> **Зависимости:** Эта история может выполняться параллельно с 18.1-18.3, так как использует существующий `SearchField` компонент.

### Существующие компоненты для переиспользования

**SearchField** — `src/components/ui/SearchField/SearchField.tsx`
[Source: epic-18-search.md, docs/architecture/04-component-structure.md]

Готовый компонент с:

- `debounceMs` — debounce 300ms (по умолчанию)
- `minLength` — минимальная длина для поиска (по умолчанию 2)
- `onSearch` — callback при изменении debounced значения
- Clear button для очистки
- ARIA-атрибуты для accessibility (`aria-label="Поиск"`)

```typescript
interface SearchFieldProps {
  onSearch?: (value: string) => void;
  minLength?: number;
  suggestions?: string[];
  products?: Array<{ id: number; name: string; price: number }>;
  debounceMs?: number;
  placeholder?: string;
  className?: string;
}
```

---

### CatalogPage — Ключевые места для изменений

[Source: src/app/catalog/page.tsx]

**Текущая структура CatalogContent (строки 327-898):**

Компонент уже содержит:

- `searchParams` из `useSearchParams()` — строка 328
- State для фильтров: `activeCategoryId`, `priceRange`, `selectedBrandIds`, `ordering`, `inStock`
- Функция `fetchProducts` — строка 473
- Функция `handleResetFilters` — строка 559

**Место для SearchField (после хлебных крошек, строки 696-718):**

```tsx
// После breadcrumbs nav (строка 718)
// Перед h1 заголовком (строка 720)
<SearchField
  placeholder="Поиск в каталоге..."
  onSearch={handleSearchChange}
  minLength={2}
  debounceMs={300}
  className="mt-4 max-w-md"
/>
```

---

### Модификация fetchProducts

[Source: src/app/catalog/page.tsx, строки 473-508]

Текущий код:

```typescript
const fetchProducts = useCallback(async () => {
  const filters: ProductFilters = {
    page,
    page_size: PAGE_SIZE,
    ordering,
    min_price: priceRange.min,
    max_price: priceRange.max,
  };
  // ... category, brand, in_stock фильтры
  const response = await productsService.getAll(filters);
}, [activeCategoryId, ordering, page, priceRange, selectedBrandIds, inStock]);
```

**Необходимые изменения:**

```typescript
// Добавить searchQuery в dependencies
const fetchProducts = useCallback(async () => {
  const filters: ProductFilters = {
    page,
    page_size: PAGE_SIZE,
    ordering,
    min_price: priceRange.min,
    max_price: priceRange.max,
  };

  // Добавить поисковый запрос
  if (searchQuery.trim().length >= 2) {
    filters.search = searchQuery.trim();
  }

  // ... остальные фильтры
  const response = await productsService.getAll(filters);
}, [activeCategoryId, ordering, page, priceRange, selectedBrandIds, inStock, searchQuery]);
```

---

### Обновление ProductFilters интерфейса

[Source: src/services/productsService.ts, строки 136-152]

> [!IMPORTANT]
> Текущий интерфейс `ProductFilters` **НЕ содержит** поле `search`. Необходимо добавить его для поддержки поиска в каталоге.

**Текущий интерфейс (без поля search):**

```typescript
export interface ProductFilters {
  page?: number;
  page_size?: number;
  limit?: number;
  category?: string;
  category_id?: number;
  brand?: string;
  min_price?: number;
  max_price?: number;
  ordering?: string;
  in_stock?: boolean;
  is_hit?: boolean;
  is_new?: boolean;
  is_sale?: boolean;
  is_promo?: boolean;
  is_premium?: boolean;
}
```

**После модификации (Task 2.1):**

```typescript
export interface ProductFilters {
  page?: number;
  page_size?: number;
  limit?: number;
  category?: string;
  category_id?: number;
  brand?: string;
  min_price?: number;
  max_price?: number;
  ordering?: string;
  in_stock?: boolean;
  is_hit?: boolean;
  is_new?: boolean;
  is_sale?: boolean;
  is_promo?: boolean;
  is_premium?: boolean;
  search?: string;  // ДОБАВИТЬ
}
```

---

### Управление URL параметрами

[Source: next/navigation documentation]

```typescript
import { useRouter, useSearchParams, usePathname } from 'next/navigation';

const router = useRouter();
const pathname = usePathname();
const searchParams = useSearchParams();

// Обновление URL без перезагрузки
const updateSearchParams = (key: string, value: string | null) => {
  const params = new URLSearchParams(searchParams.toString());
  
  if (value === null || value === '') {
    params.delete(key);
  } else {
    params.set(key, value);
  }
  
  const newUrl = `${pathname}?${params.toString()}`;
  router.push(newUrl, { scroll: false });
};

// Использование
const handleSearchChange = (query: string) => {
  setSearchQuery(query);
  updateSearchParams('search', query || null);
  setPage(1);
};
```

---

### Стилизация SearchField на странице каталога

[Source: docs/frontend/design-system.json, docs/frontend/css-variables-mapping.md]

```tsx
{/* Контейнер поиска под breadcrumbs */}
<div className="mt-4 flex flex-col sm:flex-row items-start sm:items-center gap-4">
  <SearchField
    placeholder="Поиск в каталоге..."
    onSearch={handleSearchChange}
    minLength={2}
    debounceMs={300}
    className="w-full sm:max-w-md"
  />
  
  {/* Индикатор результатов поиска */}
  {searchQuery.trim().length >= 2 && (
    <span className="text-body-s text-text-secondary" aria-live="polite">
      Найдено {totalProducts} товаров по запросу «{searchQuery}»
    </span>
  )}
</div>
```

**Tailwind классы для стилизации:**

| Элемент | Классы |
|---------|--------|
| Контейнер | `mt-4 flex flex-col sm:flex-row items-start sm:items-center gap-4` |
| SearchField | `w-full sm:max-w-md` |
| Индикатор | `text-body-s text-text-secondary` |

---

### Обработка сброса фильтров

[Source: src/app/catalog/page.tsx, строки 559-574]

**Текущий handleResetFilters:**

```typescript
const handleResetFilters = () => {
  setSelectedBrandIds(new Set());
  setPriceRange(DEFAULT_PRICE_RANGE);
  setOrdering(DEFAULT_ORDERING);
  setInStock(true);
  setPage(1);
  // ... сброс категории
};
```

**Необходимые изменения:**

```typescript
const handleResetFilters = () => {
  setSelectedBrandIds(new Set());
  setPriceRange(DEFAULT_PRICE_RANGE);
  setOrdering(DEFAULT_ORDERING);
  setInStock(true);
  setSearchQuery(''); // ДОБАВИТЬ
  setPage(1);
  
  // Очистить параметр search из URL
  updateSearchParams('search', null);
  
  // ... сброс категории
};
```

---

### Файловая структура проекта

[Source: docs/architecture/source-tree.md]

```
frontend/src/
├── app/
│   └── catalog/
│       ├── page.tsx              # МОДИФИКАЦИЯ
│       └── __tests__/            # ОБНОВЛЕНИЕ ТЕСТОВ
│           └── CatalogPage.test.tsx
├── components/
│   └── ui/
│       └── SearchField/          # СУЩЕСТВУЮЩИЙ (без изменений)
│           └── SearchField.tsx
└── services/
    └── productsService.ts        # МОДИФИКАЦИЯ (добавить search в ProductFilters)
```

---

### Требования к Performance

[Source: epic-18-search.md#requirements]

- Debounce 300ms для предотвращения лишних запросов при быстром вводе
- Минимальная длина запроса: 2 символа
- Комбинирование search с существующими фильтрами на стороне backend

---

### Требования к Accessibility

[Source: epic-18-search.md#requirements, coding-standards.md]

- WCAG 2.1 AA
- `aria-label="Поиск в каталоге"` для SearchField
- `aria-live="polite"` для индикатора результатов
- Keyboard navigation поддерживается SearchField из коробки

**Конкретные aria-labels:**

```tsx
<SearchField
  aria-label="Поиск товаров в каталоге"
  placeholder="Поиск в каталоге..."
  // ...
/>

{searchQuery && (
  <span 
    className="text-body-s text-text-secondary"
    aria-live="polite"
    role="status"
  >
    Найдено {totalProducts} товаров по запросу «{searchQuery}»
  </span>
)}
```

---

### Backend API для поиска

[Source: epic-18-search.md, src/services/productsService.ts]

Backend уже поддерживает текстовый поиск через параметр `search`:

```
GET /api/v1/products/?category_id=5&search=nike&page=1&page_size=12
```

PostgreSQL Full-Text Search с русской конфигурацией обрабатывает поисковые запросы.

---

## Testing

### Файлы тестов

- `src/app/catalog/__tests__/CatalogPage.test.tsx` — **ОБНОВЛЕНИЕ**

### Технологический стек тестирования

[Source: docs/architecture/10-testing-strategy.md, docs/architecture/tech-stack.md]

- **Framework:** Vitest 2.1.5
- **Testing Library:** @testing-library/react 16.3.0
- **User Events:** @testing-library/user-event 14.5.1
- **API Mocking:** MSW 2.12.2
- **DOM Environment:** happy-dom 15.11.3

### Паттерны тестирования

[Source: coding-standards.md#frontend-testing]

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
```

### Тестовые сценарии

1. **Отображение SearchField:**
   - SearchField рендерится на странице каталога
   - Placeholder "Поиск в каталоге..." отображается

2. **Интеграция с URL:**
   - Ввод запроса обновляет URL с параметром `search`
   - При загрузке страницы с `?search=nike` поле содержит "nike"

3. **Совместимость с фильтрами:**
   - Поиск работает совместно с фильтром категории
   - Поиск работает совместно с фильтром бренда

4. **Очистка поиска:**
   - Нажатие кнопки очистки сбрасывает поиск
   - Сброс всех фильтров сбрасывает и поиск

### Мокирование next/navigation

```typescript
import { useRouter, useSearchParams, usePathname } from 'next/navigation';

// Mock для productsService
const mockProducts = [
  {
    id: 1,
    name: 'Nike Air Max 90',
    slug: 'nike-air-max-90',
    retail_price: 12990,
    main_image: '/images/nike-air-max.jpg',
    is_in_stock: true,
  },
  {
    id: 2,
    name: 'Nike Dunk Low',
    slug: 'nike-dunk-low',
    retail_price: 9990,
    main_image: '/images/nike-dunk.jpg',
    is_in_stock: true,
  },
];

const mockApiResponse = {
  count: 2,
  next: null,
  previous: null,
  results: mockProducts,
};

vi.mock('@/services/productsService', () => ({
  default: {
    getAll: vi.fn(() => Promise.resolve(mockApiResponse)),
  },
}));

// Mock для next/navigation
vi.mock('next/navigation', () => ({
  useRouter: vi.fn(() => ({
    push: vi.fn(),
    replace: vi.fn(),
  })),
  useSearchParams: vi.fn(() => new URLSearchParams()),
  usePathname: vi.fn(() => '/catalog'),
}));

// Mock для categoriesService и brandsService
vi.mock('@/services/categoriesService', () => ({
  default: {
    getTree: vi.fn(() => Promise.resolve([])),
  },
}));

vi.mock('@/services/brandsService', () => ({
  default: {
    getAll: vi.fn(() => Promise.resolve([])),
  },
}));
```

### Примеры тестов

```typescript
describe('CatalogPage Search Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should display SearchField on catalog page', () => {
    render(<CatalogPage />);
    expect(screen.getByPlaceholderText('Поиск в каталоге...')).toBeInTheDocument();
  });

  it('should filter products when search query is entered', async () => {
    const user = userEvent.setup();
    render(<CatalogPage />);
    
    const searchInput = screen.getByPlaceholderText('Поиск в каталоге...');
    await user.type(searchInput, 'nike');
    
    await waitFor(() => {
      expect(productsService.getAll).toHaveBeenCalledWith(
        expect.objectContaining({ search: 'nike' })
      );
    });
  });

  it('should update URL with search parameter', async () => {
    const mockPush = vi.fn();
    (useRouter as Mock).mockReturnValue({ push: mockPush, replace: vi.fn() });
    
    const user = userEvent.setup();
    render(<CatalogPage />);
    
    const searchInput = screen.getByPlaceholderText('Поиск в каталоге...');
    await user.type(searchInput, 'adidas');
    
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith(
        expect.stringContaining('search=adidas'),
        expect.anything()
      );
    });
  });

  it('should clear search when clear button is clicked', async () => {
    (useSearchParams as Mock).mockReturnValue(new URLSearchParams('search=test'));
    
    const user = userEvent.setup();
    render(<CatalogPage />);
    
    const clearButton = screen.getByLabelText('Очистить поиск');
    await user.click(clearButton);
    
    expect(screen.getByPlaceholderText('Поиск в каталоге...')).toHaveValue('');
  });

  it('should reset search when filters are reset', async () => {
    const user = userEvent.setup();
    render(<CatalogPage />);
    
    // Вводим поисковый запрос
    const searchInput = screen.getByPlaceholderText('Поиск в каталоге...');
    await user.type(searchInput, 'nike');
    
    // Нажимаем кнопку сброса фильтров
    const resetButton = screen.getByText('Сбросить');
    await user.click(resetButton);
    
    expect(searchInput).toHaveValue('');
  });
});
```

### Команды для запуска тестов

```bash
# Запуск всех тестов frontend
cd frontend && npm run test

# Запуск конкретного теста  
npm run test -- CatalogPage

# Запуск тестов с покрытием
npm run test:coverage
```

### Требования к покрытию

[Source: docs/architecture/10-testing-strategy.md]

- Overall: >= 70%
- Модифицированные модули: >= 80%

---

## Change Log

| Date       | Version | Description           | Author       |
|------------|---------|----------------------|--------------|
| 2025-12-21 | 1.0     | Initial story draft   | Scrum Master |
| 2025-12-21 | 1.1     | PO Validation: исправлено противоречие в ProductFilters, добавлены mock данные для тестов | Product Owner |

---

## Dev Agent Record

### Agent Model Used

Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

- ✅ Все acceptance criteria выполнены
- ✅ SearchField интегрирован на страницу каталога под breadcrumbs
- ✅ Параметр `search` добавлен в интерфейс ProductFilters
- ✅ URL обновляется динамически при вводе поискового запроса (debounce 300ms)
- ✅ Поиск работает совместно с существующими фильтрами (категория, бренд, цена, наличие)
- ✅ Реализована очистка поиска через встроенную кнопку SearchField
- ✅ handleResetFilters обновлен для сброса поискового запроса
- ✅ Добавлена UI индикация: "Найдено N товаров по запросу «X»"
- ✅ Все 8 unit-тестов успешно проходят
- ✅ Соблюдены требования WCAG 2.1 AA (aria-label, aria-live, role)

### File List

**Modified:**

- `frontend/src/services/productsService.ts` - добавлен параметр `search?: string` в ProductFilters
- `frontend/src/app/catalog/page.tsx` - интеграция SearchField, URL management, UI индикация

**Created:**

- `frontend/src/app/catalog/__tests__/CatalogPage.test.tsx` - 8 unit-тестов для поисковой функциональности

---

## QA Results

### Review Date: 2025-12-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Оценка: Отлично (95/100)**

Реализация интеграции поиска в каталог выполнена на высоком уровне:

- ✅ Чистая интеграция `SearchField` в существующий `CatalogContent` компонент
- ✅ Корректная работа с URL параметрами через `useSearchParams`, `useRouter`, `usePathname`
- ✅ Правильная реализация debounce (300ms) и минимальной длины (2 символа)
- ✅ Консистентная интеграция с существующими фильтрами (категория, бренд, цена, наличие)
- ✅ Accessibility: `aria-label`, `aria-live="polite"`, `role="status"`
- ✅ Корректная склонение "товар/товара/товаров" в индикаторе результатов

### Refactoring Performed

Рефакторинг не требовался — код написан качественно и следует установленным паттернам проекта.

### Compliance Check

- Coding Standards: ✅ Код следует стандартам TypeScript и React
- Project Structure: ✅ Файлы размещены корректно согласно `source-tree.md`
- Testing Strategy: ✅ 8 unit-тестов покрывают все AC
- All ACs Met: ✅ Все 5 acceptance criteria выполнены

### Improvements Checklist

- [x] SearchField интегрирован под breadcrumbs (AC 1)
- [x] Поиск фильтрует товары с комбинированием существующих фильтров (AC 2, 4)
- [x] URL обновляется динамически: `/catalog?category=...&search=...` (AC 3)
- [x] Очистка поиска сбрасывает фильтр (AC 5)
- [x] Unit-тесты покрывают все сценарии (8 тестов)
- [x] Accessibility атрибуты реализованы

### Security Review

**Status: PASS**

- Поисковый запрос корректно экранируется при передаче в URL
- Нет инъекций в параметры — используются стандартные URLSearchParams
- Backend обрабатывает поиск через PostgreSQL Full-Text Search

### Performance Considerations

**Status: PASS**

- Debounce 300ms предотвращает избыточные API-запросы
- Минимальная длина 2 символа снижает нагрузку
- Запросы комбинируются с существующими фильтрами на стороне backend

### Files Modified During Review

Нет модификаций — код соответствует стандартам качества.

### Gate Status

Gate: **PASS** → `docs/qa/gates/18.4-catalog-search-integration.yml`

### Recommended Status

**✅ Ready for Done**

Все acceptance criteria выполнены, тесты проходят, код соответствует стандартам качества.

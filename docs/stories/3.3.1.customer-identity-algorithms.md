# Story 3.3.1: customer-identity-algorithms

## Status
Ready for Development

## Story
**As a** система,
**I want** точно идентифицировать одного клиента в разных системах,
**so that** избежать дубликатов и обеспечить целостность данных.

## Acceptance Criteria

1. Создан класс `CustomerIdentityResolver` с методом `find_customer_by_identifiers`
2. Реализован поиск по множественным критериям с приоритизацией
3. Настроена нормализация данных (телефоны, имена)
4. Реализован алгоритм схожести строк для ФИО
5. Созданы правила для физ.лиц vs юр.лиц
6. Добавлена защита от false positive совпадений
7. Написаны тесты для всех алгоритмов

### Детальные задачи:

- [ ] Создать CustomerIdentityResolver (AC: 1)
  - [ ] Класс в `apps/users/services/identity_resolution.py`
  - [ ] Метод `find_customer_by_identifiers(**identifiers)`
  - [ ] Поддержка multiple identification methods
  - [ ] Confidence scoring для результатов

- [ ] Реализовать приоритизированный поиск (AC: 2)
  - [ ] **Первичный:** поиск по `onec_id` (100% точность)
  - [ ] **Вторичный:** поиск по `email` (уникальный)
  - [ ] **Третичный:** `phone` + `ФИО` (нечеткое сравнение)
  - [ ] **Четвертичный:** `tax_id` для юридических лиц

- [ ] Настроить нормализацию данных (AC: 3)
  - [ ] Нормализация телефонов: +7, 8, без пробелов и скобок
  - [ ] Нормализация имен: убрать лишние пробелы, привести к Title Case
  - [ ] Нормализация email: lowercase, trim whitespace
  - [ ] Обработка NULL/пустых значений

- [ ] Реализовать схожесть ФИО (AC: 4)
  - [ ] Алгоритм Levenshtein distance для строк
  - [ ] Обработка транслитерации (Иван vs Ivan)
  - [ ] Учет сокращений (Александр vs Саша)
  - [ ] Порог схожести >85% для совпадения

- [ ] Создать правила для типов лиц (AC: 5)
  - [ ] **Физ.лица:** приоритет email > phone + ФИО
  - [ ] **Юр.лица:** приоритет tax_id > email > company_name
  - [ ] Разные алгоритмы для разных типов
  - [ ] Кросс-проверка: физ.лицо не может совпадать с юр.лицом

- [ ] Добавить защиту от ложных срабатываний (AC: 6)
  - [ ] Минимальные пороги для каждого типа поиска
  - [ ] Исключение общих имен (Иванов И.И.)
  - [ ] Проверка на здравый смысл (разные города, даты)
  - [ ] Manual review для пограничных случаев

## Definition of Done
- [ ] Точность идентификации ≥95% на тестовых данных
- [ ] False positive rate <5%
- [ ] Время обработки 1000 клиентов <30 секунд
- [ ] Покрытие тестами ≥90%

## Dev Notes

### Algorithm Architecture
```python
class CustomerIdentityResolver:
    """Сервис идентификации клиентов между системами"""
    
    CONFIDENCE_THRESHOLDS = {
        'onec_id_match': 1.0,      # 100% точность
        'email_match': 0.95,       # 95% точность  
        'phone_fuzzy': 0.85,       # 85% для телефона
        'name_fuzzy': 0.80,        # 80% для имени
        'combined_fuzzy': 0.90,    # 90% для комбинации
    }
    
    def find_customer_by_identifiers(self, **identifiers):
        """Поиск клиента по множественным идентификаторам"""
        candidates = []
        
        # Уровень 1: Поиск по onec_id (высшая точность)
        if identifiers.get('onec_id'):
            candidate = self._find_by_onec_id(identifiers['onec_id'])
            if candidate:
                candidates.append((candidate, self.CONFIDENCE_THRESHOLDS['onec_id_match']))
        
        # Уровень 2: Поиск по email
        if identifiers.get('email') and not candidates:
            candidate = self._find_by_email(identifiers['email'])
            if candidate:
                candidates.append((candidate, self.CONFIDENCE_THRESHOLDS['email_match']))
        
        # Уровень 3: Нечеткий поиск по телефону + ФИО
        if not candidates:
            fuzzy_candidates = self._fuzzy_search(identifiers)
            candidates.extend(fuzzy_candidates)
        
        # Ранжирование и фильтрация
        return self._rank_and_filter_candidates(candidates, identifiers)
    
    def _fuzzy_search(self, identifiers):
        """Нечеткий поиск по частичным данным"""
        candidates = []
        
        # Нормализация входных данных
        normalized = self._normalize_identifiers(identifiers)
        
        # Поиск по телефону
        if phone := normalized.get('phone'):
            phone_candidates = self._find_by_similar_phone(phone)
            for candidate in phone_candidates:
                confidence = self._calculate_phone_confidence(phone, candidate.phone)
                candidates.append((candidate, confidence))
        
        # Поиск по ФИО
        if full_name := normalized.get('full_name'):
            name_candidates = self._find_by_similar_name(full_name)
            for candidate in name_candidates:
                confidence = self._calculate_name_confidence(full_name, candidate.get_full_name())
                candidates.append((candidate, confidence))
        
        return candidates
```

### Name Similarity Algorithm
```python
def calculate_name_similarity(self, name1, name2):
    """Расчет схожести имен с учетом транслитерации"""
    from difflib import SequenceMatcher
    import transliterate
    
    # Нормализация
    name1_norm = self.normalize_name(name1)
    name2_norm = self.normalize_name(name2)
    
    # Прямое сравнение
    direct_similarity = SequenceMatcher(None, name1_norm, name2_norm).ratio()
    
    # Сравнение с транслитерацией
    name1_translit = transliterate.translit(name1_norm, 'ru', reversed=True)
    translit_similarity = SequenceMatcher(None, name1_translit, name2_norm).ratio()
    
    # Сравнение по частям (фамилия, имя, отчество)
    name1_parts = name1_norm.split()
    name2_parts = name2_norm.split()
    parts_similarity = self._compare_name_parts(name1_parts, name2_parts)
    
    # Итоговая схожесть
    return max(direct_similarity, translit_similarity, parts_similarity)

def _compare_name_parts(self, parts1, parts2):
    """Сравнение частей имени"""
    if len(parts1) != len(parts2):
        return 0.0
    
    similarities = []
    for p1, p2 in zip(parts1, parts2):
        # Обработка сокращений
        if self._is_abbreviation(p1, p2):
            similarities.append(0.8)  # Частичное совпадение для сокращений
        else:
            similarities.append(SequenceMatcher(None, p1, p2).ratio())
    
    return sum(similarities) / len(similarities)
```

### Phone Normalization
```python
def normalize_phone(self, phone):
    """Нормализация телефонного номера"""
    if not phone:
        return None
    
    # Убираем все нецифровые символы
    digits_only = re.sub(r'[^\d]', '', phone)
    
    # Обрабатываем российские форматы
    if digits_only.startswith('8') and len(digits_only) == 11:
        return '7' + digits_only[1:]
    elif digits_only.startswith('7') and len(digits_only) == 11:
        return digits_only
    elif len(digits_only) == 10:
        return '7' + digits_only
    
    return digits_only
```

## Story Points
**8** (High complexity due to fuzzy matching algorithms)

## Priority
**High** - Критично для качества синхронизации

## Labels
`epic-3` `identity-resolution` `fuzzy-matching` `algorithms` `data-quality`
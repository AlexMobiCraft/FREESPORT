# Story 15.2: Интеграция с Orders API и email уведомления

## Status

Ready for development

## Story

**As a** разработчик платформы FREESPORT,
**I want** интегрировать форму checkout с Orders API для создания заказов и отправки email уведомлений,
**so that** пользователи могут успешно оформлять заказы, а администратор получает уведомления о новых заказах.

## Acceptance Criteria

1. ✅ Создание заказа через `ordersService.create()`
2. ✅ Заказ создаётся со статусом "Новый"
3. ✅ Email администратору отправляется автоматически (backend обрабатывает)
4. ✅ Синхронизация с cartStore (очистка после успешного оформления)
5. ✅ Обработка ошибок (валидация, сетевые ошибки)
6. ✅ Unit-тесты с MSW моками

## Tasks / Subtasks

### Задача 1: Создание ordersService (AC: 1, 2, 5)

- [ ] Создать файл `src/services/ordersService.ts`
- [ ] Реализовать функцию `createOrder(data: CheckoutFormData, cartItems: CartItem[]): Promise<Order>`
- [ ] Реализовать функцию `getOrderById(orderId: string): Promise<Order>` (для Story 15.4):
- [ ] Использовать `apiClient` из `src/services/api-client.ts` для HTTP запросов
- [ ] Настроить endpoint: `POST /api/v1/orders/`
- [ ] Обработка ответа:

  ```typescript
  interface CreateOrderResponse {
    id: string
    order_number: string
    status: 'new' | 'paid' | 'shipped' | 'delivered'
    total_amount: number
    created_at: string
  }
  ```

- [ ] Обработка ошибок:
  - 400 Bad Request: валидационные ошибки
  - 401 Unauthorized: токен истёк/отсутствует
  - 500 Server Error: ошибка сервера
- [ ] Retry логика для сетевых ошибок (до 3 попыток с exponential backoff)

### Задача 2: Создание orderStore (Zustand) (AC: 1, 4)

- [ ] Создать файл `src/stores/orderStore.ts`
- [ ] Реализовать интерфейс:

  ```typescript
  interface OrderState {
    currentOrder: Order | null
    isSubmitting: boolean
    error: string | null

    // Actions
    createOrder: (data: CheckoutFormData) => Promise<void>
    clearOrder: () => void
    setError: (error: string | null) => void
  }
  ```

- [ ] В действии `createOrder`:
  - Получить товары из `cartStore.items`
  - Вызвать `ordersService.createOrder(data, cartItems)`
  - При успехе: сохранить заказ в `currentOrder`, очистить корзину через `cartStore.clearCart()`
  - При ошибке: сохранить ошибку в `error`
- [ ] Использовать `zustand/middleware` для persist (опционально)

### Задача 3: Интеграция orderStore в CheckoutForm (AC: 1, 4, 5)

- [ ] В `src/components/checkout/CheckoutForm.tsx` импортировать `useOrderStore()`
- [ ] Обновить обработчик `onSubmit`:

  ```typescript
  const { createOrder, isSubmitting, error } = useOrderStore()

  const onSubmit = async (data: CheckoutFormData) => {
    try {
      await createOrder(data)
      // Перенаправление на success страницу (Story 15.4)
      const orderId = useOrderStore.getState().currentOrder?.id
      router.push(`/checkout/success/${orderId}`)
    } catch (err) {
      // Ошибка уже сохранена в orderStore.error
      console.error('Order creation failed:', err)
    }
  }
  ```

- [ ] Отображать состояние загрузки:

  ```tsx
  <Button type="submit" disabled={isSubmitting}>
    {isSubmitting ? 'Оформление...' : 'Оформить заказ'}
  </Button>
  ```

- [ ] Отображать ошибки:

  ```tsx
  {error && (
    <InfoPanel variant="error" className="mb-4">
      {error}
    </InfoPanel>
  )}
  ```

### Задача 4: Очистка корзины после успешного заказа (AC: 4)

- [ ] В `orderStore.createOrder` после успешного ответа:

  ```typescript
  import { useCartStore } from './cartStore'

  createOrder: async (data) => {
    try {
      const response = await ordersService.createOrder(data, get().cartItems)
      set({ currentOrder: response, error: null })

      // Очистка корзины
      useCartStore.getState().clearCart()
    } catch (error) {
      set({ error: error.message })
      throw error
    } finally {
      set({ isSubmitting: false })
    }
  }
  ```

- [ ] Убедиться, что `cartStore.clearCart()` удаляет все товары и сбрасывает состояние

### Задача 5: Email уведомления администратору (AC: 3)

- [ ] **ВАЖНО:** Backend автоматически отправляет email после создания заказа
- [ ] Frontend НЕ отвечает за отправку email
- [ ] Убедиться, что в `POST /api/v1/orders/` нет параметров для email
- [ ] Документация для Dev Agent: "Backend обрабатывает отправку email администратору автоматически при создании заказа. Никакой дополнительной логики на frontend не требуется."

### Задача 6: Unit-тестирование ordersService (AC: 6)

- [ ] Создать `src/services/__tests__/ordersService.test.ts`
- [ ] Настроить MSW моки для `POST /api/v1/orders/`:

  ```typescript
  // src/__mocks__/handlers/ordersHandlers.ts
  import { http, HttpResponse } from 'msw'

  export const ordersHandlers = [
    http.post('/api/v1/orders/', async ({ request }) => {
      const body = await request.json()

      // Успешный ответ
      return HttpResponse.json({
        id: '550e8400-e29b-41d4-a716-446655440000',
        order_number: 'ORD-2025-001',
        status: 'new',
        total_amount: 5000.00,
        created_at: '2025-12-14T12:00:00Z'
      }, { status: 201 })
    })
  ]
  ```

- [ ] Тест-кейсы:
  - Успешное создание заказа
  - Обработка 400 Bad Request (валидационные ошибки)
  - Обработка 401 Unauthorized
  - Обработка 500 Server Error
  - Retry логика при сетевых ошибках

### Задача 7: Unit-тестирование orderStore (AC: 6)

- [ ] Создать `src/stores/__tests__/orderStore.test.ts`
- [ ] Тест-кейсы:
  - `createOrder` успешно создаёт заказ и очищает корзину
  - `createOrder` сохраняет ошибку при сбое
  - `isSubmitting` изменяется корректно (true → false)
  - `clearOrder` сбрасывает currentOrder в null

### Задача 8: Integration-тестирование CheckoutForm с orderStore (AC: 6)

- [ ] Создать `src/components/checkout/__tests__/CheckoutForm.integration.test.tsx`
- [ ] Тест-кейсы:
  - Успешная отправка формы создаёт заказ и перенаправляет на success
  - Кнопка отправки disabled во время isSubmitting
  - Ошибка отображается в InfoPanel при сбое
  - Корзина очищается после успешного заказа
- [ ] Использовать MSW для мокирования API

### Задача 9: Обработка edge cases (AC: 5)

- [ ] Пустая корзина: показать ошибку "Корзина пуста, невозможно оформить заказ"
- [ ] Недостаточный остаток товара: обработать 400 ошибку от backend
- [ ] Сессия истекла (401): перенаправить на страницу login
- [ ] Конфликт промокодов (если применимо): показать понятную ошибку
- [ ] Проверка наличия `cartStore.items` перед отправкой

### Задача 10: Типизация TypeScript (AC: 1, 5)

- [ ] Создать `src/types/order.ts`:

  ```typescript
  export interface Order {
    id: string
    order_number: string
    status: 'new' | 'paid' | 'shipped' | 'delivered'
    total_amount: number
    created_at: string
    delivery_address: Address
    delivery_method: DeliveryMethod
    items: OrderItem[]
  }

  export interface OrderItem {
    variant_id: number        // ID варианта товара из cartStore
    product_id: number        // ID продукта (для отображения)
    product_name: string
    quantity: number
    price: number
    total: number
  }

  export interface CreateOrderPayload {
    // Контактные данные
    email: string
    phone: string
    first_name: string
    last_name: string

    // Адрес доставки
    delivery_address: {
      city: string
      street: string
      house: string
      apartment?: string
      postal_code: string
    }

    // Способ доставки
    delivery_method_id: string

    // Товары из корзины (используем variant_id из cartStore)
    items: Array<{
      variant_id: number    // cart.items[].variant_id → order.items[].variant_id
      quantity: number
    }>

    // Комментарий
    comment?: string
  }
  ```

- [ ] Использовать эти типы в ordersService и orderStore

## Dev Notes

### Архитектурный контекст

**Зависимости от Story 15.1:**

- `CheckoutForm` компонент с обработчиком `onSubmit`
- `CheckoutFormData` тип из `checkoutSchema.ts`
- UI Kit компоненты (`Button`, `InfoPanel`)

**Интеграция с Эпиком 14 (Корзина):**

- `cartStore` для получения товаров и очистки после заказа
- `CartItem` интерфейс для формирования payload

**Интеграция с Эпиком 13 (Аутентификация):**

- `authStore` для получения JWT токена (передаётся в headers)
- Обработка 401 Unauthorized при истёкшем токене

[Source: Epic 15 Description]

### API Endpoint

**POST /api/v1/orders/**

**Request:**

```typescript
{
  "email": "user@example.com",
  "phone": "+79001234567",
  "first_name": "Иван",
  "last_name": "Петров",
  "delivery_address": {
    "city": "Москва",
    "street": "Ленина",
    "house": "10",
    "apartment": "5",
    "postal_code": "123456"
  },
  "delivery_method_id": "courier",  // или "pickup", "transport_company"
  "items": [
    { "variant_id": 123, "quantity": 2 },
    { "variant_id": 456, "quantity": 1 }
  ],
  "comment": "Позвоните за час до доставки"
}
```

**Response (201 Created):**

```typescript
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "order_number": "ORD-2025-001",
  "status": "new",
  "total_amount": 5000.00,
  "created_at": "2025-12-14T12:00:00Z",
  "delivery_method": {
    "id": "courier",
    "name": "Курьер",
    "description": "Доставка курьером до двери"
  },
  "items": [...]
}
```

**Error Responses:**

- `400 Bad Request`: валидационные ошибки (недостаточно товара, невалидные данные)
- `401 Unauthorized`: токен отсутствует или истёк
- `500 Server Error`: внутренняя ошибка сервера

[Source: architecture/03-api-specification.md#Orders API]

### Zustand Store Pattern

**Конвенции:**

```typescript
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

interface OrderState {
  // State
  currentOrder: Order | null
  isSubmitting: boolean
  error: string | null

  // Actions
  createOrder: (data: CheckoutFormData) => Promise<void>
  clearOrder: () => void
  setError: (error: string | null) => void
}

export const useOrderStore = create<OrderState>()(
  devtools(
    (set, get) => ({
      // Initial state
      currentOrder: null,
      isSubmitting: false,
      error: null,

      // Actions
      createOrder: async (data) => {
        set({ isSubmitting: true, error: null })
        try {
          const cartItems = useCartStore.getState().items
          const order = await ordersService.createOrder(data, cartItems)
          set({ currentOrder: order })
          useCartStore.getState().clearCart()
        } catch (error: any) {
          set({ error: error.message || 'Ошибка создания заказа' })
          throw error
        } finally {
          set({ isSubmitting: false })
        }
      },

      clearOrder: () => set({ currentOrder: null, error: null }),
      setError: (error) => set({ error })
    }),
    { name: 'orderStore' }
  )
)
```

[Source: architecture/coding-standards.md#Zustand Store]

### Обработка ошибок

**Типы ошибок:**

1. **Валидационные ошибки (400):**

   ```typescript
   {
     "error": "Validation failed",
     "details": {
       "items": ["Товар prod-123 закончился на складе"]
     }
   }
   ```

2. **Ошибки аутентификации (401):**

   ```typescript
   {
     "error": "Unauthorized",
     "message": "Token expired"
   }
   ```

3. **Серверные ошибки (500):**

   ```typescript
   {
     "error": "Internal server error",
     "message": "Failed to create order"
   }
   ```

**Обработка в ordersService:**

```typescript
try {
  const response = await apiClient.post('/api/v1/orders/', payload)
  return response.data
} catch (error: any) {
  if (error.response?.status === 400) {
    const message = error.response.data.details?.items?.[0] || 'Ошибка валидации'
    throw new Error(message)
  }

  if (error.response?.status === 401) {
    // Перенаправить на login
    router.push('/login')
    throw new Error('Сессия истекла. Войдите заново.')
  }

  throw new Error('Ошибка создания заказа. Попробуйте снова.')
}
```

[Source: architecture/12-error-handling.md]

### Testing с MSW

**Настройка MSW:**

```typescript
// src/__mocks__/server.ts
import { setupServer } from 'msw/node'
import { ordersHandlers } from './handlers/ordersHandlers'
import { cartHandlers } from './handlers/cartHandlers'

export const server = setupServer(...ordersHandlers, ...cartHandlers)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

**Моки для тестов:**

```typescript
// ordersHandlers.ts
export const ordersHandlers = [
  // Успешный кейс
  http.post('/api/v1/orders/create', async () => {
    return HttpResponse.json({
      id: '550e8400-e29b-41d4-a716-446655440000',
      order_number: 'ORD-2025-001',
      status: 'new',
      total_amount: 5000.00
    }, { status: 201 })
  }),

  // Ошибка валидации
  http.post('/api/v1/orders/create-invalid', async () => {
    return HttpResponse.json({
      error: 'Validation failed',
      details: { items: ['Товар закончился'] }
    }, { status: 400 })
  })
]
```

[Source: architecture/10-testing-strategy.md#MSW]

### Performance Considerations

**Retry логика с exponential backoff:**

```typescript
const retryWithBackoff = async (fn: () => Promise<any>, maxRetries = 3) => {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn()
    } catch (error: any) {
      if (attempt === maxRetries - 1 || !isNetworkError(error)) {
        throw error
      }

      const delay = Math.pow(2, attempt) * 1000  // 1s, 2s, 4s
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}
```

**Оптимизация payload:**

- Отправлять только необходимые данные (не весь объект Product, только id и quantity)
- Минимизировать размер JSON
- Не отправлять дубликаты данных (если данные уже есть в профиле)

[Source: architecture/11-security-performance.md]

## Change Log

| Date       | Version | Description                                       | Author          |
|------------|---------|---------------------------------------------------|-----------------|
| 2025-12-14 | 1.0.0   | Создание story для Orders API интеграции         | Bob (SM Agent)  |

## Dev Agent Record

_(Заполняется разработчиком во время реализации)_

### Agent Model Used

_(Название и версия AI-модели)_

### Debug Log References

_(Ссылки на debug логи, если применимо)_

### Completion Notes

_(Заметки о завершении задач и проблемах)_

### File List

_(Список созданных/модифицированных файлов)_

## QA Results

_(Заполняется QA агентом после проверки)_

# Story 2.8: search-api

## Status
Ready for Development

## Story
**As a** покупатель,
**I want** искать товары по названию и артикулу,
**so that** быстро найти нужный товар.

## Acceptance Criteria

1. GET `/products/?search=query` ищет по названию, описанию, артикулу
2. Поиск работает на русском языке
3. Результаты ранжируются по релевантности
4. Поиск комбинируется с существующими фильтрами
5. Performance <500ms для каталогов 10k+ товаров

- [ ] Настроить базовый поиск (AC: 1)
  - [ ] Добавить SearchFilter в Products ViewSet
  - [ ] Настроить поиск по полям: name, description, sku
  - [ ] Добавить search parameter в API
  - [ ] Валидировать search query на XSS
  - [ ] Обработать пустые поисковые запросы

- [ ] Русскоязычный поиск (AC: 2)
  - [ ] Настроить PostgreSQL full-text search
  - [ ] Создать search vector для русского языка
  - [ ] Добавить индексы для GIN search
  - [ ] Настроить stemming для русских слов
  - [ ] Обработать морфологические формы

- [ ] Ранжирование результатов (AC: 3)
  - [ ] Использовать PostgreSQL ts_rank для релевантности
  - [ ] Приоритет: точное совпадение в названии
  - [ ] Средний приоритет: частичное совпадение в названии
  - [ ] Низкий приоритет: совпадение в описании
  - [ ] Сортировка по релевантности по умолчанию

- [ ] Интеграция с фильтрами (AC: 4)
  - [ ] Комбинирование search с category фильтром
  - [ ] Комбинирование с price range фильтрами
  - [ ] Поддержка search + brand фильтрации
  - [ ] Сохранение существующей пагинации
  - [ ] Корректная работа с ordering parameters

- [ ] Оптимизация производительности (AC: 5)
  - [ ] Создание составных индексов для поиска
  - [ ] Ограничение длины search query (max 100 chars)
  - [ ] Кэширование частых поисковых запросов
  - [ ] Профилирование и оптимизация SQL queries
  - [ ] Добавление search analytics для мониторинга

## Dev Notes

### Story Context
**Existing System Integration:**
- Интегрируется с: Product model, существующий Products API
- Технология: PostgreSQL full-text search + DRF filters
- Следует паттерну: Django Q objects для complex queries
- Точки касания: Products ViewSet, database indexes

### Technical Notes
- **Integration Approach:** Расширение существующего ProductFilter через django-filter
- **Existing Pattern Reference:** Django search with Q() objects и PostgreSQL search vectors
- **Key Constraints:** Performance для больших каталогов

### PostgreSQL Search Implementation
```python
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank
from django.db.models import Q

class ProductSearchFilter(django_filters.BaseInFilter):
    def filter(self, qs, value):
        if not value:
            return qs
        
        search_query = value[0] if isinstance(value, list) else value
        
        # Защита от XSS и SQL injection
        if len(search_query) > 100 or '<' in search_query or '>' in search_query:
            return qs.none()
        
        # PostgreSQL full-text search
        search_vector = SearchVector('name', weight='A', config='russian') + \
                       SearchVector('description', weight='B', config='russian') + \
                       SearchVector('sku', weight='A', config='russian')
        
        search_query_obj = SearchQuery(search_query, config='russian')
        
        return qs.annotate(
            search=search_vector,
            rank=SearchRank(search_vector, search_query_obj)
        ).filter(
            search=search_query_obj
        ).order_by('-rank', '-created_at')
```

### Search Index Migration
```sql
-- Создание GIN индекса для полнотекстового поиска
CREATE INDEX products_search_gin_idx ON products 
USING GIN(to_tsvector('russian', name || ' ' || description || ' ' || sku));

-- Составной индекс для поиска с фильтрацией
CREATE INDEX products_search_category_idx ON products(category_id) 
WHERE name IS NOT NULL;
```

### DRF Integration
```python
class ProductFilter(django_filters.FilterSet):
    search = ProductSearchFilter()
    category_id = django_filters.NumberFilter()
    brand = django_filters.CharFilter(field_name='brand__slug')
    min_price = django_filters.NumberFilter(field_name='retail_price', lookup_expr='gte')
    max_price = django_filters.NumberFilter(field_name='retail_price', lookup_expr='lte')
    
    class Meta:
        model = Product
        fields = ['search', 'category_id', 'brand', 'min_price', 'max_price']

class ProductViewSet(viewsets.ReadOnlyModelViewSet):
    filterset_class = ProductFilter
    search_fields = []  # Отключаем DRF SearchFilter в пользу custom
```

### Testing
- Unit тесты для search functionality
- Тестирование русскоязычного поиска
- Performance тесты для больших датасетов
- Проверка интеграции с фильтрами
- Валидация безопасности поисковых запросов

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-16 | 1.0 | Initial brownfield story creation | BMad Orchestrator |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
_TBD - будет заполнено dev агентом_

### Completion Notes List
_TBD - будет заполнено dev агентом_

### File List
_TBD - будет заполнено dev агентом_

## QA Results
_TBD - будет заполнено QA агентом_
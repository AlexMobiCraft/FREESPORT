# Epic 13: Дедупликация брендов при импорте из 1С

## Epic Goal

Устранить дублирование брендов при импорте из 1С, объединяя бренды с одинаковыми названиями (от разных поставщиков) в единую сущность на сайте, сохраняя при этом связь товаров с конкретными ID брендов в 1С для корректной синхронизации заказов.

## Epic Description

### Контекст проблемы

В системе 1С существуют бренды с **одинаковыми названиями**, но **разными UUID** — это происходит из-за того, что разные юридические лица/поставщики создают свои записи брендов независимо друг от друга.

**Пример:**
- Бренд "BoyBo" с ID `fb3f263e-dfd0-11ef-8361-fa163ea88911` (Поставщик A)
- Бренд "BoyBo" с ID `45f84510-c452-11ef-818a-fa163ea88911` (Поставщик B)

При текущей логике импорта (`onec_id` как unique) создаются два бренда "BoyBo" на сайте, что:
- Создаёт путаницу для пользователей в фильтрах каталога
- Ухудшает SEO (дублирование контента)
- Усложняет управление каталогом

### Решение: Master Brand + 1C Mapping

```
┌─────────────────────────────────────────────────────────────┐
│                     Brand (сайт)                            │
│  id=1, name="BoyBo", slug="boybo", normalized_name="boybo"  │
│  ← Уникальный бренд для каталога, фильтров, SEO            │
└─────────────────────────────────────────────────────────────┘
                              ▲
                              │ ForeignKey
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────┴─────────┐    ┌──────┴──────────┐    ┌─────┴─────────┐
│ Brand1CMapping  │    │ Brand1CMapping  │    │    Product    │
│ onec_id=fb3f... │    │ onec_id=45f8... │    │ brand_id=1    │
│ brand_id=1      │    │ brand_id=1      │    │ onec_brand_id │
│ onec_name=BoyBo │    │ onec_name=BOYBO │    │   =fb3f...    │
└─────────────────┘    └─────────────────┘    └───────────────┘
```

**Ключевые принципы:**
1. **Один бренд на сайте** = одно уникальное нормализованное название
2. **Множество маппингов 1С** = все ID брендов из 1С связаны с master-брендом
3. **Связь товара с 1С** = `Product.onec_brand_id` хранит оригинальный UUID бренда из 1С
4. **Синхронизация заказов** = при отправке заказов в 1С используется `onec_brand_id`

### Нормализация названий

Для определения "одинаковости" брендов используется нормализация:
- Приведение к lowercase
- Удаление пробелов
- Удаление спецсимволов

**Примеры:**
- "BoyBo" → "boybo"
- "BOYBO" → "boybo"
- "Boy Bo" → "boybo"
- " boybo " → "boybo"

### Business Value

- **UX:** Пользователи видят один бренд "BoyBo" в фильтрах, а не два
- **SEO:** Нет дублирования страниц брендов
- **Операционная эффективность:** Упрощённое управление каталогом
- **Интеграция:** Сохранена полная связь с 1С для синхронизации

## Stories

### Story 13.1: Модели Brand1CMapping и обновление Brand

**Цель:** Создать архитектуру для хранения маппингов 1С ID на master-бренды

**Acceptance Criteria:**
1. Создана модель `Brand1CMapping` с полями:
   - `brand` (ForeignKey to Brand, CASCADE)
   - `onec_id` (CharField, unique, db_index)
   - `onec_name` (CharField) — оригинальное название из 1С
   - `created_at` (DateTimeField, auto_now_add)
2. В модель `Brand` добавлено поле `normalized_name` (CharField, unique, db_index)
3. Удалено поле `Brand.onec_id` (заменено на Brand1CMapping)
4. Создана функция `normalize_brand_name(name: str) -> str`
5. При сохранении Brand автоматически вычисляется `normalized_name`
6. Создана миграция с корректной обработкой существующих данных

**Tasks:**
- [ ] Создать модель `Brand1CMapping` в `apps/products/models.py`
- [ ] Добавить поле `normalized_name` в модель `Brand`
- [ ] Создать утилиту `normalize_brand_name()` в `apps/products/utils.py`
- [ ] Переопределить `Brand.save()` для автовычисления `normalized_name`
- [ ] Удалить поле `Brand.onec_id`
- [ ] Создать миграцию
- [ ] Написать unit-тесты для `normalize_brand_name()`
- [ ] Написать unit-тесты для модели `Brand1CMapping`

---

### Story 13.2: Поле onec_brand_id в Product

**Цель:** Сохранять связь товара с конкретным 1С ID бренда для синхронизации заказов

**Acceptance Criteria:**
1. В модель `Product` добавлено поле `onec_brand_id` (CharField, nullable, db_index)
2. При импорте товара из 1С `onec_brand_id` заполняется из данных 1С
3. Поле отображается в Django Admin (readonly)
4. Создана миграция

**Tasks:**
- [ ] Добавить поле `onec_brand_id` в модель `Product`
- [ ] Создать миграцию
- [ ] Обновить `ProductAdmin` — добавить поле в fieldsets (readonly)
- [ ] Написать unit-тест

---

### Story 13.3: Обновление логики импорта брендов

**Цель:** Импорт брендов с автоматическим объединением дубликатов по нормализованному имени

**Acceptance Criteria:**
1. Метод `process_brands()` ищет существующий бренд по `normalized_name`
2. Если бренд найден — создаётся только `Brand1CMapping`
3. Если бренд не найден — создаётся новый `Brand` + `Brand1CMapping`
4. Статистика импорта включает `brands_created`, `mappings_created`, `mappings_updated`
5. Логирование: какие бренды были объединены

**Tasks:**
- [ ] Обновить `ProductDataProcessor.process_brands()` в `processor.py`
- [ ] Добавить статистику `mappings_created` в отчёт импорта
- [ ] Добавить логирование объединений
- [ ] Написать integration-тест: импорт двух брендов "BoyBo" и "BOYBO"
- [ ] Написать integration-тест: повторный импорт того же бренда

---

### Story 13.4: Обновление импорта товаров

**Цель:** При импорте товаров сохранять `onec_brand_id` и находить бренд через маппинг

**Acceptance Criteria:**
1. Метод `create_product_placeholder()` ищет бренд через `Brand1CMapping.objects.filter(onec_id=brand_id)`
2. Если маппинг найден — используется связанный `Brand`
3. Если маппинг не найден — создаётся "No Brand" (fallback)
4. `Product.onec_brand_id` заполняется из данных 1С
5. Логирование: если маппинг не найден

**Tasks:**
- [ ] Обновить `create_product_placeholder()` в `processor.py`
- [ ] Обновить поиск бренда: через `Brand1CMapping` вместо `Brand.onec_id`
- [ ] Заполнять `Product.onec_brand_id`
- [ ] Написать integration-тест: импорт товара с существующим маппингом бренда
- [ ] Написать integration-тест: импорт товара с несуществующим маппингом

---

### Story 13.5: Django Admin для управления брендами

**Цель:** Интерфейс администратора для просмотра маппингов и ручного объединения/разъединения брендов

**Acceptance Criteria:**
1. В `BrandAdmin` отображается inline `Brand1CMappingInline` со всеми маппингами
2. В `list_display` отображается количество маппингов (`mappings_count`)
3. Доступно массовое действие "Объединить выбранные бренды" (`merge_brands`)
4. После объединения: все маппинги переносятся на целевой бренд, исходные бренды удаляются
5. Создан `Brand1CMappingAdmin` для управления отдельными маппингами
6. В `Brand1CMappingAdmin` доступно действие "Перенести на другой бренд"

**Tasks:**
- [ ] Создать `Brand1CMappingInline` в `admin.py`
- [ ] Добавить `mappings_count` в `BrandAdmin.list_display`
- [ ] Реализовать action `merge_brands` с выбором целевого бренда
- [ ] Создать `Brand1CMappingAdmin`
- [ ] Реализовать action для переноса маппинга на другой бренд
- [ ] Написать тесты admin actions

---

### Story 13.6: Документация и финальное тестирование

**Цель:** Документировать новую архитектуру и провести полное тестирование

**Acceptance Criteria:**
1. Обновлена документация в `docs/architecture/` — описание новой модели брендов
2. Обновлена документация API (если есть эндпоинты брендов)
3. Проведено полное тестирование с реальными данными из `data/import_1c/`
4. Все тесты проходят успешно
5. Обновлён CLAUDE.md с информацией о новой архитектуре брендов

**Tasks:**
- [ ] Обновить архитектурную документацию
- [ ] Провести интеграционное тестирование с реальными данными
- [ ] Обновить CLAUDE.md
- [ ] Code review и финализация

## Technical Notes

### Функция нормализации

```python
# apps/products/utils.py
import re
import unicodedata

def normalize_brand_name(name: str) -> str:
    """
    Нормализует название бренда для сравнения.

    "BoyBo" → "boybo"
    "BOYBO" → "boybo"
    "Boy Bo" → "boybo"
    " boybo " → "boybo"
    """
    if not name:
        return ""
    # Удаляем акценты и диакритики (é → e)
    name = unicodedata.normalize('NFKD', name)
    name = ''.join(c for c in name if not unicodedata.combining(c))
    # Lowercase
    name = name.lower()
    # Удаляем все пробелы
    name = re.sub(r'\s+', '', name)
    # Удаляем спецсимволы (оставляем только буквы и цифры)
    name = re.sub(r'[^\w]', '', name, flags=re.UNICODE)
    return name
```

### Миграция существующих данных

Поскольку данные будут очищены и загружены заново, сложная data migration не требуется. Однако миграция должна:
1. Создать `Brand1CMapping` таблицу
2. Добавить `normalized_name` в `Brand`
3. Добавить `onec_brand_id` в `Product`
4. Удалить `onec_id` из `Brand`

### Важные ограничения

- `Brand.name` остаётся **не уникальным** (legacy, для безопасности)
- `Brand.normalized_name` — **уникальный** (новый механизм дедупликации)
- `Brand1CMapping.onec_id` — **уникальный** (один 1С ID = один маппинг)
- `Product.brand` — **PROTECT** (нельзя удалить бренд с товарами)
- `Brand1CMapping.brand` — **CASCADE** (при удалении бренда удаляются маппинги)

## Dependencies

- **Epic 3:** Интеграция с 1С (базовый импорт)
- **Модели:** Brand, Product, ImportSession

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Некорректная нормализация (ложные совпадения) | Добавить логирование объединений, возможность ручного разъединения |
| Потеря связи товаров с 1С | `onec_brand_id` сохраняет оригинальный ID |
| Сложность отладки | Подробное логирование, admin inline для просмотра маппингов |

## Definition of Done

- [ ] Все AC выполнены для всех stories
- [ ] Тесты покрывают >80% нового кода
- [ ] Code review пройден
- [ ] Документация обновлена
- [ ] Интеграционное тестирование с реальными данными успешно
- [ ] Нет регрессий в существующем функционале импорта

# Бэклог будущих доработок и улучшений

Цель документа — фиксировать задачи «на потом» так, чтобы любой разработчик мог быстро понять контекст, причину, ожидаемое поведение и где именно править.

---

## Шаблон задачи (копируй секцию целиком)

### [ID] Название

- **Статус**: TODO | IN_PROGRESS | DONE | CANCELED
- **Приоритет**: P0 (Critical) | P1 (High) | P2 (Medium) | P3 (Low)
- **Компонент/область**: (frontend/backend/docs)
- **Источник**: (story/gate/инцидент/код-ревью)

#### Контекст

Коротко: что это за функциональность и где используется.

#### Проблема

Что сейчас работает неправильно / ограниченно. Приведи конкретный пример.

#### Предлагаемое решение

Что именно нужно изменить (желательно пошагово).

#### Acceptance Criteria (AC)

- [ ] ...

#### Затронутые файлы

- `path/to/file.ext` — что там менять

#### Полезные ссылки/документы

- `docs/...` — кратко зачем

#### Риски и тестирование

- **Риски**: ...
- **Как тестировать (manual)**: ...
- **Какие автотесты добавить/обновить**: ...

---

## Задачи

### [FUT-001] VerificationBadge: использовать `verification_status` вместо `is_verified` (поддержка "pending")

- **Статус**: TODO
- **Приоритет**: P2 (Medium)
- **Компонент/область**: frontend
- **Источник**: QA review Story 16.1 (Quinn)

#### Контекст

В профиле B2B-пользователя отображается бейдж статуса верификации (компонент `VerificationBadge`). Сейчас визуальный статус определяется через boolean `user?.is_verified`.

#### Проблема

Текущая логика фактически различает только 2 состояния:
- `verified`
- `unverified`

При этом в модели пользователя предусмотрен `verification_status: 'unverified' | 'verified' | 'pending'`.
В результате состояние "pending" (например, "На проверке") невозможно корректно отобразить.

#### Предлагаемое решение

1. Переключить источник правды для бейджа на `user?.verification_status`.
2. Пробросить `status` в `VerificationBadge` как `user?.verification_status`.
3. Убедиться, что маппинг `VERIFICATION_STATUS_MAP` поддерживает ключ `pending`.
4. Обновить unit/e2e тесты, чтобы явно проверять отображение "На проверке" для B2B пользователя со статусом `pending`.

#### Acceptance Criteria (AC)

- [ ] Для B2B пользователя с `verification_status = 'verified'` показывается бейдж "Верифицирован".
- [ ] Для B2B пользователя с `verification_status = 'pending'` показывается бейдж "На проверке".
- [ ] Для B2B пользователя с `verification_status = 'unverified'` показывается бейдж "Не верифицирован".
- [ ] Обновлены тесты: добавлен кейс на `pending`.

#### Затронутые файлы

- `frontend/src/components/business/ProfileForm/ProfileForm.tsx`
  - Сейчас: `VerificationBadge status={user?.is_verified ? 'verified' : 'unverified'}`
  - Нужно: `VerificationBadge status={user?.verification_status}`
- `frontend/src/components/business/ProfileForm/ProfileForm.test.tsx`
  - Добавить тест/обновить mock пользователя для проверки бейджа "На проверке".
- `frontend/tests/e2e/profile/edit-profile.spec.ts`
  - Добавить/обновить mock API, чтобы возвращать `verification_status: 'pending'` и проверить текст.

#### Полезные ссылки/документы

- `docs/stories/epic-16/16.1.story.md` — требования и контекст Story 16.1
- `docs/qa/gates/16.1-profile-layout.yml` — QA gate PASS и рекомендация FUT-001
- `docs/architecture/02-data-models.md` — модель User (включая `verification_status`)

#### Риски и тестирование

- **Риски**: несоответствие фактического ответа API (если поле `verification_status` ещё не возвращается/называется иначе).
- **Как тестировать (manual)**:
  - Зайти в `/profile` под B2B пользователем со статусом "pending" и убедиться, что бейдж показывает "На проверке".
- **Какие автотесты добавить/обновить**:
  - Unit: кейс `pending` в `ProfileForm.test.tsx`.
  - E2E: сценарий B2B с `verification_status='pending'`.

### [FUT-002] Генерация PDF для заказа (B2B): реализовать настоящий экспорт вместо заглушки

- **Статус**: TODO
- **Приоритет**: P2 (Medium)
- **Компонент/область**: frontend/backend
- **Источник**: story (Story 16.2)

#### Контекст

В Story 16.2 на странице детального просмотра заказа `/profile/orders/[id]` предусмотрена кнопка “Экспорт в PDF” **только для B2B** пользователей.
Сейчас функциональность реализована как заглушка (показывается toast “В разработке”).

#### Проблема

Пользователь B2B не может реально выгрузить документ заказа (состав, суммы, реквизиты) для бухгалтерии/документооборота.
Это блокирует использование раздела “История заказов” как источника документов.

#### Предлагаемое решение

1. Определить целевую стратегию генерации PDF:
   - Server-side: endpoint `GET /api/v1/orders/{id}/export-pdf/` отдаёт `application/pdf`.
   - Client-side: генерация PDF в браузере (например, через `jsPDF`/`react-pdf`) на основе данных заказа.
2. Реализовать авторизацию и проверку доступа:
   - Только владелец заказа.
   - Только B2B пользователь.
3. Реализовать скачивание файла:
   - Корректный filename: `order-<order_number>.pdf`.
4. Обновить UI на `/profile/orders/[id]`:
   - Убрать заглушку, добавить обработку ошибок.
   - Показать toast success/error по результату.
5. Добавить/обновить MSW mocks для тестов (если используется client-side запрос) и автотесты.

#### Acceptance Criteria (AC)

- [ ] Для B2B пользователя кнопка “Экспорт в PDF” доступна на `/profile/orders/[id]`.
- [ ] Для B2C пользователя кнопка не отображается.
- [ ] При клике на “Экспорт в PDF” скачивается валидный PDF файл (не пустой).
- [ ] При попытке скачать чужой заказ возвращается 403/ошибка и показывается корректное уведомление.
- [ ] Ошибки сети/сервера отображаются пользователю через toast.

#### Затронутые файлы

- `frontend/src/app/(profile)/orders/[id]/page.tsx` — заменить заглушку `handleExportPDF` на реальную реализацию
- `frontend/src/services/ordersService.ts` — добавить метод `exportPdf(orderId)` (если выбран server-side вариант)
- `frontend/src/__mocks__/handlers/ordersHandlers.ts` — добавить mock для `GET /orders/:id/export-pdf/` (если будет запрос)
- `backend/apps/**/` — реализовать endpoint `GET /api/v1/orders/{id}/export-pdf/` (если выбран server-side вариант)

#### Полезные ссылки/документы

- `docs/stories/epic-16/16.2.story.md` — контекст кнопки “Экспорт в PDF” и ограничение “только для B2B”
- `docs/architecture/03-api-specification.md` — спецификация Orders API (при расширении)

#### Риски и тестирование

- **Риски**:
  - Различия в форматах данных заказа (B2B реквизиты/поля) и необходимость доп. полей на backend.
  - Большие заказы: производительность генерации/размер PDF.
- **Как тестировать (manual)**:
  - Зайти под B2B пользователем в `/profile/orders/<id>` и скачать PDF; проверить содержимое (номер заказа, список товаров, суммы).
  - Зайти под B2C пользователем и убедиться, что кнопки нет.
- **Какие автотесты добавить/обновить**:
  - E2E (Playwright): проверка наличия кнопки для B2B и факта скачивания файла.
  - Unit: тест обработчика `handleExportPDF` (если логика вынесена в сервис/утилиту).

### [FUT-003] Favorites: реализовать точную проверку доступности варианта через API (вместо `!!product_sku`)

- **Статус**: TODO
- **Приоритет**: P1 (High)
- **Компонент/область**: frontend
- **Источник**: QA review Story 16.3 (Quinn)

#### Контекст

На странице `/profile/favorites` отображается список избранных товаров. Для каждого товара показывается доступность (бейдж "Нет в наличии", состояние кнопки "В корзину").

#### Проблема

Сейчас доступность определяется упрощённо: `isAvailable: !!item.product_sku`.
Это не соответствует доменной модели FREESPORT, где доступность определяется на уровне **ProductVariant** (поля `is_active`, `stock_quantity`, учитывая `reserved_quantity` при необходимости).

#### Предлагаемое решение

1. Определить контракт получения данных варианта по `product_sku`:
   - Вариант A (предпочтительно): backend расширяет `FavoriteSerializer`, добавляя поля доступности варианта (например `variant_is_active`, `variant_stock_quantity`, `variant_reserved_quantity`, `variant_id`).
   - Вариант B: frontend делает дополнительный запрос(ы) за данными варианта по `product_sku` (например, endpoint вида `GET /api/v1/variants/?sku=...`).
2. Обновить `transformFavorites()` так, чтобы `isAvailable` вычислялся на основе данных варианта:
   - минимум: `variant.is_active && variant.stock_quantity > 0`.
3. Обновить добавление в корзину:
   - использовать `variantId` (если cartStore ожидает id варианта), либо согласовать с cart API ожидаемый идентификатор.
4. Обновить unit/e2e тесты:
   - добавить сценарий "нет в наличии" на уровне варианта (не завязанный на `product_sku`).

#### Acceptance Criteria (AC)

- [ ] Доступность в избранном определяется по данным **ProductVariant**, а не по наличию `product_sku`.
- [ ] Для недоступного варианта показывается бейдж "Нет в наличии" и кнопка "В корзину" недоступна.
- [ ] Для доступного варианта кнопка "В корзину" доступна и использует корректный идентификатор (variantId / согласованный id).
- [ ] Обновлены unit-тесты: проверка вычисления доступности по данным варианта.

#### Затронутые файлы

- `frontend/src/app/(profile)/favorites/page.tsx`
  - Заменить упрощённую логику `isAvailable: !!item.product_sku` на вычисление по данным варианта.
- `frontend/src/services/favoriteService.ts`
  - При необходимости расширить сервис (если добавляется запрос варианта).
- `frontend/src/types/favorite.ts`
  - При необходимости расширить тип `FavoriteWithAvailability` (variantId/остатки/флаги).
- `frontend/src/services/__tests__/favoriteService.test.ts`
  - При необходимости добавить/обновить тесты под новый контракт.
- `frontend/e2e/profile/favorites.spec.ts`
  - Добавить/обновить сценарий для недоступного варианта.

#### Полезные ссылки/документы

- `docs/stories/epic-16/16.3.story.md` — контекст реализации избранного и требования по ProductVariant
- `docs/qa/gates/16.3-addresses-favorites.yml` — QA gate и рекомендация FUT-003

#### Риски и тестирование

- **Риски**: потенциальный N+1 запрос на варианты, если делать запрос на каждый favorite; требуется батчинг или расширение serializer.
- **Как тестировать (manual)**:
  - Открыть `/profile/favorites` и проверить, что товары без остатков получают бейдж "Нет в наличии", а доступные — позволяют добавить в корзину.
- **Какие автотесты добавить/обновить**:
  - Unit: тест вычисления `isAvailable` на основе `variant_is_active/variant_stock_quantity`.
  - E2E: сценарий с недоступным вариантом.

### [FUT-004] Addresses: добавить автодополнение адреса через DaData API

- **Статус**: TODO
- **Приоритет**: P2 (Medium)
- **Компонент/область**: frontend
- **Источник**: QA review Story 16.3 (Quinn)

#### Контекст

В `AddressModal` пользователь вручную заполняет поля адреса (город/улица/дом/квартира/индекс). В коде уже оставлен TODO на DaData автодополнение.

#### Проблема

Ручной ввод увеличивает количество ошибок (опечатки, неверный индекс) и ухудшает UX при частом заполнении адресов.

#### Предлагаемое решение

1. Добавить конфигурацию DaData:
   - ключ хранить в переменных окружения (например `NEXT_PUBLIC_DADATA_API_KEY`), без хардкода.
2. Реализовать автодополнение:
   - при вводе в поле (например, `street` или отдельное поле "Адрес") показывать список подсказок.
   - при выборе подсказки — заполнить `city`, `street`, `building`, `postal_code` (и при наличии — квартиру/офис).
3. Убедиться, что при отсутствии ключа автодополнение отключено (фоллбек на ручной ввод).
4. Добавить unit-тесты для поведения автодополнения (мок fetch/axios).

#### Acceptance Criteria (AC)

- [ ] В модальном окне адреса доступен список подсказок при вводе адреса.
- [ ] Выбор подсказки заполняет соответствующие поля формы.
- [ ] При отсутствии API ключа автодополнение не ломает форму и остаётся ручной ввод.
- [ ] Добавлены unit-тесты на автодополнение (моки запросов + сценарий выбора подсказки).

#### Затронутые файлы

- `frontend/src/components/business/AddressModal/AddressModal.tsx`
  - Реализовать UI подсказок и заполнение полей.
- `frontend/src/services/` (новый или существующий сервис)
  - Добавить клиент DaData (если принято выделять в сервис).
- `frontend/src/components/business/AddressModal/AddressModal.test.tsx` (если появится)
  - Добавить тесты поведения автодополнения.

#### Полезные ссылки/документы

- `docs/stories/epic-16/16.3.story.md` — контекст AddressModal и TODO на DaData
- `https://dadata.ru/api/suggest/address/` — документация DaData (suggest)

#### Риски и тестирование

- **Риски**: утечка ключа, если использовать не тот тип ключа; лимиты/квоты DaData.
- **Как тестировать (manual)**:
  - Открыть `/profile/addresses`, нажать "Добавить адрес", начать вводить улицу и выбрать подсказку — убедиться, что поля заполнились.
- **Какие автотесты добавить/обновить**:
  - Unit: мок ответа DaData + выбор подсказки.

### [FUT-005] Tests: добавить unit-тесты для AddressList и FavoritesList

- **Статус**: TODO
- **Приоритет**: P2 (Medium)
- **Компонент/область**: frontend
- **Источник**: QA review Story 16.3 (Quinn)

#### Контекст

Компоненты `AddressList` и `FavoritesList` отвечают за отображение пустого состояния, skeleton состояния загрузки и рендер списка карточек.

#### Проблема

Сейчас в проекте есть тесты для `AddressCard` и `FavoriteProductCard`, а также тесты сервисов и E2E. Однако unit-тестов для `AddressList`/`FavoritesList` (пустое состояние, skeleton, корректная прокидка callbacks) нет.

#### Предлагаемое решение

1. Добавить unit-тесты для `AddressList`:
   - пустое состояние: отображается текст и кнопка "Добавить адрес" вызывает `onAddNew`.
   - loading состояние: отображается skeleton.
   - список: рендерится нужное количество `AddressCard`, корректно прокидываются `onEdit/onDelete`.
2. Добавить unit-тесты для `FavoritesList`:
   - пустое состояние: текст + ссылка на `/catalog`.
   - loading состояние: отображается skeleton grid.
   - список: рендерится `FavoriteProductCard` и корректно вызываются `onAddToCart/onRemoveFavorite`.

#### Acceptance Criteria (AC)

- [ ] Добавлены unit-тесты для `AddressList` (empty/loading/list).
- [ ] Добавлены unit-тесты для `FavoritesList` (empty/loading/list).
- [ ] Тесты следуют AAA pattern и используют Testing Library.

#### Затронутые файлы

- `frontend/src/components/business/AddressList/AddressList.test.tsx` (новый)
- `frontend/src/components/business/FavoritesList/FavoritesList.test.tsx` (новый)

#### Полезные ссылки/документы

- `docs/stories/epic-16/16.3.story.md` — требования по тестам (AC 8) и контекст компонентов
- `docs/architecture/10-testing-strategy.md` — стандарты тестирования (AAA, Testing Library, MSW)

#### Риски и тестирование

- **Риски**: нестабильные тесты из-за зависимостей на `next/link`/`next/image` — потребуется мокирование (как уже сделано в `FavoriteProductCard.test.tsx`).
- **Как тестировать (manual)**: не требуется (unit-level изменение).
- **Какие автотесты добавить/обновить**: только новые unit-тесты (см. выше).

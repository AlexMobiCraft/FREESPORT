# ADR: Логика резервирования товаров при добавлении в корзину

**Статус:** Принято

**Дата:** 2025-09-26

## Context

- Обнаружена проблема overselling: товары не резервировались при добавлении в `CartItem`, что позволяло нескольким пользователям претендовать на последний экземпляр.
- Требовалось обеспечить атомарность операций с корзиной и защиту от гонок при параллельных изменениях количества.
- Архитектура должна была сохранить совместимость с существующими сервисами (`Cart`, `Products`) и не усложнить массовые операции с данными.

## Decision

- Принято решение использовать сигналы Django для управления `reserved_quantity`, сохранив бизнес-логику вне модели `CartItem`.
- Добавлено поле `reserved_quantity` в `Product`, реализованы обработчики `pre_save`/`post_delete` и их регистрация в `apps/cart/apps.py`.
- Все операции обернуты в транзакции для гарантии целостности и корректной синхронизации при конкурентных сценариях.

## Consequences

- **Плюсы:** предотвращение overselling, консистентность данных между корзиной и складом, возможность расширения под новые события.
- **Минусы:** усложнение отладки из-за вынесенной логики сигналов, дополнительная нагрузка на базу данных при большом количестве операций.
- **Технический долг:** мониторинг производительности, доработка поддержки `bulk` операций и интеграция с будущей системой резервирования заказов.

## Контекст

В ходе тестирования была выявлена критическая проблема: при добавлении товара в корзину его количество на складе (`stock_quantity`) не уменьшалось и не резервировалось. Это могло привести к ситуациям, когда несколько пользователей добавляют в корзину последний экземпляр товара, но купить его сможет только первый оформивший заказ. Система не предотвращала перепродажу (overselling) на этапе формирования корзины.

Необходимо было реализовать механизм, который бы атомарно резервировал товар при добавлении в `CartItem` и освобождал его при удалении.

## Рассмотренные варианты

### 1. Прямое изменение в методах модели `CartItem`

- **Описание:** Переопределить методы `save()` и `delete()` в модели `CartItem` для ручного увеличения/уменьшения поля `product.reserved_quantity`.
- **Плюсы:** Простота реализации, вся логика инкапсулирована в одной модели.
- **Минусы:** Этот подход не покрывает случаи массовых операций (`.bulk_create()`, `.delete()` на QuerySet), которые не вызывают индивидуальные методы `save()` и `delete()`. Это делает логику ненадежной.

### 2. Использование сигналов Django (`pre_save`, `post_delete`)

- **Описание:** Создать обработчики сигналов, которые будут срабатывать до сохранения (`pre_save`) и после удаления (`post_delete`) экземпляра `CartItem`. Эти обработчики будут обновлять поле `product.reserved_quantity`.
- **Плюсы:**
    - **Надежность:** Сигналы вызываются для каждой операции сохранения/удаления, включая массовые.
    - **Разделение ответственности (SoC):** Логика резервирования отделена от основной логики модели `CartItem`.
    - **Атомарность:** Позволяет обернуть операции в транзакции для обеспечения целостности данных.
- **Минусы:**
    - Логика становится менее явной, так как она вынесена в отдельный файл `signals.py`.

## Принятое решение

Выбран **Вариант 2: Использование сигналов Django**.

Это решение было принято как наиболее надежное и соответствующее лучшим практикам Django. Оно гарантирует, что логика резервирования будет вызвана при любых операциях с `CartItem`, предотвращая рассинхронизацию данных.

### Детали реализации

1.  **Добавлено поле `reserved_quantity`** в модель `Product`:

    ```python
    # apps/products/models.py
    class Product(models.Model):
        # ...
        reserved_quantity = models.PositiveIntegerField(default=0)
    ```

2.  **Созданы обработчики сигналов** в `apps/cart/signals.py`:

    - `update_reserved_quantity_on_save(sender, instance, **kwargs)`:
        - Срабатывает на `pre_save`.
        - Вычисляет разницу в количестве (`quantity_diff`) между старым и новым состоянием `CartItem`.
        - Атомарно увеличивает `product.reserved_quantity` на `quantity_diff`.

    - `update_reserved_quantity_on_delete(sender, instance, **kwargs)`:
        - Срабатывает на `post_delete`.
        - Атомарно уменьшает `product.reserved_quantity` на количество удаляемого товара.

3.  **Сигналы зарегистрированы** в `apps/cart/apps.py` для их активации при запуске приложения.

## Последствия

- **Положительные:**
    - Система теперь корректно отслеживает зарезервированные товары, что является основой для предотвращения перепродаж.
    - Повышена целостность данных складского учета.
    - Реализация является масштабируемой и надежной.
- **Отрицательные:**
    - Незначительное усложнение кода за счет введения сигналов. Новые разработчики должны быть осведомлены о существовании этой логики.
- **Дальнейшие шаги:**
    - Необходимо убедиться, что при оформлении заказа (`Order`) зарезервированное количество корректно списывается с `reserved_quantity` и `stock_quantity`.
    - Рассмотреть возможность создания фоновой задачи для очистки "зависших" резервов в брошенных корзинах.

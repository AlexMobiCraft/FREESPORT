# Story 2.2: User Management API - Принятые технические решения

**Дата:** 16 августа 2025  
**Статус:** COMPLETED  
**Разработчик:** Claude Sonnet 4

## Обзор

Документ описывает ключевые технические и архитектурные решения, принятые при реализации Story 2.2: User Management API с ролевой системой B2B/B2C и JWT аутентификацией.

## Архитектурные решения

### 1. Email-based аутентификация вместо username

**Решение:** Использование email как USERNAME_FIELD в кастомной User модели

**Обоснование:**
- Email более естественен для пользователей B2B/B2C
- Уникальность email гарантирует отсутствие коллизий
- Соответствует современным практикам UX
- Упрощение процесса восстановления паролей

**Техническая реализация:**
```python
class User(AbstractUser):
    username = None  # Отключаем username
    email = models.EmailField('Email адрес', unique=True)
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
```

**Альтернативы рассмотренные:**
- Дублирование username и email - отклонено из-за избыточности
- Использование phone как альтернативного логина - отложено на будущее

### 2. Ролевая система для B2B/B2C пользователей

**Решение:** 6-уровневая система ролей с различными уровнями доступа

**Роли реализованы:**
- **retail** - Розничный покупатель (базовые цены)
- **wholesale_level1/2/3** - Оптовики трех уровней (оптовые цены)
- **trainer** - Тренер/Фитнес-клуб (специальные цены)
- **federation_rep** - Представитель федерации (федеральные цены)
- **admin** - Администратор (полный доступ)

**Обоснование:**
- Соответствие бизнес-требованиям многоуровневого ценообразования
- Гибкость для добавления новых ролей в будущем
- Четкое разделение B2B и B2C функциональности

**Код реализации:**
```python
ROLE_CHOICES = [
    ('retail', 'Розничный покупатель'),
    ('wholesale_level1', 'Оптовик уровень 1'),
    ('wholesale_level2', 'Оптовик уровень 2'),
    ('wholesale_level3', 'Оптовик уровень 3'),
    ('trainer', 'Тренер/Фитнес-клуб'),
    ('federation_rep', 'Представитель федерации'),
    ('admin', 'Администратор'),
]
```

### 3. JWT токенизация для stateless аутентификации

**Решение:** django-rest-framework-simplejwt для токенной аутентификации

**Параметры токенов:**
- Access token: 60 минут (баланс безопасности/удобства)
- Refresh token: 7 дней (разумный период для переавторизации)
- Алгоритм: HS256 (достаточная безопасность для внутреннего API)

**Обоснование:**
- Stateless архитектура лучше масштабируется
- Мобильные приложения требуют токенной аутентификации
- Микросервисная архитектура в будущем
- Простота интеграции с фронтенд фреймворками

**Альтернативы рассмотренные:**
- Session-based аутентификация - отклонено из-за scaling ограничений
- OAuth2 - избыточно для внутреннего API
- Более длительные токены - отклонено из соображений безопасности

### 4. Валидация B2B полей

**Решение:** Условная валидация company_name и tax_id для B2B ролей

**Логика валидации:**
```python
def validate(self, data):
    role = data.get('role', 'retail')
    b2b_roles = ['wholesale_level1', 'wholesale_level2', 'wholesale_level3', 'trainer', 'federation_rep']
    
    if role in b2b_roles:
        if not data.get('company_name'):
            raise ValidationError("Название компании обязательно для B2B пользователей")
        if not data.get('tax_id'):
            raise ValidationError("ИНН обязателен для B2B пользователей")
```

**Обоснование:**
- Юридические требования для B2B операций
- Валидация на уровне API предотвращает некорректные данные
- Гибкость для различных типов организаций

## Технические решения

### 1. Кастомный UserManager для email аутентификации

**Решение:** Переопределение create_user и create_superuser методов

**Реализация:**
```python
class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError('Email обязателен для создания пользователя')
        
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user
```

**Обоснование:**
- Обеспечивает корректную работу Django admin
- Правильная обработка создания суперпользователей
- Валидация email на уровне менеджера

### 2. Модульная организация views

**Решение:** Разделение views на логические модули в apps/users/views/

**Структура:**
- `authentication.py` - регистрация, логин, refresh токенов
- `profile.py` - управление профилем пользователя
- `misc.py` - вспомогательные эндпоинты (роли)

**Обоснование:**
- Улучшенная читаемость кода
- Упрощение поддержки и развития
- Логическое разделение ответственности
- Подготовка к масштабированию команды

### 3. Comprehensive сериализаторы

**Решение:** 5 специализированных сериализаторов для разных операций

**Сериализаторы:**
- `UserRegistrationSerializer` - регистрация с валидацией B2B полей
- `UserLoginSerializer` - аутентификация с email
- `UserProfileSerializer` - отображение профиля
- `UserProfileUpdateSerializer` - обновление профиля
- `UserRoleSerializer` - список ролей

**Обоснование:**
- Разделение логики создания, чтения и обновления
- Безопасность через ограничение доступных полей
- Специализированная валидация для каждой операции

### 4. Телефонная валидация

**Решение:** RegexValidator для российских номеров телефонов

**Паттерн:** `^\+7\d{10}$` (формат +79001234567)

**Обоснование:**
- Стандартизация формата номеров
- Предотвращение ошибок ввода
- Подготовка к SMS-уведомлениям в будущем
- Соответствие российским стандартам

## Решения по безопасности

### 1. Хэширование паролей

**Решение:** Использование стандартного Django auth backend с PBKDF2

**Обоснование:**
- Проверенная временем система
- Соответствие стандартам безопасности
- Автоматическое обновление алгоритмов в новых версиях Django
- Совместимость с Django admin

### 2. Защита от атак

**Меры безопасности:**
- SQL Injection: Django ORM автоматически защищает
- XSS: DRF автоматически экранирует данные
- CSRF: Токенная аутентификация не подвержена CSRF
- Brute Force: Планируется rate limiting (следующие stories)

### 3. Валидация входных данных

**Решение:** Многоуровневая валидация через DRF serializers

**Уровни валидации:**
1. Field-level validation (тип данных, формат)
2. Object-level validation (бизнес-правила)
3. Custom validators (телефон, ИНН формат)
4. Database constraints (уникальность email)

## Интеграционные решения

### 1. Подготовка к Company модели

**Решение:** B2B поля в User модели как временное решение

**Планируемая эволюция:**
```python
# Текущее состояние
class User(AbstractUser):
    company_name = models.CharField(...)
    tax_id = models.CharField(...)

# Будущая архитектура
class Company(models.Model):
    user = models.OneToOneField(User)
    legal_name = models.CharField(...)
    tax_id = models.CharField(...)
```

**Обоснование:**
- Быстрая реализация MVP функциональности
- Простота миграции в будущем
- Избежание over-engineering на раннем этапе

### 2. Адреса пользователей

**Решение:** Подготовка к связке с Address модели через related_name

**Связь:** `User.addresses` → `Address.user`

**Обоснование:**
- Разделение ответственности между моделями
- Поддержка множественных адресов на пользователя
- Готовность к Story 2.3 (Personal Cabinet)

## Производственные соображения

### 1. Масштабируемость

**Архитектурные решения для роста:**
- Stateless JWT аутентификация
- Индексация по email для быстрого поиска
- Готовность к горизонтальному масштабированию
- Кэширование ролей пользователей (планируется)

### 2. Мониторинг и логирование

**Планируемые метрики:**
- Время регистрации пользователей
- Частота использования refresh токенов
- Распределение пользователей по ролям
- Ошибки аутентификации

### 3. Соответствие GDPR

**Подготовленные механизмы:**
- Мягкое удаление пользователей (is_active=False)
- Возможность экспорта данных пользователя
- Ограничение доступа к персональным данным
- Логирование доступа к пользовательским данным

## Тестирование

### 1. Покрытие функциональности

**Тестируемые сценарии:**
- Регистрация всех типов пользователей
- Валидация B2B полей
- JWT flow (login → access → refresh → logout)
- Профиль пользователя (получение и обновление)
- Безопасность доступа к чужим данным

### 2. Граничные случаи

**Покрытые edge cases:**
- Дублирующиеся email адреса
- Некорректные форматы телефонов
- Отсутствующие B2B поля для wholesale пользователей
- Истекшие и недействительные токены

## Будущие улучшения

### Краткосрочные (следующие 2-4 недели)
1. Rate limiting для защиты от brute force атак
2. Email верификация при регистрации
3. Forgot password функциональность

### Среднесрочные (1-3 месяца)
1. Миграция на отдельную Company модель
2. Two-factor authentication для B2B пользователей
3. Социальная аутентификация (Google, VK)

### Долгосрочные (3-6 месяцев)
1. Single Sign-On (SSO) для корпоративных клиентов
2. Аудит и логирование всех пользовательских действий
3. Advanced permissions система

## Заключение

Story 2.2 заложила прочную основу для пользовательской системы FREESPORT:

✅ **Гибкая ролевая система** - поддержка всех типов B2B/B2C пользователей  
✅ **Современная аутентификация** - JWT токены для stateless архитектуры  
✅ **Безопасность** - многоуровневая валидация и защита  
✅ **Масштабируемость** - готовность к росту пользовательской базы  
✅ **Интеграционная готовность** - подготовка к будущим stories  

Система пользователей полностью готова для поддержки всех планируемых функций платформы FREESPORT.
# Story 2.3: Personal Cabinet API - Принятые технические решения

**Дата:** 16 августа 2025  
**Статус:** COMPLETED  
**Разработчик:** Claude Sonnet 4

## Обзор

Документ описывает ключевые технические и архитектурные решения, принятые при реализации Story 2.3: Personal Cabinet API с дашбордом, управлением адресами и системой избранного.

## Архитектурные решения

### 1. Модульная организация views

**Решение:** Рефакторинг apps/users/views.py в структуру модулей

**Новая структура:**
```
apps/users/views/
├── __init__.py
├── authentication.py    # Регистрация, логин, refresh
├── profile.py          # Профиль пользователя  
├── personal_cabinet.py # Дашборд, адреса, избранное
└── misc.py            # Служебные endpoints (роли)
```

**Обоснование:**
- Улучшенная читаемость и навигация по коду
- Логическое разделение ответственности
- Упрощение командной разработки
- Подготовка к масштабированию функциональности

**Альтернативы рассмотренные:**
- Единый файл views.py - отклонено из-за растущей сложности
- Создание отдельных Django apps - избыточно для текущего этапа

### 2. Агрегированный дашборд для B2B/B2C пользователей

**Решение:** Единый endpoint с дифференцированной логикой по ролям

**Структура дашборда:**
```python
# Общие данные для всех пользователей
{
    "user_info": {...},
    "orders_count": 0,
    "favorites_count": 2,
    "addresses_count": 1,
}

# Дополнительные данные для B2B
{
    "total_order_amount": "0.00",
    "avg_order_amount": "0.00", 
    "is_verified": True,
    "company_name": "ООО Спортмастер"
}
```

**Обоснование:**
- Различная ценность информации для B2B и B2C
- Единый endpoint упрощает фронтенд интеграцию
- Гибкость для добавления ролевых данных

**Альтернативы рассмотренные:**
- Отдельные endpoints для B2B/B2C - отклонено из-за дублирования кода
- Статичный набор полей - отклонено из-за ограниченности

### 3. Система управления адресами

**Решение:** Отдельная Address модель с типами адресов и логикой по умолчанию

**Типы адресов:**
- `shipping` - Адрес доставки
- `legal` - Юридический адрес (для B2B)

**Логика адреса по умолчанию:**
```python
def save(self, *args, **kwargs):
    if self.is_default:
        # Автоматически снимаем флаг default с других адресов пользователя
        Address.objects.filter(
            user=self.user, 
            address_type=self.address_type
        ).update(is_default=False)
    super().save(*args, **kwargs)
```

**Обоснование:**
- Поддержка множественных адресов критична для B2B
- Автоматическое управление default адресом предотвращает ошибки
- Разделение типов адресов упрощает юридические процессы

### 4. Система избранного (Favorites)

**Решение:** Many-to-Many связь через промежуточную модель Favorite

**Архитектура:**
```python
class Favorite(models.Model):
    user = models.ForeignKey(User)
    product = models.ForeignKey(Product)
    added_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ('user', 'product')
```

**Обоснование:**
- Уникальное ограничение предотвращает дублирование
- Временная метка позволяет сортировку по дате добавления
- Простота добавления дополнительных полей (заметки, теги)

**Альтернативы рассмотренные:**
- ManyToManyField без through модели - отклонено из-за ограниченности
- JSON поле в User модели - отклонено из-за производительности

## Технические решения

### 1. Валидация российских почтовых индексов

**Решение:** RegexValidator для 6-значных индексов

**Паттерн:** `^\d{6}$`

**Обоснование:**
- Соответствие российским стандартам почтовых индексов
- Предотвращение ошибок при интеграции с службами доставки
- Подготовка к автоматическому определению регионов

**Код реализации:**
```python
postal_code_validator = RegexValidator(
    regex=r'^\d{6}$',
    message="Почтовый индекс должен состоять из 6 цифр"
)
```

### 2. Permissions и фильтрация данных

**Решение:** Автоматическая фильтрация по текущему пользователю во всех ViewSets

**Реализация:**
```python
class AddressViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return Address.objects.filter(user=self.request.user)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
```

**Обоснование:**
- Гарантированная безопасность данных пользователей
- Предотвращение случайного доступа к чужим данным
- Упрощение логики во frontend

### 3. Оптимизация запросов для избранного

**Решение:** Использование select_related для загрузки данных товаров

**Реализация:**
```python
def get_queryset(self):
    return Favorite.objects.filter(user=self.request.user).select_related(
        'product', 'product__brand', 'product__category'
    ).order_by('-added_at')
```

**Обоснование:**
- Избежание N+1 запросов при получении списка избранного
- Загрузка всех необходимых данных в одном запросе
- Улучшенная производительность для больших списков

### 4. Временные заглушки с документированием

**Решение:** Создание заглушек для интеграции с будущими stories

**Заглушки реализованы:**
- `orders_count` - будет интегрирован в Story 2.7
- `total_order_amount` - агрегация из Order модели
- `avg_order_amount` - вычисляемое поле

**Документирование:**
```python
# TODO_TEMPORARY_FIXES.md
# Story 2.3 временные заглушки для интеграции с Order API
```

**Обоснование:**
- Полнота API для фронтенд разработки
- Четкое планирование будущих интеграций
- Предотвращение breaking changes

## Решения по интеграции

### 1. Связь с Product API

**Решение:** Интеграция избранного с существующей Product моделью

**Интеграция:**
- Проверка существования и активности товара
- Автоматическая очистка при удалении товара
- Использование ролевого ценообразования в отображении

**Код проверки:**
```python
def validate_product(self, value):
    if not value.is_active:
        raise ValidationError("Нельзя добавить неактивный товар в избранное")
    return value
```

### 2. Подготовка к Order API

**Решение:** Структурирование дашборда для легкой интеграции с заказами

**Подготовленные поля:**
- `orders_count` - количество заказов пользователя
- `total_order_amount` - общая сумма заказов
- `avg_order_amount` - средний чек

**Планируемая интеграция:**
```python
# Story 2.7 - реальная реализация
orders_qs = Order.objects.filter(user=user)
dashboard_data.update({
    'orders_count': orders_qs.count(),
    'total_order_amount': orders_qs.aggregate(
        total=Sum('total_amount')
    )['total'] or Decimal('0.00'),
})
```

### 3. Ролевая интеграция

**Решение:** Дифференцированная логика дашборда на основе User.role

**B2B специфичные поля:**
- `is_verified` - статус верификации компании
- `company_name` - название организации
- Расширенная статистика заказов

**Обоснование:**
- Соответствие бизнес-потребностям B2B клиентов
- Подготовка к системе верификации компаний
- Гибкость для добавления новых ролей

## Решения по тестированию

### 1. Comprehensive API тестирование

**Покрытие тестами:**
- Дашборд для всех ролей пользователей
- CRUD операции для адресов
- Логика адреса по умолчанию
- Избранное с валидацией товаров
- Permissions и безопасность доступа

**Тестовые сценарии:**
```python
def test_dashboard_b2b_fields():
    # Проверка B2B специфичных полей
    user = create_user(role='wholesale_level1')
    response = client.get('/api/v1/users/profile/dashboard/')
    assert 'company_name' in response.data
    assert 'is_verified' in response.data
```

### 2. Edge cases тестирование

**Покрытые граничные случаи:**
- Пустые списки адресов и избранного
- Невалидные почтовые индексы
- Попытки доступа к чужим данным
- Удаление товаров из избранного
- Конфликты адресов по умолчанию

## Производственные соображения

### 1. Производительность

**Оптимизации:**
- select_related для избранного
- Эффективные индексы на user_id полях
- Минимальное количество запросов в дашборде

**Планируемые улучшения:**
- Кэширование дашборда для активных пользователей
- Пагинация для больших списков адресов/избранного
- Background task для тяжелых агрегаций

### 2. Масштабируемость

**Архитектурные решения:**
- Модульная организация готова к разделению на микросервисы
- Stateless API для горизонтального масштабирования
- Prepared statements через Django ORM

### 3. Мониторинг

**Планируемые метрики:**
- Время отклика дашборда
- Популярность функций (адреса vs избранное)
- Паттерны использования B2B vs B2C
- Ошибки валидации адресов

## Пользовательский опыт

### 1. Упрощение взаимодействия

**UX решения:**
- Единый дашборд для всех типов пользователей
- Автоматическое управление адресами по умолчанию
- Мгновенное добавление/удаление избранного

### 2. Персонализация

**Ролевая персонализация:**
- B2B пользователи видят бизнес-метрики
- Retail пользователи видят персональную статистику
- Админы получают расширенную информацию

## Будущие улучшения

### Краткосрочные (следующие 2-4 недели)
1. Интеграция реальной статистики заказов (Story 2.7)
2. Валидация адресов через внешние API (DaData)
3. Добавление заметок к избранным товарам

### Среднесрочные (1-3 месяца)
1. Система уведомлений в дашборде
2. Экспорт данных пользователя (GDPR compliance)
3. Групповые операции с адресами и избранным

### Долгосрочные (3-6 месяцев)
1. Персонализированные рекомендации в дашборде
2. Интеграция с CRM системами для B2B
3. Advanced аналитика поведения пользователей

## Заключение

Story 2.3 создала полноценный личный кабинет для всех типов пользователей FREESPORT:

✅ **Модульная архитектура** - готовность к масштабированию и развитию  
✅ **B2B/B2C дифференциация** - персонализированный опыт для разных ролей  
✅ **Удобство использования** - интуитивное управление адресами и избранным  
✅ **Производительность** - оптимизированные запросы и структуры данных  
✅ **Интеграционная готовность** - подготовка к будущим stories  

Личный кабинет обеспечивает все необходимые функции для управления пользовательскими данными и готов к интеграции с остальными компонентами платформы.
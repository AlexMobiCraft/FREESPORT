# Story 2.4: Catalog API - Принятые технические решения

**Дата:** 17 августа 2025  
**Статус:** COMPLETED  
**Разработчик:** Claude Sonnet 4

## Context

- Каталог должен обслуживать и B2B, и B2C пользователей с разными ценами и навигационными потребностями.
- Существующие модели продуктов и категорий требовали расширения для ролей, фильтров и иерархий.
- Бизнес приоритизировал производительность и готовность к дальнейшим интеграциям (поиск, рекомендации, 1С).

## Decision

- Реализовано ролевое ценообразование, расширенная фильтрация и иерархические категории внутри одного Catalog API.
- Использован `django-filter`, оптимизации ORM (`select_related`, `prefetch_related`), а также отдельные endpoints для деревьев категорий и брендов.
- Определены стандарты пагинации, сортировки и отображения B2B информационных цен.

## Consequences

- **Плюсы:** единый API покрывает все роли, высокая производительность, улучшенный UX и готовность к масштабированию.
- **Минусы:** усложнение сериализаторов/фильтров, необходимость строгого контроля тестов и мониторинга при росте каталога.
- **Технический долг:** переход на полнотекстовый поиск (PostgreSQL/Elasticsearch), доработка фасетной фильтрации и кэширования.

## Обзор

Документ описывает ключевые технические и архитектурные решения, принятые при реализации Story 2.4: Catalog API с ролевым ценообразованием, фильтрацией и иерархическими категориями.

## Архитектурные решения

### 1. Ролевое ценообразование в каталоге

**Решение:** Динамическая адаптация цен на основе роли пользователя в сериализаторах

**Логика ценообразования:**
```python
def get_current_price(self, obj):
    request = self.context.get('request')
    if request and hasattr(request, 'user') and request.user.is_authenticated:
        return obj.get_price_for_user(request.user)
    return obj.retail_price  # Для анонимных пользователей
```

**Обоснование:**
- Автоматическая адаптация к роли пользователя без дублирования логики
- Безопасность - каждый пользователь видит только свои цены
- Единообразие с системой ценообразования во всей платформе
- Простота поддержки и изменения правил ценообразования

**Ролевые цены:**
- retail → retail_price (базовая цена)
- wholesale_level1 → opt1_price (1-й уровень оптовых цен)
- wholesale_level2 → opt2_price (2-й уровень оптовых цен)  
- wholesale_level3 → opt3_price (3-й уровень оптовых цен)
- trainer → trainer_price (специальная цена для тренеров)
- federation_rep → federation_price (федеральная цена)

**Альтернативы рассмотренные:**
- Отдельные endpoints для каждой роли - отклонено из-за дублирования
- Передача роли как параметра - отклонено из соображений безопасности

### 2. B2B информационные цены

**Решение:** Условное отображение RRP и MSRP только для B2B пользователей

**Логика отображения:**
```python
def get_recommended_retail_price(self, obj):
    request = self.context.get('request')
    if (request and hasattr(request, 'user') and 
        request.user.is_authenticated and 
        request.user.role in ['wholesale_level1', 'wholesale_level2', 'wholesale_level3', 'trainer', 'federation_rep']):
        return obj.recommended_retail_price
    return None
```

**Обоснование:**
- RRP/MSRP критически важны для B2B клиентов при планировании наценки
- Retail покупатели не нуждаются в этой информации
- Конфиденциальность коммерческой информации
- Соответствие бизнес-требованиям FREESPORT

### 3. Иерархические категории с навигацией

**Решение:** Рекурсивная структура категорий с breadcrumbs и подсчетом товаров

**Архитектура категорий:**
```python
class Category(models.Model):
    parent = models.ForeignKey('self', null=True, blank=True)
    
    @property
    def breadcrumbs(self):
        breadcrumbs = []
        current = self
        while current:
            breadcrumbs.insert(0, {'id': current.id, 'name': current.name})
            current = current.parent
        return breadcrumbs
```

**Features реализованы:**
- Неограниченная вложенность категорий
- Автоматическая генерация навигационной цепочки
- Подсчет активных товаров в каждой категории
- Список дочерних категорий для навигации

**Обоснование:**
- Гибкость для сложных каталогов спортивных товаров
- Улучшенная навигация для пользователей
- SEO оптимизация через структурированные данные
- Подготовка к фасетному поиску

### 4. Комплексная фильтрация товаров

**Решение:** django-filter для декларативной фильтрации с custom логикой

**Установка зависимости:**
```bash
pip install django-filter==23.5
```

**Реализованные фильтры:**
- `category_id` - фильтрация по категории
- `brand` - по ID или slug бренда  
- `min_price`/`max_price` - ценовой диапазон с учетом роли
- `in_stock` - только товары в наличии
- `is_featured` - рекомендуемые товары
- `search` - полнотекстовый поиск

**Умная ценовая фильтрация:**
```python
def filter_by_price_range(self, queryset, name, value):
    request = self.request
    user = request.user if request.user.is_authenticated else None
    
    # Определяем поле цены на основе роли пользователя
    price_field = self.get_price_field_for_user(user)
    
    if name == 'min_price':
        return queryset.filter(**{f'{price_field}__gte': value})
    elif name == 'max_price':
        return queryset.filter(**{f'{price_field}__lte': value})
```

**Обоснование:**
- Фильтрация по актуальным для пользователя ценам
- Высокая производительность через database-level фильтрацию
- Расширяемость для новых типов фильтров
- Интеграция с Django ORM для оптимизации запросов

## Технические решения

### 1. Оптимизация производительности запросов

**Решение:** Comprehensive использование select_related и prefetch_related

**Оптимизации в ProductViewSet:**
```python
def get_queryset(self):
    return Product.objects.filter(is_active=True).select_related(
        'brand', 'category'
    ).prefetch_related(
        'category__parent'  # Для breadcrumbs
    )
```

**Оптимизации в CategoryViewSet:**
```python
def get_queryset(self):
    return Category.objects.filter(is_active=True).prefetch_related(
        'children'  # Для дочерних категорий
    )
```

**Обоснование:**
- Критическая важность производительности для каталогов
- Избежание N+1 проблем при загрузке связанных данных
- Масштабируемость для больших каталогов (>10k товаров)
- Минимизация нагрузки на database

### 2. Полнотекстовый поиск

**Решение:** Поиск по множественным полям через Django ORM

**Реализация:**
```python
def filter_search(self, queryset, name, value):
    return queryset.filter(
        Q(name__icontains=value) |
        Q(sku__icontains=value) |
        Q(description__icontains=value) |
        Q(brand__name__icontains=value)
    )
```

**Обоснование:**
- Простота реализации без внешних зависимостей
- Достаточная функциональность для MVP
- Подготовка к миграции на Elasticsearch в будущем
- Case-insensitive поиск по ключевым полям

**Планируемые улучшения:**
- PostgreSQL Full Text Search
- Elasticsearch для advanced поиска
- Поиск по synonyms и автокомплит

### 3. Сортировка товаров

**Решение:** Множественные опции сортировки через OrderingFilter

**Доступные сортировки:**
- `name` / `-name` - по названию (A-Z / Z-A)
- `price` / `-price` - по цене (возрастание/убывание)
- `created_at` / `-created_at` - по дате добавления (новые/старые)

**Динамическая сортировка по цене:**
```python
def get_ordering(self):
    ordering = self.request.query_params.get('ordering', '-created_at')
    
    if 'price' in ordering:
        # Определяем поле цены на основе роли пользователя
        price_field = self.get_price_field_for_user(self.request.user)
        return ordering.replace('price', price_field)
    
    return ordering
```

**Обоснование:**
- Сортировка по актуальным для пользователя ценам
- Стандартные UX паттерны для e-commerce
- Высокая производительность через database sorting

### 4. Пагинация каталога

**Решение:** PageNumberPagination с настраиваемым размером страницы

**Конфигурация:**
```python
REST_FRAMEWORK = {
    'PAGE_SIZE': 20,
    'PAGE_SIZE_QUERY_PARAM': 'page_size',
    'MAX_PAGE_SIZE': 100
}
```

**Обоснование:**
- Контроль нагрузки на сервер при больших каталогах
- Улучшенный UX через постепенную загрузку
- Flexibility для разных устройств (мобильные vs десктоп)

## Решения по интеграции

### 1. Brands API

**Решение:** Простой список активных брендов с базовой информацией

**Структура ответа:**
```json
{
    "id": 1,
    "name": "Nike",
    "slug": "nike",
    "logo": "/media/brands/nike.png",
    "website": "https://nike.com"
}
```

**Обоснование:**
- Поддержка фильтрации товаров по брендам
- Подготовка к брендовым страницам
- Минимальная необходимая информация для каталога

### 2. Categories Tree API

**Решение:** Отдельный endpoint для навигационного дерева

**Endpoint:** `GET /api/v1/categories-tree/`

**Структура ответа:**
```json
{
    "id": 1,
    "name": "Спорт",
    "children": [
        {
            "id": 2,
            "name": "Футбол",
            "children": []
        }
    ]
}
```

**Обоснование:**
- Оптимизация для frontend навигационных меню
- Отдельный кэш для структуры категорий
- Упрощение рендеринга дерева на клиенте

### 3. Интеграция с User API

**Решение:** Использование request.user для определения роли и цен

**Преимущества:**
- Единая точка истины для ролевой логики
- Автоматическая синхронизация с изменениями ролей
- Безопасность через контекст запроса

## Решения по тестированию

### 1. Ролевое ценообразование

**Тестовые сценарии:**
```python
def test_role_based_pricing():
    # Тест разных цен для разных ролей
    retail_user = create_user(role='retail')
    wholesale_user = create_user(role='wholesale_level2')
    
    # Проверка цен в каталоге
    retail_response = get_catalog(retail_user)
    wholesale_response = get_catalog(wholesale_user)
    
    assert retail_response.data[0]['current_price'] == '3000.00'
    assert wholesale_response.data[0]['current_price'] == '2500.00'
```

### 2. Фильтрация и поиск

**Покрытие тестами:**
- Фильтрация по всем доступным параметрам
- Поиск по разным полям товаров
- Сортировка по цене для разных ролей
- Комбинации фильтров

### 3. Производительность

**Тестирование запросов:**
- Количество SQL запросов при загрузке каталога
- Время отклика при больших объемах данных
- Эффективность фильтрации и сортировки

## Производственные соображения

### 1. Масштабируемость

**Архитектурные решения:**
- Database индексы на часто фильтруемые поля
- Готовность к шардингу каталога по категориям
- Подготовка к CDN для изображений товаров

**Планируемые оптимизации:**
- Redis кэш для категорий и брендов
- Elasticsearch для advanced поиска
- Background sync с 1С для остатков

### 2. Мониторинг каталога

**Ключевые метрики:**
- Время отклика catalog API
- Популярные поисковые запросы
- Эффективность фильтров
- Conversion rate по категориям

### 3. SEO и производительность

**Оптимизации:**
- Структурированные данные для товаров
- Опимизированные meta теги через seo_title/description
- Lazy loading изображений
- Сжатие API ответов

## Пользовательский опыт

### 1. Фасетная навигация

**Реализованные возможности:**
- Иерархические категории с breadcrumbs
- Множественная фильтрация с сохранением состояния
- Умная ценовая фильтрация по роли пользователя
- Быстрый поиск с результатами в реальном времени

### 2. Персонализация каталога

**Ролевые различия:**
- B2B: видят RRP/MSRP, оптовые цены, минимальные заказы
- B2C: видят розничные цены, акции, рекомендации
- Анонимные: базовый каталог с розничными ценами

## Будущие улучшения

### Краткосрочные (следующие 2-4 недели)
1. Фильтрация по характеристикам (specifications JSON)
2. Сравнение товаров
3. Wishlist интеграция с Favorites API

### Среднесрочные (1-3 месяца)
1. Elasticsearch для продвинутого поиска
2. Персонализированные рекомендации
3. A/B тестирование сортировок

### Долгосрочные (3-6 месяцев)
1. AI-powered search и recommendations
2. Динамическое ценообразование
3. Интеграция с inventory management системами

## Заключение

Story 2.4 создала мощный и гибкий каталог товаров для FREESPORT:

✅ **Ролевое ценообразование** - автоматическая адаптация цен к типу пользователя  
✅ **Comprehensive фильтрация** - поиск, сортировка, категории, бренды  
✅ **Производительность** - оптимизированные запросы для больших каталогов  
✅ **B2B функциональность** - информационные цены, минимальные заказы  
✅ **Масштабируемость** - готовность к росту каталога и нагрузки  

Catalog API обеспечивает все необходимые функции для продажи спортивных товаров всем типам клиентов с учетом их специфических потребностей.